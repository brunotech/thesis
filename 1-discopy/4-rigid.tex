%!TEX root = ms.tex

In this section, we describe the module \py{rigid}, an implementation of
rigid monoidal categories.
We present \emph{snake removal}, the algorithm for normalising rigid diagrams, and its application to the semantics of \emph{pregroup grammars}.
Note that rigid categories are also called \emph{autonomous} \cite{JoyalStreet88,Delpeuch14a}, they are equivalent to the compact 2-categories of Preller, Lambek \cite{PrellerLambek07} with one object.

A (strict) monoidal category $\mathbf{C}$ is \emph{rigid} when every object $x$
has left and right adjoints $x^l$ and $x^r$ and four morphisms
$x \otimes x^l \xto{\epsilon} 1 \xto{\eta} x^l \otimes x$ and
$x^r \otimes x \xto{\epsilon'} 1 \xto{\eta'} x \otimes x^r$ depicted as cups and caps,
subject to $(\epsilon' \otimes 1_x) \circ (1_x \otimes \eta') = 1_x = (1_x \otimes \epsilon) \circ (\eta \otimes 1_x)$.
Note that any monoidal functor between rigid categories is isomorphic to a rigid functor, i.e. which sends cups to cups and caps to caps.

In a rigid category, left and right adjoints are unique up to a unique isomorphism.
They cancel each other --- i.e. $(x^l)^r = x = (x^r)^l$ --- and they are anti-homomorphisms of the tensor product --- i.e. $1^l = 1^r = 1$, $(x \otimes y)^l = y^l \otimes x^l$ and $(x \otimes y)^r = y^r \otimes x^r$.
Thus, the adjoint of a product can always be written as a product of adjoints.
Given a set of atomic types $\Sigma_0$, the objects of the free rigid category are given by lists of pairs $(x, n) \in \Sigma_0 \times \bb{Z}$ with the inclusion $\Sigma_0 \injects \Sigma_0 \times \bb{Z}$ defined by $x \mapsto (x, 0)$ and the adjoints $(x, n)^l = (x, n - 1)$ and $(x, n)^r = (x, n + 1)$.
We define a \emph{rigid signature} $\Sigma$ as a pair of sets $\Sigma_0, \Sigma_1$ with a pair of functions $\mathtt{dom}, \mathtt{cod} : \Sigma_1 \to (\Sigma_0 \times \bb{Z})^\star$,
then the free rigid category is given by the quotient $\mathbf{RC}(\Sigma) = \mathbf{MC}(\Sigma') / \cal{R}$
where $\Sigma'$ is the monoidal signature with $\Sigma'_0 = \Sigma_0 \times \bb{Z}$ and $\Sigma'_1 = \Sigma_1 + \set{\mathtt{cup}_x : x \otimes x^r \to 1, \mathtt{cap}_x : 1 \to x \otimes x^l}_{x \in \Sigma'_0}$.
The cups and caps for the unit are the identity, those for $x \otimes y$ are given by nesting the cups and caps of $x$ and $y$.
The relations $\cal{R}$ are given by the snake equation for every $x \in \Sigma'_0$:
\begin{center}
\input{1-discopy/figures/snake-equation}
\end{center}

The \py{rigid} module implements classes \py{Ty}, \py{Diagram}, \py{Box} and \py{Functor} which subclass those from \py{monoidal}.
Pregroup types, i.e. the objects of free rigid categories, are implemented as \py{Ty}-instances \py{x} with two attributes \py{x.l} and \py{x.r} for the adjoints.
\py{Box} has two subclasses \py{Cup} and \py{Cap} implementing the adjunction for simple types.
The \py{Diagram} class has two static methods \py{cups} and \py{caps} which implement the adjunction for product types.
The \py{normalize} and \py{normal\_form} methods are overriden to implement snake removal: for each pair of cup and cap forming a snake, we first apply interchangers to make them adjacent, then replace the snake with an identity, see \cite[Definition 2.12]{DunnVicary19}.

\begin{example}
A rigid category is compact-closed if it is also symmetric monoidal.
In that case, the left and right adjoints coincide.
The category of matrices over a commutative semiring with Kronecker product as tensor is compact-closed, thus it is rigid.
\end{example}

\begin{example}\label{example-pregroup}
Lambek's pregroup grammars \cite{Lambek99,Lambek01,Lambek08} can be defined in terms of free rigid categories.
Indeed, a pregroup is a thin rigid category, i.e. with at most one arrow between any two objects.
A pregroup grammar $G$ is given by a vocabulary $V$, a finite set of basic types $B$ with $s \in B$ the sentence type and a finite dictionnary $D \sub V \times (B \times \bb{Z})^\star$ assigning pregroup types to words.
Let $\Sigma_G$ be the rigid signature with generating objects $V + B$ and arrows $w \to t$ for each dictionnary entry $(w, t) \in D$ and $\mathbf{G} = \mathbf{RC}(\Sigma_G)$.
The language of $G$ is given by $L(G) = \set{u \in V^\star \ \vert \ \exists \ f : u \to s \in \mathbf{G}}$.
That is, a list of words $u \in V^\star$ is a grammatical sentence whenever there is a diagram $f = g \circ d$ with $d : u \to t$ a product of dictionnary entries and $g : t \to s$ a pregroup derivation generated by cups and caps.
We do not draw the wires for words and depict the dictionnary entries as triangles. For example, let $B = \set{s, n}$ and $D = \set{\text{one, two, three} \to n, \s \text{plus} \to n^r \otimes n \otimes n^l, \s \text{equals} \to n^r \otimes s \otimes n^l}$, then ``one plus two equals three'' is a grammatical sentence:
\begin{center}
\input{1-discopy/figures/pregroup-reduction}
\end{center}
\end{example}

\begin{example}
For any monoidal category $\mathbf{C}$, there is a free rigid category $A(\mathbf{C})$ with a fully-faithful monoidal functor $\mathbf{C} \injects A(\mathbf{C})$, see \cite{Delpeuch14a}.
Concretely, this means that in a rigid diagram with boxes coming from a monoidal category, if the domain and codomain have no adjoint types then all snakes can be removed.
This allows to give a semantics to a pregroup grammar $G$ as a rigid functor $F : \mathbf{G} \to A(\mathbf{C})$.
For example, let $\text{one, two} : 1 \to n$ and $\text{plus} : n \times n \to n$ be functions, then we can compute the meaning of ``one plus two'':
\begin{center}
\input{1-discopy/figures/snake-removal} $\quad \mapsto \quad 3$
\end{center}
where the first step is snake removal and the second is function evaluation as in appendix~\ref{3-cartesian}.
\end{example}
