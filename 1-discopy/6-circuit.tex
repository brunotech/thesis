%!TEX root = ms.tex

Quantum circuits are a standard model for quantum computation.
They form the arrows of a PROP, i.e. a symmetric monoidal category generated by one object, called a qubit.
We define $\mathbf{Circ}$ as the free PROP generated by
$n$-qubit gates $g : n \to n$,
scalars $\{s : 0 \to 0\}_{s \in \bb{C}}$,
post-selection $\{\mathtt{bra}_i : 1 \to 0\}_{i \in \{0, 1\}}$
and preparation $\{\mathtt{ket}_i : 0 \to 1\}_{i \in \{0, 1\}}$ of ancilla qubits in the computational basis.
Circuit evaluation is defined as a monoidal functor $\mathtt{eval} : \mathbf{Circ} \to \mathbf{Tensor}_\bb{C}$ which sends each gate $g : n \to n$ to its unitary matrix $\mathtt{eval}(g) : 2^n \to 2^n$.

Given the circuit for an $n$-qubit state $c : 0 \to n$, measurement results are a tensor $\mathtt{measure}(c) : 1 \to 2^n$ of non-negative reals in $\mathbf{Tensor}_{\bb{R}^+}$, computed using the Born rule.
Note that if a circuit contains scalars or post selection, the measurement results need not be a normalised probability distribution.

The quotient $\mathbf{Circ}_\sim$, where $c = c'$ iff $\mathtt{eval}(c) = \mathtt{eval}(c')$, is a compact-closed category.
Cups and caps are given by the (unnormalised) Bell effect and state, the snake equation implies the correctness of the teleportation protocol.
See \cite{CoeckeKissinger17} for an introduction to diagrammatic reasoning and quantum processes.

\begin{class}\normalfont\texttt{Circuit(dom, cod, boxes, offsets)}
is a subclass of \py{rigid.Diagram} with \py{PRO}-instances as \py{dom} and \py{cod}. It has methods \py{eval}, implemented as a \py{TensorFunctor}, and \py{measure} which computes the Born rule.
\end{class}

\begin{class}\normalfont\texttt{Bra(b\_0, ..., b\_n)} and \normalfont\texttt{Ket(b\_0, ..., b\_n)} are
subclasses of \py{Circuit} and \py{rigid.Box} given by a bitstring \py{b\_0, ..., b\_n}.
\end{class}

\begin{class}\normalfont\texttt{Gate(name, n\_qubits, array)}
is a subclass of \py{Circuit} and \py{rigid.Box} with instances \py{H}, \py{CX}, \py{SWAP}, etc. Phases are implemented as subclasses \py{Rx} and \py{Rz}.
\end{class}

\begin{class}\normalfont\texttt{CircuitFunctor(ob, ar)}
is a subclass of \py{rigid.Functor} where \py{ob} and \py{ar} are mappings from \py{Ty} to \py{PRO} and from \py{Box} to \py{Circuit} respectively.
\end{class}

The methods \py{to\_tk} and \py{from\_tk} translate back and forth between DisCoPy's \py{Circuit} class and that of t$\vert$ket$\rangle$ \cite{SivarajahEtAl20}, which can then be compiled and executed on quantum hardware or simplified using \texttt{pyzx} \cite{KissingervandeWetering19}.
Note that in the translation from DisCoPy diagrams to the directed acyclic graphs of t$\vert$ket$\rangle$, we treat the \py{SWAP} gate as a logical gate, i.e. it simply renames the two qubits.
In the other direction, we introduce \py{SWAP} gates whenever a t$\vert$ket$\rangle$ gate is applied to non-adjacent qubits.
Thus, \py{from\_tk(c.to\_tk())} is equal to the original circuit \py{c} up to the axioms of symmetric monoidal categories.

\begin{example}
The quantum algorithms for natural language processing (NLP) of \cite{ZengCoecke16} can be defined as rigid functors $\mathbf{G} \to \mathbf{Circ}$ from a pregroup grammar (see examples~\ref{example-pregroup} and \ref{example-discocat}) to the category of circuits.
See \cite{Coecke19} for a discussion of distributional compositional models for NLP on quantum hardware.
A proof-of-concept was implemented using \normalfont{DisCoPy}, see the notebook of the first experiments \href{https://github.com/oxford-quantum-group/discopy/blob/master/notebooks/qnlp-experiment.ipynb}{here} and \href{https://medium.com/cambridge-quantum-computing/quantum-natural-language-processing-748d6f27b31d}{there} \cite{Meichanetzidis20} for more details.
\end{example}
