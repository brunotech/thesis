%!TEX root = ms.tex

We give a brief introduction to the concepts of signatures, free categories
and functors, fixing some notation for the rest of the paper.
We then describe how these concepts, once implemented in Python, give the
architecture of \py{cat}, the first module of the DisCoPy package.

A \emph{simple signature} $\Sigma$ is given by a pair of sets $\Sigma_0, \Sigma_1$ of generating objects and arrows, and a pair of functions
$\mathtt{dom}, \mathtt{cod} : \Sigma_1 \to \Sigma_0$ called the domain and the codomain
respectively.
A morphism of signatures $F : \Sigma \to \Sigma'$ is a pair of functions
$F_0 : \Sigma_0 \to \Sigma'_0$, $F_1 : \Sigma_1 \to \Sigma'_1$ which commute with $\mathtt{dom}$ and $\mathtt{cod}$.
The \emph{free category} $\mathbf{C}(\Sigma)$ generated by a signature $\Sigma$, is
defined as follows: the objects are given by $\Sigma_0$ and an arrow
$f : s \to t$ is given by a list $f = f_1 ... f_n \in \Sigma_1^n$ such that
$\mathtt{dom}(f_1) = s, \mathtt{cod}(f_n) = t$ and $\mathtt{cod}(f_i) = \mathtt{dom}(f_{i + 1})$
for all $i \leq n$. Identity arrows are given by the empty list and composition
is given by list contatenation.
The universal property of $\mathbf{C}(\Sigma)$ may be stated as follows: functors
$F : \mathbf{C}(\Sigma) \to \mathbf{D}$ from a free category are uniquely defined by
their image on the signature $\Sigma$, i.e. by a morphism of signatures
$F : \Sigma \to U(\mathbf{D})$ for $U$ the forgetful functor.
These abstract definitions are implemented in an object-oriented fashion with
the following Python classes, where the tuples denote the arguments to the
corresponding class constructors.

\begin{class}\normalfont\texttt{cat.Ob(name)} is given by any Python object \py{name}.
Equality of objects is given by the equality of names, i.e. \py{x == y}
if and only if \py{x.name == y.name}.
\end{class}

\begin{class}\normalfont\texttt{cat.Arrow(dom, cod, boxes)} is given by a pair of \py{Ob}-instances
\py{dom, cod} and a sequence of \py{Box}-instances \py{boxes}.
Axioms are checked at initialisation, \py{AxiomError} is raised otherwise.
An \py{Arrow}-instance \py{f} has the following methods:

\begin{itemize}
\item \py{f.dagger()} returns the dagger of an arrow,
it has syntactic sugar \py{f[::-1]}.
\item \py{f.then(g)} returns the composition of two arrows,
it is written \py{f >> g} or \py{g << f}.
\item \py{Arrow.id(x)} returns the identity arrow
on a given object, it is shortened to \py{Id(x)}.
\end{itemize}
Axioms are implemented as part of the testing suite for the DisCoPy
package: associativity \py{f >> (g >> h)}
\s \py{== (f >> g) >> h} and unitality
\py{f >> Id(f.cod) == f == Id(f.dom) >> f} follow directly from the monoid
structure of Python sequences.
\py{Arrow}-instances can be manipulated using the standard Python syntax for
sequences: they are iterable, indexable and sliceable, i.e.
\py{f[i] == f.boxes[i]} and \py{f[i:j]} returns the arrow \py{f[i] >> ...}
\py{>> f[j]}.
Printing an arrow yields a DisCoPy expression which generates it,
which proves useful for debugging and interactive programming.
\end{class}

\begin{class}\normalfont\texttt{cat.Box(name, dom, cod, data=None, \_dagger=False)} is a subclass of \py{Arrow}, i.e. a box \py{f} is defined as an arrow with \py{f.boxes == [f]}.
\py{data} is an optional argument, it can be used to attach arbitrary Python data to a box.
\py{\_dagger} is an optional Boolean argument, set to \py{False} by default.
It is used to construct an involutive identity-on-objects contravariant endo-functor, i.e. a dagger.
\end{class}

\begin{class}\normalfont\texttt{cat.Functor(ob, ar, ob\_factory=Ob, ar\_factory=Arrow)} is given by a pair of mappings \py{ob, ar} from \py{Ob} to \py{ob\_factory} and from \py{Box} to \py{ar\_factory} respectively.
The domain of a \py{Functor}-instance \py{F} is defined implicitly as the free category generated by the domain of \py{ob} and \py{ar}.
The two factory methods allow to build functors with arbitrary codomains, \py{ar\_factory} is required to provide methods \py{id} and \py{then}.
\end{class}

\begin{example}
In order to illustrate the syntax, we give a basic example of a free functor.
\normalfont
\begin{python}
x, y, z = Ob('x'), Ob('y'), Ob('z')
f, g, h = Box('f', x, y), Box('g', y, z), Box('h', z, x)
F = cat.Functor(ob={x: y, y: z, z: x}, ar={f: g, g: h})
assert F(f >> g) == F(f) >> F(g) == g >> h
\end{python}
\end{example}

\begin{example}
\py{PythonFunctor} implements functors into Python functions, see
appendix~\ref{3-cartesian}.
\normalfont
\begin{python}
F = PythonFunctor(
    ob={x: 0, y: 1, z: 2}, ar={f: lambda: 42, g: lambda x: (x, x + 1)})
assert F(f >> g)() == (42, 43)
\end{python}
\end{example}

\begin{example}
The category of matrices is implemented by the \py{Tensor} class, see
section~\ref{5-tensor}.
\normalfont
\begin{python}
F = TensorFunctor(ob={x: 1, y: 2, z: 2}, ar={f: [0, 1], g: [0, 1, 1, 0]})
assert F(f >> g) == F(f) >> F(g) == [1, 0]
\end{python}
\end{example}

All the objects, arrows, boxes and functors constructed with DisCoPy are representable in the following sense: for any instance \py{x}, the string \py{repr(x)} is a valid Python expression which evaluates to \py{x}, assuming that the names defining \py{x} are representable themselves.
Hence, DisCoPy data structures can be serialized and exported in a standard format \cite{Statebox20} for interoperability with other category theory tools.
Note that while the data structures and methods of DisCoPy are purely functional, boxes may hold mutable a \py{data} attribute.
It is used to build boxes that are not finitely generated such as the weights of neural networks (appendix~\ref{3-cartesian}) or the phases of quantum circuits (section~\ref{6-circuit}).
