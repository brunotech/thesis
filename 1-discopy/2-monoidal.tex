%!TEX root = ../THESIS.tex

In this section, we describe the core data structure behind DisCoPy:
the \py{Diagram} class, an implementation of the arrows of a free
monoidal category. We begin with a definition of free monoidal categories via
free \emph{premonoidal categories}.

\begin{definition}\label{definition-1}
A (strict) monoidal category is a category $\mathbf{C}$ equipped with an associative
and unital functor $\otimes : \mathbf{C} \times \mathbf{C} \to \mathbf{C}$ for $\times$
the Cartesian product.
A (strict) premonoidal category is a category $\mathbf{C}$ equipped with an
associative and unital functor $\boxtimes : \mathbf{C} \ \Box \ \mathbf{C} \to \mathbf{C}$
for $\Box$ given by the following pushout in $\mathbf{Cat}$:

% \begin{center}\begin{tikzcd}
% & \mathbf{C}_0 \times \mathbf{D}_0 \arrow[r, ""] \arrow[d, ""]
% &  \mathbf{C} \times \mathbf{D}_0 \arrow[d, ""] \\
% &  \mathbf{C}_0 \times \mathbf{D} \arrow[r, ""]
% &  \mathbf{C} \ \Box \  \mathbf{D}
% \end{tikzcd}\end{center}
where $\mathbf{C}_0, \mathbf{D}_0$ are the discrete category of objects and the maps are given by the inclusions.
\end{definition}

\begin{example}\label{example-2}
The Keisli category for a strong monad over a monoidal category is a
premonoidal category. It is monoidal precisely when the monad is commutative.
The state monad over the category of sets yields a denotational
semantics for side-effects \cite{PowerRobinson97}.
\end{example}

\begin{example}
For a semiring $\bb{S}$, the distribution monad $X \mapsto \bb{S}^X$ over the
category of finite sets yields a premonoidal category with matrices over $\bb{S}$ as arrows and Kronecker product as tensor. It is monoidal when $\bb{S}$ is commutative.
\end{example}

The pushout $\Box$ is known as the \emph{funny tensor product}, it may also be defined
by the following universal property. Let $\mathbf{C} \Rightarrow \mathbf{D}$ be the
category where objects are functors $\mathbf{C} \to \mathbf{D}$ and arrows are the
transformations with no naturality requirement. Then $-\ \Box\ \mathbf{C}$
is characterised as the left adjoint of $\mathbf{C} \Rightarrow -$ in $\mathbf{Cat}$.
This makes $\Box$ a closed symmetric monoidal structure over $\mathbf{Cat}$, the
unique such structure apart from the usual Cartesian product, see
\cite{FoltzEtAl80}. A functor from the funny tensor product
$\mathbf{C}\ \Box\ \mathbf{D}$ can be understood as a functor which is ``separately
functorial'' in its two arguments $\mathbf{C}$ and $\mathbf{D}$, in analogy to separate continuity.
Premonoidal categories are also known as one-object sesquicategories
(one-and-a-half categories), i.e. 2-categories without the interchange law,
see \cite{Street96}.
Our motivation for working in a premonoidal setting is two-fold: 1) free
premonoidal categories have a simple presentation as free categories and 2)
free monoidal categories may then be described as quotient categories.

We define a \emph{monoidal signature} $\Sigma$ as a pair of sets $\Sigma_0, \Sigma_1$ with a pair of functions into the free monoid $\mathtt{dom}, \mathtt{cod} : \Sigma_1 \to \Sigma_0^\star$.
Generating arrows $f \in \Sigma_1$ are depicted as boxes with input $\mathtt{dom}(f)$ and output $\mathtt{cod}(f)$.
Given a monoidal signature $\Sigma$, we define a simple signature $L(\Sigma)$ with objects $\Sigma_0^\star$, arrows $\Sigma_0^\star \times \Sigma_1 \times \Sigma_0^\star$ with $\mathtt{dom}(u, f, v) = usv$
and $\mathtt{cod}(u, f, v) = utv$ for $s = \mathtt{dom}(f)$ and $t = \mathtt{cod}(f)$.
A layer $(u, f, v) \in \Sigma_0^\star \times \Sigma_1 \times \Sigma_0^\star$ is depicted as a box with wires to its left and right:

\begin{center}
\input{1-discopy/figures/layer}
\end{center}

\begin{proposition}
Given a monoidal signature $\Sigma$, the free premonoidal category is the free category $\mathbf{PMC}(\Sigma) = \mathbf{C}(L(\Sigma))$ generated by the simple signature of layers $L(\Sigma)$.
\end{proposition}

We define a \emph{diagram} as an arrow of $\mathbf{C}(L(\Sigma))$.
Diagrams are uniquely defined by a domain, a list of generators and an \emph{offset} for each box: the number of wires passing to its left.
Two diagrams are equal in the free monoidal category if they are related by a series of \emph{interchangers},
where $u, v, w \in \Sigma_0^\star$ and $s \xto{f} t, s' \xto{f'} t' \in \Sigma_1$:

\begin{center}
\input{1-discopy/figures/interchange}
\end{center}

The \emph{right interchangers}, going from the right- to the left-hand side of the previous equivalence are terminating on boundary-connected diagrams.
Given a boundary-connected diagram with $n$ boxes, a normal form can be reached in at most $O(n^3)$ steps \cite[Theorem~36]{DelpeuchVicary18}.
This makes the word problem for monoidal categories --- i.e. given two arbitrary diagrams, are they equal up to interchanger? --- decidable in polynomial time, see \cite[Theorem~48]{DelpeuchVicary18}.

\begin{proposition}
Given a monoidal signature $\Sigma$, the free monoidal category is the quotient $\mathbf{MC}(\Sigma) = \mathbf{PMC}(\Sigma) / \cal{I}$ for $\cal{I}$ the interchanger relation, see \cite[Theorem~16]{DelpeuchVicary18}.
\end{proposition}

\begin{example}
Context-free grammars (CFGs) are a special case of free monoidal categories, where
non-terminal symbols are generating objects and production rules are generators
with an atomic type as domain. Syntax trees are diagrams, their normal form
correspond to the leftmost derivation in a CFG. Weighted CFGs can be defined
as free monoidal categories equipped with a monoidal functor into a monoid delooping, see \cite{ShieblerEtAl20}.
\end{example}

Note that a monoidal category generated by one object, i.e. with
$\Sigma_0 = \set{1}$, is called a \emph{PRO}. An example is the category of
circuits described in section~\ref{6-circuit}.
This combinatorial definition yields an implementation of the free monoidal category where the generating objects $\Sigma_0$ are given by \py{Ob}-instances and the generating arrows $\Sigma_1$ are given by \py{Box}-instances.

\begin{class}\normalfont\texttt{monoidal.Ty(x\_1, ..., x\_n)} is a subclass of \py{cat.Ob}.
A type \py{x} is given by a (possibly empty) list of objects,
It has a method \py{x.tensor(y)}, shortened to \py{x @ y}, which inherits the monoid structure of lists with the empty type \py{Ty()} as unit.
\end{class}

\begin{class}\normalfont\texttt{monoidal.PRO(n)} is a subclass of \py{Ty} generated by \py{Ob(1)}.
A \py{PRO} type is given a natural number \py{n} with addition as tensor, i.e.
\py{PRO(n) == Ty(n * (1, ))}.
\end{class}

\begin{class}\normalfont\texttt{monoidal.Layer(left, box, right)} is a subclass of \py{cat.Box}.
A layer is given by a \py{Box}-instance \py{box} and a pair of \py{Ty}-instances \py{left} and \py{right}.
While essential to the internal structure of DisCoPy, layers remain invisible to the end user of the package.
\end{class}

\begin{class}\normalfont\texttt{monoidal.Diagram(dom, cod, boxes, offsets, layers=None)} subclasses \py{Arrow}.
A diagram \py{f} is given by a pair of types \py{dom, cod}, a pair of equal-length sequences \py{boxes, offsets} of \py{Box}-instances and natural numbers respectively.
\py{layers} is an optional argument, if omitted it will be computed from \py{dom}, \py{boxes} and \py{offsets}.
\py{f} has all the methods of \py{Arrow} plus the following:
\begin{itemize}
\item \py{f.tensor(g)}, shortened to \py{f @ g}, returns the diagram with
\\\py{(f @ g).boxes == f.boxes + g.boxes} and
\\\py{(f @ g).offsets == f.offsets + [n + len(f.cod) for n in g.offsets]}.
\item \py{f.interchange(i, j, left=False)} returns a diagram with the boxes at indices \py{i} and \py{j} interchanged or raises an \py{InterchangerError} if they are connected.
This method gets called recursively whenever \py{i < j + 1} or \py{j < i - 1}.
If there is a choice in how to interchange, then we apply the right interchanger by default.
\item \py{f.normalize(left=False)} yields a reduction sequence applying right interchangers repeatedly. Setting \py{left=True} will apply left interchangers instead.
\item \py{f.normal\_form(left=False)} returns the last output of \py{f.normalize} if \py{f} is boundary-connected, otherwise it raises a \py{NotImplementedError}.
\item \py{f.draw(to\_tikz=False, **params)} draws a diagram using \texttt{networkx} \cite{Networkx20}, see the DisCoPy documentation \cite{DeFeliceToumi} for a complete list of parameters. Diagrams are displayed with \texttt{matplotlib} \cite{Matplotlib20} by default, setting \py{to\_tikz=True} outputs a list of Ti\textit{k}z \cite{Tantau13} commands instead. This is how all the diagrams in this article were produced.
\item \py{f.to\_gif(g, h, ..., **params)} takes a list of diagrams and returns an animated GIF which can be used to visualise a rewriting process in a jupyter notebook \cite{KluyverEtAl16}.
\end{itemize}

As for \py{Arrow}, \py{Diagram}-instances can be manipulated as lists.
Indexing a diagram \py{f} returns a layer \py{Id(left) @ box @ Id(right)} such that \py{f == f[0] >> ... >> f[-1]}.
\end{class}

\begin{class}\normalfont\texttt{monoidal.Box(name, dom, cod, data=None, \_dagger=False)} is a subclass of \py{cat.Box} and \py{Diagram}. A box \py{f} is defined as a diagram with \py{f.boxes, f.offsets == [f], [0]}.
\end{class}

\begin{class}\normalfont\texttt{monoidal.Functor(ob, ar, ob\_factory=Ty, ar\_factory=Diagram)} is a subclass of \py{cat.} \py{Functor}.
A monoidal functor \py{F} is given by a pair of mappings \py{ob, ar} from \py{Ty} to \py{ob\_factory} and from \py{Box} to \py{ar\_factory} respectively.
Factory methods are optional arguments that allow arbitrary codomains.
\py{ob\_factory} is required to provide a \py{tensor} method, \py{ar\_factory} should provide \py{id}, \py{then} and \py{tensor}.
\end{class}

The implementation of the \py{Diagram} data structure and its normal form follows directly from their formal definitions, they require no further explanation.
The implementation of the \py{draw} method however requires some non-trivial choices: given the combinatorial encoding of a diagram, which embedding on the plane should we return?
Moreover, the drawing algorithm may be treated as a proof of the equivalence from the combinatorial to the geometric definition of diagrams introduced by Joyal and Street \cite{JoyalStreet88, JoyalStreet91}.
The other direction, i.e. from a planar embedding (encoded as a grid of pixels) to its combinatorial encoding as a DisCoPy \py{Diagram}, is part of an in-development application for automated string diagram recognition.
We leave the details to appendix~\ref{a-draw}.
