%!TEX root = ../../THESIS.tex

\section{QNLP models with DisCoPy}

We get to the main definition of this thesis: by a QNLP model we mean a monoidal functor $F : \G \to \mathbf{Circ}$ from the category generated by a grammar $\G$ to the category $\mathbf{Circ}$ of quantum circuits.
Before we can make this definition explicit and explain how it is implemented in DisCoPy, we need to discuss how quantum circuits are implemented.

Chapter~\ref{chapter:discopy} has already given several definitions of $\mathbf{Circ}$:
\begin{itemize}
    \item as a category (example~\ref{example:Circuit}),
    \item as a monoidal category (example~\ref{example:circuit-diagrams}),
    \item as a pivotal category (example~\ref{example:pivotal-circuit}),
    \item as a category with biproducts (example~\ref{example:biproduct-measurement}).
\end{itemize}
So far, these definitions have only covered \emph{pure quantum circuits} with post-selected measurements. Pure quantum gates are interpreted as unitary matrices, preparation (kets) and measurement (bras) as basis vectors.
The evaluation of a closed pure circuit is a complex scalar and the Born rule says its squared amplitude is the probability of a measurement outcome for a given preparation.
We can use a quantum computer to approximate this probability by executing our circuit many times or in quantum computing parlance, taking many \emph{shots}.
At each execution, we measure all the qubits then we divide the number of times the post-selected outcome occurs by the number the shots.
With the interface from the \py{Circuit} class of DisCoPy to that of the t$\vert$ket$\rangle$ compiler~\cite{SivarajahEtAl20}, going from numerical simulation to quantum hardware is as easy as providing an extra argument \py{backend: pytket.Backend} to the method \py{Circuit.eval}.

\begin{example}\label{example:circuit-alive-loves-bob}
Executing the following circuit for ``Alice loves Bob'' was the first NLP experiment on a quantum computer, as documented in Coecke et al.~\cite{CoeckeEtAl20b}.

\begin{minted}{python}
s, n = Ty('s'), Ty('n')
Alice, loves, Bob = Word('Alice', n), Word('loves', n.r @ s @ n.l), Word('Bob', n)
sentence = Alice @ loves @ Bob >> Cup(n, n.r) @ s @ Cup(n.l, n)

F = rigid.Functor(
    dom=Category(Ty, Parsing), cod=Category(Qubits, Circuit),
    ob={s: qubit ** 0, n: qubit ** 1},
    ar={Alice: Ket(0), loves: Ket(0, 0) >> H @ sqrt2 @ X >> CX, Bob: Ket(1)})

drawing.equation(sentence, F(sentence), symbol="$\\mapsto$")
\end{minted}
\ctikzfig{img/qnlp/alice-loves-bob}
\begin{minted}{python}
from pytket.backends.ibm import IBMQBackend
assert F(sentence).eval(
    backend=IBMQBackend('ibmq_singapore', hub='ibmq'), n_shots=2 ** 10) > .95
\end{minted}
\end{example}

Let's unpack what happened when we executed the last line of the example above.
We apply a monoidal functor \py{F} to the diagram for a \py{sentence} to get a circuit diagram.
DisCoPy then translates it into a \py{pytket.Circuit} which gets executed $2^{10}$ times on the \py{'ibmq_singapore'} backend (a 20-qubit quantum device).
We then assert that the probability of measuring all zeros is close enough to $1$, once multiplied by $(\vert \sqrt{2} \vert^2)^3 = 8$ to account for the three scalars.
What did we achieve? We have evaluated the DisCoCat model of example~\ref{example:discopy-alice-loves-bob} on a quantum computer!
Indeed, we have chosen our QNLP model so that the quantum states for words encode their interpretation, e.g. we have sent \py{loves} to an (anti-correlated) Bell state scaled by $\sqrt{2}$ so that \py{F(loves).eval().inside} \py{= [[0, 1], [1, 0]]}.
In this way, every complex vector $u \in \R^{2^n}$ can be encoded into the amplitudes of an $n$-qubit quantum state, up to a complex scalar (the global phase times some real scalar).
Thus, if we keep track of these scalars explicitly we can turn any DisCoCat model $F : \G \to \mathbf{Mat}_\C$ into a QNLP model $F_Q : \G \to \mathbf{Circ}$ such that evaluating the circuit $F_Q(f)$ for a grammatical sentence $f : w_1 \dots w_n \to s$ yields its interpretation $F(f)$.
But at what cost?
First, we will need a potentially exponential number of gates to encode an arbitrary complex vector as a quantum state.
Even if we do manage to load our the meaning of words on the machine efficiently, we are post-selecting on a exponentially unlikely event (measuring all qubits to zero) thus we will need an exponential number of shots to approximate the result.
