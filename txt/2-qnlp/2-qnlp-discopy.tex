%!TEX root = ../../THESIS.tex

\section{QNLP models with DisCoPy}

We get to the main definition of this thesis: by a QNLP model we mean a monoidal functor $F : \G \to \mathbf{Circ}$ from the category generated by a grammar $\G$ to the category $\mathbf{Circ}$ of quantum circuits.
Before we can make this definition explicit and explain how it is implemented in DisCoPy, we need to discuss how quantum circuits are implemented.

\subsubsection{Quantum circuits with DisCoPy}

Chapter~\ref{chapter:discopy} has already given several definitions of $\mathbf{Circ}$:
\begin{itemize}
    \item as a category (example~\ref{example:Circuit}),
    \item as a monoidal category (example~\ref{example:circuit-diagrams}),
    \item as a pivotal category (example~\ref{example:pivotal-circuit}),
    \item as a category with biproducts (example~\ref{example:biproduct-measurement}).
\end{itemize}
So far, these definitions have only covered \emph{pure quantum circuits} with post-selected measurements. Pure quantum gates are interpreted as unitary matrices, preparation (kets) and measurement (bras) as basis vectors.
The evaluation of a closed pure circuit is a complex scalar and the Born rule says its squared amplitude is the probability of a measurement outcome for a given preparation.
We can use a quantum computer to approximate this probability by executing our circuit many times or in quantum computing parlance, taking many \emph{shots}.
At each execution, we measure all the qubits then we divide the number of times the post-selected outcome occurs by the number the shots.
With the interface from the \py{Circuit} class of DisCoPy to that of the t$\vert$ket$\rangle$ compiler~\cite{SivarajahEtAl20}, going from numerical simulation to quantum hardware is as easy as providing an extra argument \py{backend: pytket.Backend} to the method \py{Circuit.eval}.

\begin{example}
Executing the following circuit for ``Alice loves Bob'' was the first NLP experiment on a quantum computer, as documented in Coecke et al.~\cite{CoeckeEtAl20b}.

\begin{minted}{python}
s, n = Ty('s'), Ty('n')
Alice, loves, Bob = Word('Alice', n), Word('loves', n.r @ s @ n.l), Word('Bob', n)
sentence = Alice @ loves @ Bob >> Cup(n, n.r) @ s @ Cup(n.l, n)

F = rigid.Functor(
    dom=Category(Ty, Parsing), cod=Category(Qubits, Circuit),
    ob={s: Qubits(0), n: Qubits(1)},
    ar={Alice: Ket(0), loves: Ket(0, 0) >> H @ sqrt2 @ X >> CX, Bob: Ket(1)})

drawing.equation(sentence, F(sentence), symbol="$\\mapsto$")
\end{minted}
\ctikzfig{img/qnlp/alice-loves-bob}
\begin{minted}{python}
from pytket.backends.ibm import IBMQBackend
assert F(sentence).eval(
    backend=IBMQBackend('ibmq_singapore', hub='ibmq'), n_shots=2 ** 10) > .95
\end{minted}
\end{example}

Let's unpack what happened when we executed the last line of the example above.
We apply a monoidal functor \py{F} to the diagram for a \py{sentence} to get a circuit diagram.
DisCoPy then translates it into a \py{pytket.Circuit} which gets executed $2^{10}$ times on the \py{'ibmq_singapore'} backend (a 20-qubit quantum device).
We then assert that the probability of measuring all zeros is close enough to $1$, once multiplied by $(\vert \sqrt{2} \vert^2)^3 = 8$ to account for the three scalars.
What did we achieve? We have evaluated the DisCoCat model of example~\ref{example:discopy-alice-loves-bob} on a quantum computer!
Indeed, we have chosen our QNLP model so that the quantum states for words encode their interpretation, e.g. we have sent \py{loves} to an (anti-correlated) Bell state scaled by $\sqrt{2}$ so that \py{F(loves).eval().inside} \py{= [[0, 1], [1, 0]]}.
In this way, every complex vector $u \in \R^{2^n}$ can be encoded into the amplitudes of an $n$-qubit quantum state, up to a complex scalar (the global phase times some real scalar).
Thus, if we keep track of these scalars explicitly we can turn any DisCoCat model $F : \G \to \mathbf{Mat}_\C$ into a QNLP model $F_Q : \G \to \mathbf{Circ}$ such that evaluating the circuit $F_Q(f)$ for a grammatical sentence $f : w_1 \dots w_n \to s$ yields its interpretation $F(f)$.
But at what cost?
First, we will need a potentially exponential number of gates to encode an arbitrary complex vector as a quantum state.
Even if we do manage to load our the meaning of words on the machine efficiently, we are post-selecting on a exponentially unlikely event (measuring all qubits to zero) thus we will need an exponential number of shots to approximate the result.

Thus, this naive definition of QNLP models is unsatisfactory from a computational point of view: if we post-select on all the qubits we'll have to wait an exponentially long time to even approximate an answer.
It is also unsatisfactory from a category theoretic point of view.
It would be nice to factorise our DisCoCat model $F : \G \to \mathbf{Mat}_\C$ as a QNLP model $F_Q : \G \to \mathbf{Circ}$ followed by an evaluation functor $\mathbf{Circ} \to \mathbf{Mat}_\C$.
But what we can actually execute on a quantum machine is the Born rule of the result, which is not a functor: the squared amplitude of a composition is not necessarily the composition of the squared amplitudes.
Killing two birds with one stone, we can overcome both limitation (computational and theoretical) if we extend our definition of $\mathbf{Circ}$ from pure to \emph{mixed quantum circuits}.
In practice, what our QNLP algorithm is missing is the simple ability to do nothing, i.e. not to measure a qubit, in theory our category $\mathbf{Circ}$ is missing a box for \emph{discard}.
As soon as we leave the realm of pure quantum circuits, quantum states cannot be represented as vectors anymore, we need \emph{density matrices}.
We cannot interpret quantum circuits as unitary matrices anymore, we need \emph{completely-positive trace-preserving} (CPTP) maps, also called \emph{quantum channels}.
As a bonus, going from pure to mixed and from unitaries to channels gives us enough room to talk about both classical and quantum processes in the same concrete category $\mathbf{Channel}$.

We will follow the definition of \emph{classical-quantum maps} from Coecke and Kissinger~\cite[Chapter~8]{CoeckeKissinger17}, .
This is a simplification of the $\mathbf{CP^\star}$ construction from Coecke, Heunen and Kissinger~\cite{CoeckeEtAl14a}, which itself generalises the notion of C$^\star$-algebra to arbitrary dagger compact closed categories.
We define the category $\mathbf{Channel}$ with objects given by pairs of natural numbers\footnote
{We actually implement an equivalent category where objects are pairs of lists of natural numbers $(a, b) \in \N^\star \times \N^\star$ and the arrows are tensors rather than matrices.} $(a, b) \in \N \times \N$ for the classical and quantum dimensions of the system.
The arrows $f : (a, b) \to (c, d)$ are given by $(a \times b^2) \times (c \times d^2)$ complex matrices subject to the following two conditions:
\begin{itemize}
\item \emph{complete positivity} (CP), there is a dimension $x \in \N$ and a $(a \times b) \times (a \times b \times x)$ matrix $g$ such that:
\ctikzfig{img/qnlp/complete-positivity}
\item \emph{trace preservation} (TP) also called \emph{causality}:
\ctikzfig{img/qnlp/trace-preservation}
\end{itemize}
The composition of two channels is given by multiplying their underlying matrices, the underlying matrix of their tensor is given by the following diagram:
\ctikzfig{img/qnlp/channel-tensor}
DisCoPy implements classical-quantum maps with the following \py{Channel} class, where we forget about the CPTP axioms and take the category $\mathbf{Channel}$ with all matrices of the appropriate shape as arrows.
There is a functor $\mathtt{double} : \mathbf{Mat}_\C \to \mathbf{Channel}$ which sends a dimension $n$ to the pair $(1, n)$ and a complex matrix $f$ to its \emph{double} $\widehat{f}$, the channel given by tensoring with its conjugate $\widehat{f} = f \otimes f^\star$.
The double of a scalar $s : 1 \to 1$ gives the same result as the Born rule $\hat{s} = s \bar{s} = \vert s \vert^2$.
The double of any matrix $f : m \to n$ automatically satisfies the complete-positivity condition, it satisfies causality iff $f$ is an isometry, i.e. $f^\dagger \fcmp f = \id(n)$, furthermore the functor is faithful up to a global phase~\cite[Proposition~6.6]{CoeckeKissinger17}.
There is also a functor $\mathtt{single} : \mathbf{Mat}_\R \to \mathbf{Channel}$ which sends a dimension $n$ to the pair $(1, n)$ and a real matrix $f$ to itself.
Again, this is always completely positive and it satisfies causality iff $f$ is a stochastic matrix, i.e. $f^T \fcmp f = \id(n)$.

For every dimension $x \in \N$, there are designated channels $\mathtt{measure}(x) : (1, x) \to (x, 1)$ and $\mathtt{encode}(x) : (x, 1) \to (1, x)$ with underlying matrix given by $\mathtt{spider}_{2, 1}(x)$ and $\mathtt{spider}_{1, 2}(x)$ respectively.
The category $\mathbf{Channel}$ inherits a dagger compact closed structure from that of $\mathbf{Mat}_\C$.
It also has sums given by element-wise addition, note however that the functor $\mathtt{double}$ does not preserve sums, i.e. $\widehat{f + f'} \neq \widehat{f} + \widehat{f'}$ in general.

\begin{python}
{\normalfont Implementation of the category $\mathbf{Channel}$ with \py{CQ} as objects and \py{Channel} as arrows.}

\begin{minted}{python}
@dataclass
class CQ:
    classical: list[int] = []
    quantum: list[int] = []

    def tensor(self, other: CQ) -> CQ:
        return CQ(self.classical + other.classical, self.quantum + other.quantum)

    def downgrade(self) -> list[int]:
        return self.classical + 2 * self.quantum

    __matmul__ = tensor

C, Q = lambda x: C(x, []), lambda x: C([], x)


@dataclass
class Channel(Composable, Tensorable):
    inside: Tensor[complex]
    dom: CQ
    cod: CQ

    @staticmethod
    def id(x: CQ) -> Channel: return Channel(x, x, Tensor[complex].id(x.downgrade()))

    def dagger(self) -> Channel: return Channel(self.inside.dagger(), self.cod, self.dom)

    @inductive
    def then(self, other: Channel) -> Channel:
        assert self.cod == other.dom
        return Channel(self.inside >> other.inside, self.dom, other.cod)

    @inductive
    def tensor(self, other: Channel) -> Channel:
        inside = ...  # Given by the diagram above.
        return Channel(inside, self.dom @ other.dom, self.cod @ other.cod)

    @staticmethod
    def double(f: Tensor[complex]) -> Channel:
        return Channel(f @ f.map(lambda x: x.conjugate()), Q(f.dom), Q(f.cod))

    @staticmethod
    def single(f: Tensor[float]) -> Channel:
        return Channel(Tensor[complex](f.inside, f.dom, f.cod), C(f.dom), C(f.cod))

    @staticmethod
    def measure(x: list[int]) -> Channel:
        return Channel(Tensor[complex].spider(2, 1, x), Q(x), C(x))

    @staticmethod
    def encode(x: list[int]) -> Channel:
        return Channel(Tensor[complex].spider(1, 2, x), C(x), Q(x))

    @staticmethod
    def discard(x: CQ) -> Channel:
        inside = Tensor[complex].spider(1, 0, x.classical)\
            @ Tensor[complex].cups(x.quantum, x.quantum[::-1])
        return Channel(inside, x, CQ())

    def __add__(self, other: Channel) -> Channel:
        assert self.dom == other.dom and self.cod == other.cod
        return Channel(self.inside + other.inside, self.dom, self.cod)

    @staticmethod
    def zero(dom: CQ, cod: CQ) -> Channel:
        return Channel(Tensor.zero(dom.dowgrade(), cod.downgrade()), dom, cod)

# Dagger compact-closed structure inherited from Tensor.
for attr in ("swap", "cups", "caps"):
    def channel_method(left: CQ, right: CQ) -> Channel:
        tensor_method = getattr(Tensor, attr)
        return Channel.single(tensor_method(left.classical, right.classical))\
            @ Channel.double(tensor_method(left.quantum, right.quantum))
    setattr(Channel, attr, channel_method)
\end{minted}
\end{python}

We're now ready to define \py{Circuit} as a subclass of \py{compact.Diagram} with objects generated by two families of objects \py{Digit(n)} and \py{Qudit(n)} indexed by natural numbers \py{n > 1}, where \py{bit = Ty(Digit(2))} and \py{qubit = Ty(Qudit(2))}.
The generating arrows are given by the classes \py{Gate}, \py{Ket} and its dagger \py{Bra}, as well as \py{Measure} and its dagger \py{Encode}.
\py{Discard} (and its dagger \py{MixedState}) can be thought of as syntactic sugar for measuring then discarding the classical result.
This extended implementation of \py{Circuit} comes with a Boolean property \py{is_pure} which defines the subcategory of pure circuits, i.e. that we can interpret as \py{Tensor}.
The \py{eval} method now comes with an optional Boolean \py{mixed}: if \py{not mixed} and \py{is_pure} we apply a \py{Tensor}-valued functor, otherwise a \py{Channel}-valued functor.
Every channel is the image of some circuit
The optional \py{backend} argument allow to go from numerical simulation to quantum hardware: it translates a circuit diagram with only \py{Digit} outputs (i.e. all qudits have been measured) into a \py{pytket.Circuit} before executing it on a quantum device.
As of today, DisCoPy does not implement the execution of \py{Encode} on quantum hardware yet, this would require to decide which quantum gate to perform depending on the result of a previous measurement.

\begin{python}
{\normalfont Implementation of the category $\mathbf{Circ}$ with \py{Digit} and \py{Qudit} as generating objects and \py{Circuit} as arrows.}

\begin{minted}{python}
class Digit(compact.Ob):
    def __init__(self, n: int):
        self.n = n
        super().__init__(name="bit" if n == 2 else "Digit({})".format(n))

class Qudit(compact.Ob):
    def __init__(self, n: int):
        self.n = n
        super().__init__(name="qubit" if n == 2 else "Qudit({})".format(n))

Digit.l = Digit.r = Qudit.l = Qudit.r = property(lambda self: self)

class Ty(compact.Ty):
    inside: list[Digit | Qudit] = []
    is_pure = property(lambda self: all(isinstance(x, Qudit) for x in self.inside))

bit, qubit = Ty(Digit(2)), Ty(Qudit(2))

class Circuit(compact.Diagram):
    @property
    def is_pure(self) -> bool:
        return all(
            box.is_pure and (left @ right).is_pure for left, box, right in self.layers)

    def eval(self, mixed=True, backend=None) -> Tensor | Channel:
        if backend is not None: ...  # Interface with pytket.
        if not mixed and self.is_pure:
            return compact.Functor(
                dom=Category(Ty, Circuit), cod=Category(list[int], Tensor),
                ob=lambda x: x.inside.quantum, ar=lambda f: f.inside)(self)
        def ob(x: Ty) -> CQ:
            obj, = x.inside
            if isinstance(obj, Digit): return C(obj.n)
            if isinstance(obj, Qudit): return Q(obj.n)
            raise TypeError
        def ar(box: Gate | Encode | Measure | Discard) -> Channel:
            if isinstance(box, (Gate, Ket)): return Channel.double(box.inside)
            if isinstance(box, Encode): return Channel.encode(b(box.dom).classical)
            if isinstance(box, Measure): return Channel.measure(ob(box.dom).quantum)
            if isinstance(box, Discard): return Channel.discard(ob(box.dom))
            raise TypeError
        return compact.Functor(
            dom=Category(Ty, Circuit), cod=Category(CQ, Channel), ob=ob, ar=ar)(self)

class Gate(compact.Box, Circuit):
    def __init__(self, name: str, dom: Ty, cod: Ty, inside: Tensor, **params):
        assert dom.is_pure and cod.is_pure
        assert Circuit.eval(dom) == inside.dom and Circuit.eval(cod) == inside.cod
        self.inside, self.is_pure = inside, True
        compact.Box.__init__(self, name, dom, cod, **params)

class Bra(compact.Box, Circuit):
    def __init__(self, *bits):
        self.bits, self.is_pure, dom, cod = bits, True, qubit ** 0, qubit ** len(bits)
        compact.Box.__init__(self, "Bra({})".format(', '.join(map(str, bits))), dom, cod)

    def dagger(self) -> Ket: return Ket(*self.bits)

    @property
    def inside(self) -> Tensor:
        if not self.bits: return Tensor.id([])
        head, *tail = self.bits
        return Tensor[complex]([[head, not head]], [2], []) @ self(Ket(*tail))

class Ket(compact.Box, Circuit):
    def __init__(self, *bits):
        self.bits, self.is_pure, dom, cod = bits, True, qubit ** 0, qubit ** len(bits)
        compact.Box.__init__(self, "Ket({})".format(', '.join(map(str, bits))), dom, cod)

    def dagger(self) -> Bra: return Bra(*self.bits)

    @property
    def inside(self) -> Tensor: return self.dagger().inside.dagger()

class Encode(compact.Box, Circuit):
    def __init__(self, n=2):
        compact.Box.__init__("Encode({})".format(n), Ty(Digit(n)), Ty(Qudit(n)))

    def dagger(self) -> Measure: return Measure(self.dom.inside[0].n)

class Measure(compact.Box, Circuit):
    def __init__(self, n=2):
        compact.Box.__init__("Measure({})".format(n), Ty(Qudit(n)), Ty(Digit(n)))

    def dagger(self) -> Measure: return Encode(self.dom.inside[0].n)

class Discard(compact.Box, Circuit):
    def __init__(self, x: Ty):
        assert len(x) == 1
        compact.Box.__init__("Discard({})".format(x), x, Ty())
\end{minted}
\end{python}

\begin{example}
We can simulate a Bell test experiment by applying the evaluation functor $\mathbf{Circ} \to \mathbf{Channel}$.

\begin{minted}{python}
H = Gate('H', qubit, qubit, [[1 / sqrt(2), 1 / sqrt(2)],
                             [1 / sqrt(2), -1 / sqrt(2)]])
CX = Gate('CX', qubit ** 2, qubit ** 2, [[1, 0, 0, 0],
                                         [0, 1, 0, 0],
                                         [0, 0, 0, 1],
                                         [0, 0, 1, 0]])
circuit = Ket(0, 0) >> H @ qubit >> CX >> Measure() @ Measure()
circuit.draw()
\end{minted}


\end{example}
