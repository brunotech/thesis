%!TEX root = ../../THESIS.tex

\section{DisCoCat models on quantum hardware}\label{section:discocat-qnlp}

We get to the main definition of this thesis: by a QNLP model we mean a monoidal functor $F : \G \to \mathbf{Circ}$ from the category generated by a grammar $\G$ to a category $\mathbf{Circ}$ of quantum circuits.
Chapter~\ref{chapter:discopy} has already given several definitions of $\mathbf{Circ}$:
\begin{itemize}
    \item as a category (example~\ref{example:Circuit}),
    \item as a monoidal category (example~\ref{example:circuit-diagrams}),
    \item as a pivotal category (example~\ref{example:pivotal-circuit}),
    \item as a category with biproducts (example~\ref{example:biproduct-measurement}).
\end{itemize}
So far, these definitions have only covered \emph{pure quantum circuits} with post-selected measurements. Pure quantum gates are interpreted as unitary matrices, preparation (kets) and measurement (bras) as basis vectors.
The evaluation of a closed pure circuit is a complex scalar and the Born rule says its squared amplitude is the probability of a measurement outcome for a given preparation.
We can use a quantum computer to approximate this probability by executing our circuit many times or in quantum computing parlance, taking many \emph{shots}.
At each execution, we measure all the qubits then we divide the number of times the post-selected outcome occurs by the number the shots.
With the interface from the \py{Circuit} class of DisCoPy to that of the t$\vert$ket$\rangle$ compiler~\cite{SivarajahEtAl20}, going from numerical simulation to quantum hardware is as easy as providing an extra argument \py{backend: pytket.Backend} to the method \py{Circuit.eval}.

\begin{example}\label{example:circuit-alive-loves-bob}
Executing the circuit for ``Alice loves Bob'' was the first NLP experiment on a quantum computer, as documented in Coecke et al.~\cite{CoeckeEtAl20b}.

\begin{minted}{python}
F = rigid.Functor(
    dom=Category(Ty, Parsing), cod=Category(Qubits, Circuit),
    ob={s: qubit ** 0, n: qubit ** 1},
    ar={Alice: Ket(0), loves: Ket(0, 0) >> H @ sqrt2 @ X >> CX, Bob: Ket(1)})

drawing.equation(sentence, F(sentence), symbol="$\\mapsto$")
\end{minted}
\ctikzfig{img/qnlp/alice-loves-bob}
\begin{minted}{python}
from pytket.backends.ibm import IBMQBackend
assert F(sentence).eval(
    backend=IBMQBackend('ibmq_singapore', hub='ibmq'), n_shots=2 ** 10) > .5
\end{minted}
\end{example}

Let's unpack what happened when we executed the last line of the example above.
We apply a monoidal functor \py{F} to the diagram for a \py{sentence} to get a circuit diagram.
DisCoPy then translates it into a \py{pytket.Circuit} which gets executed $2^{10}$ times on the \py{'ibmq_singapore'} backend (a 20-qubit quantum device).
We then assert that the probability of measuring all zeros is bigger than a $\frac{1}{2}$ threshold, once multiplied by $(\vert \sqrt{2} \vert^2)^3 = 8$ to account for the three scalars.
What did we achieve?
We have evaluated (the squared amplitude of) the DisCoCat model of example~\ref{example:alice-loves-bob} on a quantum computer!
Indeed, we have chosen our QNLP model so that the quantum states for words encode their interpretation, e.g. we have sent \py{loves} to an (anti-correlated) Bell state scaled by $\sqrt{2}$ so that \py{F(loves).eval().inside} \py{= [[0, 1], [1, 0]]}.
Assuming a universal gate set, every complex vector $u \in \C^{2^n}$ can be encoded as a pure quantum circuit $c : \mathtt{qubit}^0 \to \mathtt{qubit}^n$ scaled by a positive real scalar to account for the normalisation, which we can represent as a quantum gate on zero qubits.

In fact, every choice of encoding will define a faithful monoidal functor $\mathtt{load} : \mathbf{Tensor}_\C \to \mathbf{Circ}$ from complex tensors to pure quantum circuits with real scalars (up to equality of their interpretation) which is an inverse to evaluation, i.e. $\mathtt{load} \fcmp \mathtt{eval} = \id(\mathbf{Tensor}_\C)$.
On objects, it sends a dimension $d \in \N$ to a qudit, i.e. a $d$-dimensional quantum system.
From the rigid structure of $\mathbf{Tensor}_\C$, every arrow $f : x \to y$ can be written as $f = x \otimes u \fcmp \ttcup{x} \otimes y$ for the state $u : 1 \to x y$ given by $u = \ttcap{x} \fcmp x \otimes f$.
Thus, every tensor can be encoded as a scaled circuit followed by a post-selected Bell measurement.
From this isomorphism we can extract an abstract proof of $\mathtt{PostBQP} = \mathtt{PP}$: simulating a post-selected quantum circuit is equivalent to evaluating a monoidal functor into tensors, i.e. contracting a tensor network.

In particular, for any DisCocat model $F : \mathbf{G} \to \mathbf{Tensor}_\C$ we get a QNLP model $F_Q = F \fcmp \mathtt{load} : \mathbf{G} \to \mathbf{Circ}$ such that $F = F_Q \fcmp \mathtt{eval}$.
Evaluating the circuit $F_Q(f) = c$ for a grammatical sentence $f : w_1 \dots w_n \to s$ yields a quantum state that encodes its interpretation $\mathtt{eval}(c) = F(f)$.
When the interpretation is a scalar, i.e. $F(s) = 1$, we can directly evaluate the circuit to compute the squared amplitude $\vert F(f) \vert^2$.
If furthermore we know that the evaluation must be a positive real scalar, e.g. because the vectors for all dictionary entries are positive reals as in our example, we can simply take the square root of this probability to get a truth value for the sentence.
However, we are measuring the probability of an exponentially unlikely event (measuring all qubits to zero) thus in general we will need an exponential number of shots to approximate the result.
If the truth value is an arbitrary complex scalar, we can use a \emph{Hadamard test} to compute the real and imaginary part of the complex scalar $\mathtt{eval}(c) \in \C$.
When the interpretation is an $F(s) = n$-dimensional state for $n \geq 2$, we can perform a \emph{swap test} with the quantum state for another grammatical expression of the same type, which will compute their inner product, i.e. measure their similarity.
From the characterisation of $\mathtt{BQP}$ by Arad and Landau~\cite{AradLandau10}, we know we can get an additive approximation using a polynomial number of shots.
However, in general we have no guarantee that this additive error will not be larger than the value we want to approximate.

Thus, this naive definition of QNLP models is unsatisfactory from a computational point of view: if we post-select on all the qubits we'll have to wait an exponentially long time even to approximate an answer.
It is also unsatisfactory from a category theoretic point of view.
Indeed, so far we have defined the evaluation of pure quantum circuits as a functor into tensor, but what we can actually execute on a quantum device is the Born rule of the result, which is not a functor: the squared amplitude of a composition is not necessarily the composition of the squared amplitudes.
Killing two birds with one stone, we can overcome both limitation (computational and theoretical) if we extend our definition of $\mathbf{Circ}$ from \emph{pure} to \emph{mixed} quantum circuits.
In practice, what our QNLP algorithm is missing is the ability to do nothing, i.e. not to measure a qubit, in theory, our category $\mathbf{Circ}$ is missing a box for \emph{discard}.
As soon as we leave the realm of pure quantum circuits, quantum states cannot be represented as complex vectors anymore, we need \emph{density matrices}.
Similarly, we cannot interpret quantum circuits as unitary matrices anymore, we need \emph{completely-positive trace-preserving} (CPTP) maps, also called \emph{quantum channels}.
As a bonus, going from pure to mixed and from unitaries to channels gives us enough room to talk about both classical and quantum processes in the same concrete category $\mathbf{Channel}$.
