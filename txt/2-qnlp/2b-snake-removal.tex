%!TEX root = ../../THESIS.tex

\subsection{Simplifying QNLP models with snake removal}\label{subsection:snake-removal}

Previous sections have spelled out a first definition of QNLP models as monoidal functors $F : \G \to \mathbf{Circ}$.
The main limitation of this approach is the need for post-selection: for each cup in our pregroup reduction we need to post-select on the result of a Bell measurement, which requires to double the number of shots in order to measure accurately.
Another related problem is that we need to load all the word vectors on the quantum device at once, requiring a number of qubits proportional to the length of the sentence.
We may solve both issues at once using the \emph{snake removal} algorithm described in listing~\ref{listing:snake-removal}.
Instead of mapping the grammatical structure of the sentence directly onto the architecture of a quantum circuit, we will first rewrite the pregroup diagram to remove unnecessary snakes.
Indeed, from the rigid structure of $\mathbf{Circ}$ we have that the three-qubit circuit for a snake can be simplified to a one-qubit identity circuit, this is an abstract way to reformulate the correctness of the post-selected teleportation protocol.
Thus, for each snake removed we are effectively reducing the number of required qubits by two, with half the amount of required post-selection.

Pregroup diagrams themselves have no snakes, only boxes for the dictionary entries followed by cups.
The \emph{autonomisation} procedure of Delpeuch~\cite{Delpeuch19} allows to make the snakes manifest by opening up the boxes and filling them with caps.
Abstractly, it is based on the construction of the free rigid category generated by a given monoidal category, i.e. an autonomisation\footnote
{Autonomous is a synonym of rigid, thus autonomisation could have been called \emph{rigidification} but this would be counterintuitive, since it makes a monoidal category more flexible.}
functor $A : \mathbf{MonCat} \to \mathbf{RigidCat}$ which is left adjoint to the functor $U : \mathbf{RigidCat} \to \mathbf{MonCat}$ which forgets adjoints, cups and caps.
The action of the functor $A$ on objects is simple: given a monoidal category $C \simeq F^M(\Sigma) / R$ presented by a monoidal signature $\Sigma$ and relations $R$, we take the quotient $A(C) = F^R(\Sigma) / R$ of the free rigid category generated by $\Sigma$, seen as a rigid signature with no adjoints.
More explicitly, we start from a monoidal category $C$ that has no adjoints, cups or caps, we end up with a larger category $A(C)$ where we have added them freely: the arrows of $A(C)$ are rigid diagrams with boxes and equations coming from $C$.

The embedding functor $E : C \to A(C)$, which maps every arrow in $C$ to itself in this larger context, is monoidal and faithful~\cite[Theorem~1]{Delpeuch19}: if $E(f) = E(g)$ for two arrows $f, g : x \to y$ in $C$, then we must have $f = g$ to begin with, we cannot prove more equalities by introducing snakes.
In fact, this embedding functor is also full~\cite[Theorem~2]{Delpeuch19}, the map $E : C(x, y) \to A(C)(x, y)$ is an isomorphism for all objects $x, y$ in $C$, its inverse is computed by snake removal.
In particular for a free monoidal category $C = F^M(\Sigma)$, we get the following corollary: for a rigid diagram where the domain and codomain of each box, and of the diagram itself, contain no adjoints, the normal form contains no cups or caps, i.e. all snakes have been removed.
Thus, autonomisation allows to define the semantics of a pregroup grammar $\G$ in a monoidal category $C$ that is not rigid, for example in cartesian or semicartesian categories like $\mathbf{Pyth}$ and $\mathbf{CausalCirc}$.
Indeed, we can now define a rigid functor $F : \G \to A(C)$, apply it to a grammatical sentence $f : w_1 \dots w_n \to s$ to get a rigid diagram $F(f) : 1 \to F(s)$ in $A(C)$.
From fullness we know all snakes can be removed until we get a concrete arrow $\mathtt{normal\_form}(F(f))$ in $C$: the meaning of the sentence $f$.
This autonomisation procedure is implemented in three steps:
\begin{enumerate}
    \item we define a rigid functor $\py{wiring} : \G \to A(F^M(\Sigma))$ from our pregroup grammar to the free rigid category generated by a monoidal signature $\Sigma$,
    \item we apply this functor to a \py{sentence: pregroup.Parsing} then take the normal form to get a monoidal diagram, i.e. without cups, caps or adjoints,
    \item we apply a monoidal functor $\py{G} : F^M(\Sigma) \to C$ into our semantic category $C$ to get the meaning of the sentence $\py{G(wiring(sentence).normal_form())}$.
\end{enumerate}

\begin{example}\label{example:autonomisation}
Let's remove the snakes from ``Alice loves Bob'' by applying a functor $\py{wiring} : \G \to A(F^M(\Sigma))$ for the monoidal signature $\Sigma$ given by boxes $1 \to n$ for ``Alice'' and ``Bob'' and $n \otimes n \to s$ for ``loves''.

\begin{minted}{python}
wiring = rigid.Functor(
    dom=Category(rigid.Ty, pregroup.Parsing),
    cod=Category(rigid.Ty, rigid.Diagram),
    ob=lambda x: x,
    ar={Alice: Box("Alice", Ty(), n), Bob: Box("Bob", Ty(), n),
        loves: Cap(n.r, n) @ Cap(n, n.l) >> n.r @ Box("loves", n @ n, s) @ n.l})

drawing.equation(
    sentence, wiring(sentence), wiring(sentence).normal_form(), symbol='$\\mapsto$')
\end{minted}

\ctikzfig{img/qnlp/snake-removal}

The resulting diagram is indeed a monoidal diagram, i.e. we have removed the two snakes.
This means we can apply any monoidal functor to it.
For example, the following functor $G : F^M(\Sigma) \to \mathbf{Pyth}$ was introduced in \cite{FeliceEtAl20} in order to define functorial language games, it sends pregroup diagrams to Python functions that evaluate to themselves.

\begin{minted}{python}
G = monoidal.Functor(
    dom=Category(rigid.Ty, rigid.Diagram), cod=Category(tuple[type, ...], Function),
    ob={s: pregroup.Parsing, n: pregroup.Parsing},
    ar={Box("Alice", Ty(), n): lambda: Alice, Box("Bob", Ty(), n): lambda: Bob,
        Box("loves", n @ n, s): lambda f, g:
            f @ loves @ g >> Cup(n, n.r) @ s @ Cup(n.l, n)})

assert G(wiring(sentence).normal_form())() == sentence
\end{minted}

We can also apply a functor $G : F^M(\Sigma) \to \mathbf{Circ}$ to simplify the circuit of example~\ref{example:circuit-alive-loves-bob}.

\begin{minted}{python}
G = monoidal.Functor(
    dom=Category(rigid.Ty, rigid.Diagram),
    cod=Category(circuit.Ty, Circuit),
    ob={s: qubit ** 0, n: qubit},
    ar={Box("Alice", Ty(), n): Ket(0), Box("Bob", Ty(), n): Ket(1),
        Box("loves", n @ n, s): CX >> H @ sqrt2 @ X >> Bra(0, 0)})

drawing.equation(F(sentence), G(wiring(sentence).normal_form()))
\end{minted}

\ctikzfig{img/qnlp/snake-removed-circuit}

\begin{minted}{python}
assert F(sentence).eval() == G(wiring(sentence).normal_form()).eval()
\end{minted}
\end{example}

\begin{example}\label{example:autonomisation-who}
We can rewrite noun phrases with subject relative pronouns such as ``Alice who loves Bob'' using the following factorisation for ``who''.
We can then use the Frobenius anatomy of subject relative pronouns as given by Sadrzadeh et al.~\cite{SadrzadehEtAl13} to get a simplified quantum circuit.

\begin{minted}{python}
who = Word("who", n.r @ n @ s.l @ n)
phrase = Alice @ who @ loves @ Bob\
    >> Cup(n, n.r) @ n @ s.l @ Cup(n, n.r) @ s @ Cup(n.l, n) >> n @ Cup(s.l, s)

wiring.ar[who] = Cap(n.r, n)\
    >> n.r @ Box("who_1", n, x @ n)\
    >> n.r @ x @ Cap(s, s.l) @ n
    >> n.r @ Box("who_2", x @ s, n) @ s.l @ n

G.ob[x] = qubit
G.ar[Box("who_1", n, x @ n)] = H @ sqrt2 @ Ket(0) >> CX
G.ar[Box("who_2", x @ s, n)] = Circuit.id(qubit)

rewrite_steps = (
    phrase,
    wiring(phrase),
    wiring(phrase).normal_form(),
    G(wiring(phrase).normal_form()))
drawing.equation(rewrite_steps, symbol='$\\mapsto$')
\end{minted}
\ctikzfig{img/qnlp/snake-removal-who}
\end{example}

\begin{example}
We can always construct a trivial \py{wiring} functor which sends a dictionary entry to the disconnected diagram given by tensoring the iterated transpose of boxes with one wire.

\begin{minted}{python}
def trivial_ar(word: Word) -> rigid.Diagram:
    if len(word.cod) == 1:
        obj, = word.cod.inside
        if obj.z == 0: return
        return Box(word.name, word.cod) if obj.z == 0 else\
            trivial_ar(Word(word.name, word.cod.r)).transpose(left=True)\
            if obj.z < 0 else\
            trivial_ar(Word(word.name, word.cod.l)).transpose(left=False)
    return rigid.Diagram.tensor(*[
        trivial_ar(Word("{}_{}".format(word.name, i), x))
        for i, x in enumerate(word.cod)])

trivial = rigid.Functor(
    dom=Category(rigid.Ty, pregroup.Parsing),
    cod=Category(rigid.Ty, rigid.Diagram),
    ob=lambda x: x, ar=trivial_ar)

drawing.equation(
    sentence, trivial(sentence), trivial(sentence).normal_form(), symbol='$\\mapsto$')
\end{minted}
\ctikzfig{img/qnlp/snake-removal-trivial}
\end{example}

The \py{wiring} functor is the key ingredient of the autonomisation recipe as given by Delpeuch~\cite{Delpeuch19}.
For each dictionary entry we need to find some monoidal boxes (i.e. without adjoints) from which we can bend the wires to get the desired pregroup type.
We do not know if a non-trivial autonomisation is possible for arbitrary pregroup types, for example object relative pronouns of type $n^r n n^ll s^l$.
In example~\ref{example:autonomisation}, wiring was straightforward because all types had the shape $(x^r) y (z^l)$ for a generating object $y \in X$ and some types $x, z \in X^\star$ which do not contain adjoints.
Let us call types of this shape \emph{dependency types}, we claim\footnote
{A sketch of this statement is available on the nLab~\cite{ToumiNLab21}, a detailed proof will appear in de Felice's thesis~\cite{Felice22}.} that a pregroup grammar with only dependency types is in fact a \emph{dependency grammar} (DG) as defined by Gaifman~\cite{Gaifman65}.
From such a dependency grammar $G = (V, X, D, s)$ with dictionary entries $e = (w, (x^r) y (z^l)) \in D$, we construct a monoidal signature $\Sigma_G$ with generating objects $X$ and boxes $f_e : x z \to y$ together with a rigid functor $\py{wiring} : \G \to A(F^M(\Sigma_G))$ which acts as $e \mapsto \ttcap(x^r) \otimes \ttcap(z) \fcmp x^r \otimes f_e \otimes z^l$.
The resulting normal form is a monoidal diagram where all boxes have exactly one output, thus it is isomorphic to a tree which is called a \emph{dependency tree}.

Dependency grammars are weakly equivalent to context-free grammars~\cite[Theorem~3.11]{Gaifman65} and they are in fact strongly equivalent to a subclass of CFGs characterised by a notion of finite degree~\cite[Theorem~3.10]{Gaifman65}.
This strong equivalence can be computed in logarithmic space, thus the parsing problem for DGs reduces to that of CFGs, it can be solved in polynomial time.
Hence, DGs generate the same languages as CFGs and pregroup grammars but they sit somewhere at the intersection of the two frameworks in terms of the grammatical structures they can generate.
We conjecture that a PG is strongly equivalent to a CFG if and only if its dictionary entries all have dependency types, i.e. DGs would be precisely characterised as the intersection of CFGs and PGs.
In addition to their theoretical interest, DGs have also been applied in practice for natural language processing at industrial scale with the spaCy library~\cite{HonnibalMontani17}.
Going from pregroup grammars to the more restricted dependency grammars, all grammatical structures become tree-shaped and can be interpreted in arbitrary monoidal categories.
In particular, we can now define \emph{causal} QNLP models as functors $F : \G \to A(\mathbf{CausalCirc})$ where the meaning of grammatical sentences is given by quantum circuits without post-selection.
Giving experimental support to this approach is an ongoing research project.
