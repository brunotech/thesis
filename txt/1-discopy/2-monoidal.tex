%!TEX root = ../../THESIS.tex

\section{Diagrams in Python} \label{section:monoidal}

In the previous section, we introduced the idea of arrows in free categories as abstract data pipelines and functor application as their evaluation in concrete categories such as $\mathbf{Pyth}$, $\mathbf{Mat}$ or $\mathbf{Circ}$ where the computation happens.
For now, our pipelines are rather basic because they are linear: we cannot express functions of multiple arguments, nor tensors of order higher than 2, nor circuits with multiple qubits in any explicit way.

In this section, we move from the one-dimensional syntax of arrows in free categories to the two-dimensional syntax of \emph{string diagrams}, the arrows of free \emph{monoidal categories}.
The data for a (strict\footnote
{We will assume that our monoidal categories are strict, i.e. the axioms for monoids are equalities rather than natural isomorphisms subject to coherence conditions.}) monoidal category $C$ is that of a category together with:
an object $1 \in C_0$ called the \emph{unit} and a pair of overloaded binary operations called the \emph{tensor} on objects $\otimes : C_0 \times C_0 \to C_0$ and on arrows $\otimes : C_1 \times C_1 \to C_1$, translated to \py{@} in Python.
The axioms for monoidal categories are the following:
\begin{itemize}
\item $(C_0, \otimes, 1)$ and $(C_1, \otimes, \id(1))$ are monoids,
\item the tensor defines a functor $\otimes : C \times C \to C$, i.e. the following \emph{interchange law} $(f \fcmp f') \otimes (g \fcmp g') = (f \otimes g) \fcmp (f' \otimes g')$ holds for all arrows $f, f', g, g' \in C_1$.
\end{itemize}
We will use the following terminology: an object $x$ is called a \emph{system}, an arrow $f : 1 \to x$ from the unit is called a \emph{state} of the system $x$, an arrow $f : x \to 1$ into the unit is called an \emph{effect} of $x$ and an arrow $a : 1 \to 1$ from the unit to itself is called a \emph{scalar}.

A functor $F : C \to D$ between monoidal categories $C$ and $D$ is (strict\footnote
{We will assume that our monoidal functors are strict, i.e. $F(x \otimes y) = F(x) \otimes F(y)$ and $F(1) = 1$ are equalities rather than natural transformations.}) monoidal whenever it is also a monoid homomorphism on objects and arrows.
Thus, monoidal categories themselves form a category $\mathbf{MonCat}$ with monoidal functors as arrows.
A transformation $\alpha : F \to G$ between two monoidal functors $F, G : C \to D$ is monoidal itself when $\alpha(x \otimes y) = \alpha(x) \otimes \alpha(y)$ for all objects $x, y \in C$.

\begin{example}
Every monoid $M$ can also be seen as a discrete monoidal category, i.e. with only identity arrows.
\end{example}

\begin{example}
A monoidal category with one object is a commutative monoid.
Indeed in any monoidal category, the interchange law implies that scalars form a commutative monoid, by the following Eckmann-Hilton argument:
\begin{align*}
a \fcmp b
&\quad = \quad 1 \otimes a \s \fcmp \s b \otimes 1
\quad = \quad (1 \fcmp b) \s \otimes \s (a \fcmp 1)
\quad = \quad b \otimes a
\\
&\quad = \quad (b \fcmp 1) \s \otimes \s (1 \fcmp a)
\quad = \quad b \otimes 1 \s \fcmp \s 1 \otimes a
\quad = \quad b \fcmp a
\end{align*}
\end{example}

\begin{example}
A monoidal category with at most one arrow between any two objects is called a \emph{preordered monoid}.
The functoriality axiom implies that the preorder is in fact a pre-congruence, i.e. $a \leq b$ and $c \leq d$ implies $a \times c \leq b \times d$.
Given the presentation of a monoid $(X, R)$ with $R \sub X^\star \times X^\star$, we can construct a preordered monoid with $(\leq_R) = \bigcup_{n \in \N} R^n \sub X^\star \times X^\star$ the (non-symmetric) reflexive transitive closure of $R$.
Thus, the inequality problem (i.e. given two lists $x, y \in X^\star$ and a presentation $(X, R)$, decide whether $x \leq_R y$) is a generalisation of the word problem for monoids.
\end{example}

\begin{example}
The category $\mathbf{FinSet}$ is monoidal with the singleton $1$ as unit and Cartesian product as tensor.
Again, this is not a strict monoidal category but it is equivalent to one: take the category with natural numbers $m, n \in \N$ as objects and functions $[m] \to [n]$ as arrows for $[n] = \{ 0, 1, \dots, n - 1 \}$.
The states can be identified with elements and the only effect is discarding, i.e. the constant function into the singleton.
$\mathbf{FinSet}$ is also monoidal with the empty set $0$ as unit and disjoint union as tensor.
\end{example}

\begin{example}\label{example:endofunctors are monoidal}
For any category $C$, there is a monoidal category $C^C$ where the objects are enfodunctors with composition as tensor and the arrows are natural transformations $\alpha : F \to F'$, $\beta : G \to G'$ with vertical composition $(\alpha \otimes \beta)(x) : G(F(x)) \to G'(F'(x))$ as tensor.
\end{example}

\begin{example}
The category $\mathbf{Pyth}$ is monoidal with unit \py{()} and \py{tuple[t1, t2]} as the tensor of types \py{t1} and \py{t2}.
Given two functions \py{f} and \py{g}, we can define their tensor \py{f @ g = lambda x, y: f(x), g(y)}.

There are two caveats however.
First, $\mathbf{Pyth}$ is not strict monoidal: \py{(x, (y, z))} is not strictly equal to \py{((x, y), z)} but only naturally isomorphic, similarly for \py{((), x) != x != (x, ())}.
These natural isomorphisms are subject to coherence conditions which make sure that all the ways to rebracket \py{(((x, y), z), w)} into \py{(x, (y, (z, w)))} are the same.
In practice, this bureaucracy of parenthesis does not pose any problem: MacLane's coherence theorem~\cite[VII]{MacLane71} makes sure that every monoidal category is monoidally equivalent\footnote
{An \emph{equivalence} of categories is an adjunction where the unit and counit are in fact natural isomorphisms.
It is a \emph{monoidal equivalence} when they are also monoidal transformations.} to a strict one.

Second, the interchange law only holds for the subcategory of $\mathbf{Pyth}$ with \emph{pure functions} as arrows.
Indeed, if the functions \py{f} and \py{g} are impure (e.g. they call \py{random} or \py{print}) then their tensor \py{f @ g} will depend on the order in which they are evaluated, i.e. \py{f @ id >> id @ g != id @ g >> f @ id}.
As we will discuss in section~\ref{section:premonoidal}, $\mathbf{Pyth}$ is in fact a \emph{premonoidal category}.
The states, i.e. the functions \py{f : () -> t}, can be identified with their value \py{f(): t}.
There is only one pure effect, i.e. a unique pure function \py{f : t -> ()} called \emph{discarding}, and thus a unique pure scalar.
If we take all impure functions into account, the scalars form a non-commutative monoid of side-effects.
\end{example}

\begin{python}
{\normalfont Implementation of $\mathbf{Pyth}$ as a (non-strict pre)monoidal category with \py{tuple} as tensor.}

\begin{minted}{python}
class Function:
    ...
    def tuple(self, other: Function) -> Function:
        dom, cod = tuple[self.dom, other.dom], tuple[self.cod, other.cod]
        return Function(lambda x, y: (self(x), other(y)), dom, cod)
\end{minted}
\end{python}

\begin{example}
We can also make $\mathbf{Pyth}$ monoidal with the \emph{tagged union} as tensor on objects and \py{typing.NoReturn} as unit.
Given two types \py{t0, t1}, their tagged union \py{t0 + t1} is the union of the types \py{tuple[0, t0]} and \py{tuple[1, t1]}\footnote
{What we really mean is \py{tuple[Literal[0], t0] | tuple[Literal[1], t1]}.}, i.e. a term \py{(b, x): t0 + t1} is a pair of a Boolean \py{b: bool} and a term \py{x: t0} if \py{b} else a term \py{x: t1}.
Given two functions \py{f, g} we can define their tensor as $\py{lambda b, x:} \py{(b, f(x) if b else g(x))}$.
\end{example}
\pagebreak
\begin{python}
{\normalfont Implementation of $\mathbf{Pyth}$ as a (non-strict) monoidal category with \py{tagged_union} as tensor.}

\begin{minted}{python}
class TaggedUnion:
    _name = "TaggedUnion"

    def __class_getitem__(cls, types):
        if not types: return NoReturn
        result = Union[tuple(tuple[Literal[i], t] for i, t in enumerate(types))]
        result.__origin__, result.__args__ = TaggedUnion, types; return result

class Function:
    ...
    def tagged_union(self: Function, other: Function) -> Function:
        inside = lambda b, x: (b, self(x)) if b else (b, other(x))
        dom = TaggedUnion[self.dom, other.dom]
        cod = TaggedUnion[self.cod, other.cod]
        return Function(inside, dom, cod)
\end{minted}
\end{python}

\begin{example}
The category $\mathbf{Mat}_\S$ is monoidal with addition of natural numbers as tensor on objects and the \emph{direct sum} $f \oplus g = \big(\begin{smallmatrix}f & 0\\ 0 & g\end{smallmatrix}\big)$ as tensor on arrows.
When the rig $\S$ is commutative, $\mathbf{Mat}_\S$ is also monoidal with multiplication of natural numbers as tensor on objects and the \emph{Kronecker product} as tensor on arrows.
The inclusion functor $\mathbf{FinSet} \to \mathbf{Mat}_\B$ is monoidal in two ways: it sends disjoint unions to direct sums and Cartesian products to Kronecker products.
\end{example}

\begin{python}
{\normalfont Implementation of $\mathbf{Mat}_\S$ as a monoidal category with \py{direct_sum} and \py{Kronecker} as tensor.}

\begin{minted}{python}
class Matrix:
    ...
    def direct_sum(self, other: Matrix) -> Matrix:
        dom, cod = self.dom + other.dom, self.cod + other.cod
        left, right = (len(m.inside[0]) if m.inside else 0 for m in (self, other))
        inside = [row + right * [0] if i < len(self.inside) else left * [0] + row
                  for i, row in enumerate(self.inside + other.inside)]
        return type(self)(inside, dom, cod)

    def Kronecker(self, other: Matrix) -> Matrix:
        dom, cod = self.dom * other.dom, self.cod * other.cod
        inside = [[self[i_dom][i_cod] * other[j_dom][j_cod]
            for i_cod in range(self.cod) for j_cod in range(other.cod)]
            for i_dom in range(self.dom) for j_dom in range(other.dom)]
        return type(self)(inside, dom, cod)
\end{minted}
\end{python}

\begin{example}
The category $\mathbf{Circ}$ is monoidal with addition of natural numbers as tensor on objects and \emph{parallel composition} of circuits as tensor on arrows.
The evaluation functor $\mathtt{eval} : \mathbf{Circ} \to \mathbf{Mat}_\C$ is monoidal: it sends the parallel composition of circuits to the Kronecker product of their unitary matrices.
\end{example}

\subsection{Foo monoidal categories}

Again, implementing a monoidal category in Python means nothing but defining a pair of classes for objects and arrows with a \py{tensor} method that satisfies the axioms.
Less trivially, we want to implement the arrows of \emph{free monoidal categories} which can then be interpreted in arbitrary monoidal categories via the application of monoidal functors: this is the content of the \py{discopy.monoidal} module.
As in the case of free categories, free monoidal categories will be the image of a functor $F : \mathbf{MonSig} \to \mathbf{MonCat}$, the left adjoint to the forgetful functor $U : \mathbf{MonCat} \to \mathbf{MonSig}$ from monoidal categories to \emph{monoidal signatures}.
A monoidal signature $\Sigma$ is a monoidal category without identity, composition or tensor: a pair of sets $\Sigma_0, \Sigma_1$ and a pair of functions $\dom, \cod : \Sigma_1 \to \Sigma_0^\star$ from boxes to lists of objects.
A morphism of monoidal signatures $f : \Sigma \to \Sigma'$ is a pair of functions $f : \Sigma_0 \to \Sigma'_0$ and $f : \Sigma_1 \to \Sigma'_1$ with $f \fcmp \dom = \dom \fcmp f^\star$ and $f \fcmp \cod = \cod \fcmp f^\star$.
Thus, we have defined the category $\mathbf{MonSig}$ of monoidal signatures and their morphisms.
In order to define the forgetful functor $U : \mathbf{MonCat} \to \mathbf{MonSig}$, we will need the following technical lemma.

\begin{definition}
A monoidal category $C$ is \emph{foo} (free on objects) when its monoid of objects $(C_0, \otimes, 1)$ is a free monoid $C_0 = X^\star$ generated by some set of objects $X$.
\end{definition}

\begin{lemma}\label{lemma:foo-monoidal}
Every monoidal category is monoidally equivalent to a foo one.
\end{lemma}

\begin{proof}
Given a monoidal category $C$, we construct $C'$ with objects $C_0^\star$ the free monoid over the objects of $C$ and $C'(x, y) = C(\epsilon_{C_0^\star}(x), \epsilon_{C_0^\star}(y))$ for $\epsilon_{C_0} : C_0^\star \to C_0$ the counit of the list adjunction.
That is, an arrow $f : x \to y$ between two lists $x, y \in C_0^\star$ in $C'$ is an arrow $f : \epsilon_{C_0}(x) \to \epsilon_{C_0}(y)$ between their multiplication in $C$.
From left to right, the monoidal equivalence $C \simeq C'$ sends every object $x \in C_0$ to its singleton list $x \in C_0^\star$ and every arrow to itself, from right to left it sends every list to its multiplication and every arrow to itself.
\end{proof}

This means we can take the data for a monoidal category $C$ to be the following:
\begin{itemize}
\item a class $C_0$ of \emph{generating objects} and a class $C_1$ of arrows,
\item domain and codomain functions $\dom, \cod : C_1 \to C_0^\star$,
\item a function $\id : C_0^\star \to C_1$ and a (partial) operation $\then : C_1 \times C_1 \to C_1$,
\item an operation on arrows $\tensor : C_1 \times C_1 \to C_1$ such that $\dom (f \otimes g) = \dom(f) \dom(g)$ and $\cod (f \otimes g) = \cod(f) \cod(g)$.
\end{itemize}
The axioms for the objects to be a monoid now come for free, we only need to require that tensor on arrows is a monoid with the interchange law.
With this definition of (free-on-objects) monoidal category, we can define the forgetful functor $U : \mathbf{MonCat} \to \mathbf{MonSig}$: it forgets the identity, composition and tensor on arrows, but not the tensor on objects which is free.

\begin{example}
Take a monoid $M$ seen as a discrete monoidal category, we get an equivalent monoidal category $M'$ with objects the free monoid $M^\star$ and an isomorphism $x_1 \dots x_n \to y_1 \dots y_m$ whenever $x_1 \times \dots \times x_n = y_1 \times \dots \times y_m$ in $M$.
\end{example}

In the cases of monoidal categories where the objects are the natural numbers with addition as tensor, such as $\mathbf{FinSet}$ with disjoint union, $\mathbf{Mat}_\S$ with direct sum or $\mathbf{Circ}$, the monoid of objects is already free: $(\N, +, 0)$ is the free monoid generated by the singleton set.
These monoidal categories are also called \emph{PROs} (for PROduct categories).
When the objects are generated by a more-than-one-element set they are also called \emph{coloured PROs}, this is the same thing as a foo-monoidal category.
For example, we can take all the Python types as colours and define $\mathbf{Pyth}$ as a foo-monoidal category with \py{tuple[type, ...]} as objects.

\begin{python}
{\normalfont Syntactic sugar for whiskering and tensor.}

\begin{minted}{python}
class Tensorable:
    @classmethod
    def whisker(cls, other):
        return other if isinstance(other, cls) else cls.id(other)

    __matmul__ = lambda self, other: self.tensor(self.whisker(other))
    __rmatmul__ = lambda self, other: self.whisker(other).tensor(self)
\end{minted}
\end{python}

\begin{python}\label{listing:monoidal.Function}

{\normalfont $\mathbf{Pyth}$ as a foo-monoidal category with \py{tuple[type, ...]} as objects, \py{Function} as arrows and \py{tuple} as tensor.}

\begin{minted}{python}
class Function(cat.Function, Tensorable):
    inside: Callable
    dom: tuple[type, ...]
    cod: tuple[type, ...]

    @inductive
    def tensor(self, other: Function) -> Function:
        def inside(*xs):
            left, right = xs[:len(self.dom)], xs[len(self.dom):]
            result = tuple(self(*left)) + tuple(other(*right))
            return result[0] if len(self.cod + other.cod) == 1 else result
        return Function(inside, self.dom + other.dom, self.cod + other.cod)
\end{minted}
\end{python}

In the case of $\mathbf{Mat}_\S$ with Kronecker product as tensor, we can define an equivalent category $\mathbf{Tensor}_\S$ where the objects are lists of natural numbers and the arrows $f : x_1 \dots x_n \to y_1 \dots y_m$ are $(x_1 \times \dots \times x_n) \times (y_1 \times \dots \times y_m)$ matrices, i.e. tensors of order $m + n$.
Note that we could define yet another equivalent category where the objects are lists of prime numbers instead.

\begin{python}\label{listing:tensor}
{\normalfont Implementation of the foo-monoidal category $\mathbf{Tensor}_\S \simeq \mathbf{Mat}_\S$ with \py{tuple[int, ...]} as objects and \py{Tensor[dtype]} as arrows.}

\begin{minted}{python}
def product(x, unit=1): return unit if not x else product(unit * x[0], x[1:])

class Tensor(Tensorable, Matrix):
    inside: list[list[Number]]
    dom: tuple[int, ...]
    cod: tuple[int, ...]

    def downgrade(self) -> Matrix:
        return Matrix[self.dtype](self.inside, product(self.dom), product(self.cod))

    @classmethod
    def id(cls, x: tuple[int, ...]) -> Tensor:
        return cls(Matrix.id(product(x)).inside, x, x)

    @inductive
    def then(self, other: Tensor) -> Tensor:
        inside = Matrix.then(*map(Tensor.downgrade, (self, other))).inside
        return type(self)(inside, self.dom, other.cod)

    @inductive
    def tensor(self, other: Tensor) -> Tensor:
        inside = Matrix.Kronecker(*map(Tensor.downgrade, (self, other))).inside
        return type(self)(inside, self.dom + other.dom, self.cod + other.cod)

    def __getitem__(self, key : int | tuple) -> Tensor:
        if isinstance(key, tuple):
            key = sum(key[i] * product(self.dom[i + 1:]) for i in range(len(key)))
        inside = Matrix.__getitem__(self.downgrade(), key).inside
        dom, cod = ((), cod) if product(self.dom) == 1 else ((), ())
        return type(self)(inside, dom, cod)

    for attr in ("__bool__", "__int__", "__float__", "__complex__"):
        setattr(Tensor, attr, lambda self: getattr(self.downgrade(), attr)())
\end{minted}
\end{python}

\subsection{Free monoidal categories}\label{subsection:free-monoidal}

Now how do we go on constructing the left adjoint $F : \mathbf{MonSig} \to \mathbf{MonCat}$?
In the same way that lists in the free monoid $X^\star$ can be defined as equivalence classes of expressions built from generators in $X$, product and unit, we can construct the arrows of the free monoidal category $F(\Sigma)$ as equivalence classes of expressions built from boxes in $\Sigma_1$, identity, composition and tensor.
In order to find good representatives for these equivalence classes, we will need the following technical lemma.

\begin{definition}
Given a monoidal signature $\Sigma$, we define a signature of \emph{layers} $L(\Sigma)$ with $\Sigma_0^\star$ as objects and triples $(x, f, y) \in \Sigma_0^\star \times \Sigma_1 \times \Sigma_0^\star$ as boxes with $\dom(x, f, y) = x \dom(f) y$ and $\cod(x, f, y) = x \cod(f) y$.
Given a morphism of monoidal signatures $f : \Sigma \to \Sigma'$, we get a morphism between their signatures of layers $L(f) : L(\Sigma) \to L(\Sigma')$.
Thus, we have defined a functor $L : \mathbf{MonSig} \to \mathbf{Sig}$.
\end{definition}

\begin{lemma}
Fix a monoidal signature $\Sigma$.
Every well-typed expression built from boxes in $\Sigma_1$, identity of objects in $\Sigma_0^\star$, composition and tensor is equal to:
$$
\id(x) \s \text{for} \s x \in \Sigma_0^\star \quad \text{or} \quad
\id(x_1) \otimes f_1 \otimes \id(y_1)
\s \fcmp \s \dots \s \fcmp \s
\id(x_n) \otimes f_n \otimes \id(y_n)$$
for some list of layers $(x_1, f_1, y_1), \dots, (x_n, f_n, y_n) \in L(\Sigma)$.
\end{lemma}

\begin{proof}
By induction on the structure of well-typed expressions.
The only non-trivial case is for the tensor $f \otimes g$ of two expressions $f : x \to y$ and $g : z \to w$, where we need to apply the interchange law to push the tensor through the composition $f \otimes g \s = \s (f \fcmp \id(y)) \otimes (\id(z) \fcmp g) \s = \s f \otimes \id(z) \ \fcmp \ \id(y) \otimes g$.
\end{proof}

We have all the ingredients to define the free monoidal category $F(\Sigma)$: it is a quotient $F(L(\Sigma)) / R$ of the free category generated by the signature of layers $L(\Sigma)$.
Its objects, which we call \emph{types}, are lists in the free monoid $\Sigma_0^\star$.
Its arrows, which we call \emph{diagrams}, are paths with lists in $\Sigma_0^\star$ as nodes and layers $(x, f : s \to t, y) \in L(\Sigma)$ as edges $x s y \to x t y$.
The equality of diagrams is the smallest congruence generated by the \emph{right interchanger}:
$$
(a x b, \ g, \ c) \s \fcmp \s (a, \ f, \ b w c)
\quad \to_R \quad
(a, \ f, \ b z c) \s \fcmp \s (a y b, \ g, \ c)
$$
for all types $a, b, c \in \Sigma_0^\star$ and boxes $f : x \to y$ and $g : z \to w$.
That is, we can interchange two consecutive layers whenever the output of the first box is not connected to the input of the second, i.e. there is an identity arrow $\id(b)$ separating them.
Note that for an effect $f : x \to 1$ followed by a state $g : 1 \to y$, we have two options: we can apply the right interchanger $(1, f, 1) \fcmp (1, g, 1) \to_R (1, g, x) \fcmp (y, f, 1)$ or its opposite $(1, f, 1) \fcmp (1, g, 1) \leftarrow_R (x, g, 1) \fcmp (1, f, y)$.
For the composition of two scalars $a : 1 \to 1$ and $b : 1 \to 1$, we can apply interchangers indefinitely $a \fcmp b \to_R b \fcmp a \to_R a \fcmp b$: this is the Eckmann-Hilton argument.
Delpeuch and Vicary~\cite{DelpeuchVicary18} give a quadratic solution to the word problem for free monoidal categories, i.e. deciding when two diagrams are equal.

\begin{theorem}[\cite{DelpeuchVicary18}]
\label{theorem:monoidal-normal-form}
The equality of diagrams is decidable in linear time in the connected case, and quadratic in the general case.
The right interchanger is confluent and for connected diagrams, i.e. when the Eckmann-Hilton argument does not apply, it reaches a normal form in a cubic number of steps.
\end{theorem}

\begin{proof}
The linear-time algorithm for the connected case works by reduction to isomorphism of planar maps.
In the general case, computing the tree of connected components of the diagram takes quadratic time.
The cubic worst-case for normal forms is given in example~\ref{example:spiral}.
\end{proof}

We have defined the equality of diagrams, there remains to define the tensor operation.
First, we define the \emph{whiskering} $f \otimes z$ of a diagram $f$ by an object $z \in \Sigma_0^\star$ on the right: we tensor $z$ to the right-hand side of each layer $(x_i, f_i, y_i)$, i.e. $f \otimes z = (x_1, f_1, y_1 z) \fcmp \dots \fcmp (x_n, f_n, y_n z)$ and symmetrically for the whiskering $z \otimes f$ on the left.
Then, we can define the tensor $f \otimes g$ of two diagrams $f : x \to y$ and $g : z \to w$ in terms of whiskering $f \otimes g = f \otimes z \s \fcmp \s y \otimes g$.
Note that we could have chosen to define $f \otimes g = x \otimes g \fcmp f \otimes w$, the two definitions are equated by the interchanger.

Given a morphism of monoidal signatures $f : \Sigma \to \Sigma'$, we get a monoidal functor $F(f) : F(\Sigma) \to F(\Sigma')$ by relabeling: we have defined a functor $F : \mathbf{MonSig} \to \mathbf{MonCat}$.
We now have to show that it is indeed the left adjoint of $U : \mathbf{MonCat} \to \mathbf{MonSig}$.
This is very similar to the monoid case.
The unit $\eta_\Sigma : \Sigma \to U(F(\Sigma))$ sends objects to themselves and boxes $f : x \to y \in \Sigma$ to diagrams $(1, f, 1) \in L(\Sigma)$, i.e. the layer with empty lists on both sides of $f$.
The counit $\epsilon_C : F(U(C)) \to C$ is the functor which sends diagrams with boxes in $C$ to their evaluation, i.e. the formal composition and tensor of diagrams in $F(U(C))$ is sent to the concrete composition and tensor of arrows in $C$.
In the next section, we will show that this construction is in fact equivalent to the topological definition of diagrams as labeled graphs embedded in the plane.

\begin{python}\label{listing:Ty}
{\normalfont Outline of the class \py{monoidal.Ty}.}
\begin{minted}{python}
@dataclass
class Ty(Ob):
    def __init__(self, inside: Optional[tuple[Ob | str, ...]] = ()):
        self.inside = (x if isinstance(x, Ob) else Ob(x) for x in inside)
        name = ' @ '.join(map(str, inside)) if inside
            else "{}()".format(type(self).__name__)
        super().__init__(name)

    @classmethod
    def cast(cls, old: Ob) -> Ty:
        if isinstance(old, cls): return old
        return cls(old.inside) if isinstance(old, Ty) else cls(old)

    def tensor(self, *others: Ty) -> Ty:
        if all(isinstance(other, Ty) for other in others):
            return self.cast(Ty(
                self.inside + sum([other.inside for other in others], ())))
        return NotImplemented  # This will allow whiskering on the left.

    __matmul__ = __add__ = tensor
    __getitem__ = lambda self, key: self.cast(Ty(
        self.inside[key] if isinstance(key, slice) else (self.inside[key], )))
    __pow__ = lambda self, n: self.cast(Ty(n * self.inside))
    __len__ = lambda self: len(self.inside)
\end{minted}
\end{python}

The implementation of the class \py{Ty} for types (i.e. lists of objects) is straightforward, it is sketched in listing~\ref{listing:Ty}.
The only subtlety is in the method \py{cast} which allows the user to subclass \py{Ty} in a way that the tensor of subclassed objects stays within the subclass, without having to redefine the \py{tensor} method.
We also use it to define indexing (which returns a type of length one), slicing and exponentiation by a natural number.

\begin{example}
We can define a \py{Qubits} subclass and be sure that the tensor of qubits is still an instance of \py{Qubits}, not merely \py{Ty}.

\begin{minted}[fontsize=\footnotesize]{python}
class Qubits(Ty):
    __str__ = lambda self: "qubit ** {}".format(len(self))

qubit = Qubits('1')

assert isinstance(qubit ** 0, Qubits) and isinstance(qubit ** 42, Qubits)
\end{minted}
\end{example}

The implementation of \py{Layer} as a subclass of \py{cat.Box} is sketched in listing~\ref{listing:Layer}.
It has methods \py{__matmul__} and  \py{__rmatmul__} for whiskering on the right and left respectively, and \py{cast} for turning boxes into layers with units on both sides.
We use empty slices of the box's domain as units, so that \py{Layer} can be used with any subclass of \py{Ty} as attributes.
Instead of getting the units by calling \py{Ty()} directly, we use the domain of the box to slice empty types of the appropriate \py{Ty} subclass.
This will prove useful in sections~\ref{subsection:rigid}, \ref{subsection:closed} and~\ref{subsection:towards-higher} where we will subclass \py{Ty} to define the types for free rigid, closed and 2-categories respectively.

\begin{python}\label{listing:Layer}
{\normalfont Outline of the class \py{monoidal.Layer}.}

\begin{minted}[fontsize=\footnotesize]{python}
class Layer(cat.Box):
    def __init__(self, left: Ty, box: cat.Box, right: Ty):
        self.left, self.box, self.right = left, box, right
        name = ("{} @ ".format(left) if left else "") + box.name\
            + (" @ {}".format(right) if right else "")
        dom, cod = left @ box.dom @ right, left @ box.cod @ right
        super().__init__(name, dom, cod)

    def __matmul__(self, other: Ty) -> Layer:
        return Layer(self.left, self.box, self.right @ other)

    def __rmatmul__(self, other: Ty) -> Layer:
        return Layer(other @ self.left, self.box, self.right)

    @classmethod
    def cast(cls, old: cat.Box) -> Layer:
        return old if isinstance(old, cls) else cls(old.dom[:0], old, old.dom[:0])
\end{minted}
\end{python}

Now we have all the ingredients to define \py{Diagram} as a subclass of \py{Arrow} with instances of \py{Layer} as boxes.
The \py{tensor} method is defined in terms of left and right whiskering of layers.
The \py{interchange} method takes an integer \py{i < len(self)} and returns the diagram with boxes \py{i} and \py{i + 1} interchanged, or raises an \py{AssertionError} if they are connected.
It also takes an optional argument \py{left: bool} which allows to choose between left and right in case we're interchanging an effect then a state.
The \py{normal_form} method applies \py{interchange} until it reaches a normal form, or raises \py{NotImplementedError} if the diagram is disconnected.
The \py{draw} method renders the diagram as an image, it implements the drawing algorithm discussed in the next section.

\begin{python}\label{listing:monoidal.Diagram}
{\normalfont Outline of the class \py{monoidal.Diagram}.}

\begin{minted}{python}
class Diagram(cat.Arrow, Tensorable):
    inside: tuple[Layer, ...]
    dom: Ty
    cod: Ty

    @inductive
    def tensor(self, other: Diagram) -> Diagram:
        layers = tuple(layer @ other.dom for layer in self.inside)\
            + tuple(self.cod @ layer for layer in other.inside)
        dom, cod = self.dom @ other.dom, self.cod @ other.cod
        return self.cast(Diagram(layers, dom, cod))

    def interchange(self, i: int, left=False) -> Diagram: ...
    def normal_form(self, left=False) -> Diagram: ...
    def draw(self, **params): ...
\end{minted}
\end{python}

Again, we have a class method \py{cast} which takes an old \py{cat.Arrow} and turns it into a new object of type \py{cls}, a given subclass of \py{Diagram}.
This means we do not need to repeat the code for identity or composition which is already implemented by \py{cat.Arrow}.
In turn, when the user defines a subclass of \py{Diagram}, they do not need to repeat the code for identity, composition or tensor.
The implementation of \py{monoidal.Box} as a subclass of \py{cat.Box} and \py{Diagram} is relatively straightforward, we only need to make sure that a box is equal to the diagram of just itself.
We also want the \py{cast} method of \py{Box} to be that of \py{Diagram}.

\begin{python}
{\normalfont Outline of the class \py{monoidal.Box}.}
\begin{minted}[fontsize=\footnotesize]{python}
class Box(cat.Box, Diagram):
    cast = Diagram.cast

    def __init__(self, name: str, dom: Ty, cod: Ty, **params):
        cat.Box.__init__(self, name, dom, cod, **params)
        Diagram.__init__(self, (Layer.cast(self), ), dom, cod)

    def __eq__(self, other):
        if isinstance(other, Box): return cat.Box.__eq__(self, other)
        return isinstance(other, Diagram) and other.inside == (Layer.cast(self), )
\end{minted}
\end{python}

\begin{example}\label{example:circuit-diagrams}
We can define \py{Circuit} as a subclass of \py{Diagram}. \py{Gate}, \py{Bra} and \py{Ket} are subclasses of \py{Box} and \py{Circuit}.
Now we can compose and tensor gates together and the result will be an instance of \py{Circuit}.

\begin{minted}{python}
class Circuit(Diagram): pass

class Gate(Box, Circuit): pass

class Bra(Box, Circuit):
    def __init__(self, *bits: bool):
        self.bits, dom, cod = bits, Qubits(len(bits)), Qubits(0)
        Box.__init__(self, "Bra({})".format(', '.join(map(str, bits))), dom, cod)

    def dagger(self) -> Ket: return Ket(*self.bits)

class Ket(Box, Circuit):
    def __init__(self, *bits: bool):
        self.bits, dom, cod = bits, Qubits(0), Qubits(len(bits))
        Box.__init__(self, "Ket({})".format(', '.join(map(str, bits))), dom, cod)

    def dagger(self) -> Bra: return Bra(*self.bits)

Gate.cast = Ket.cast = Circuit.cast

X, Y, Z, H = [Gate(name, qubit, qubit) for name in "XYZH"]
CX = Gate("CX", qubit ** 2, qubit ** 2)
sqrt2 = Gate("$\\sqrt{2}$", qubit ** 0, qubit ** 0)
assert isinstance(sqrt2 @ Ket(0, 0) >> H @ qubit >> CX, Circuit)
\end{minted}
\end{example}

The \py{monoidal.Functor} class is a subclass of \py{cat.Functor}.
It overrides the \py{__call__} method to define the image of types and layers, and it delegates to its superclass for the image of boxes and composition.
To make the syntax look nicer, we define the domain of the object mapping as types of length one rather than their generating object, e.g. we can define a functor with \py{ob={x: y}} for \py{x = Ty('x')} and \py{y = Ty('y')} rather than \py{ob={x.inside[0]: y}}.
We also implement some syntactic sugar for the codomain so that we can define e.g. a \py{Tensor}-valued functor with \py{ob={x: n}} rather than \py{ob={x: [n]}} for a \py{x = Ty('x')} and \py{n: int}.
We make the best use of Python's duck typing so that the codomain can be \py{Ty} or \py{tuple} indifferently, in both cases computed using the built-in \py{sum} with the \py{Ty()} or \py{()} as unit.

\begin{python}
{\normalfont Implementation of monoidal functors.}
\begin{minted}{python}
class Functor(cat.Functor):
    dom = cod = Category(Ty, Diagram)

    def __call__(self, other : Ty | Diagram) -> Ty | Diagram:
        if isinstance(other, Ty):
            return sum([self(obj) for obj in other.inside], self.cod.ob())
        if isinstance(other, Ob):
            result = self.ob[self.dom.ob((other, ))]
            return result if isinstance(result, self.cod.ob) else self.cod.ob((result, ))
        if isinstance(other, Layer):
            return self(layer.left) @ self(layer.box) @ self(layer.right)
        return super().__call__(other)
\end{minted}

Note that the domain the dictionary \py{ob} can be either an \py{Ob} or a \py{Ty} of length $1$.
\end{python}

\begin{example}
We can simulate quantum circuits by applying a functor from \py{Circuit} to \py{Tensor}.
We override the \py{__call__} method to define the image of \py{Bra} and \py{Ket} on the fly.

\begin{minted}{python}
class Eval(Functor):
    dom, cod = Category(Qubits, Circuit), Category(tuple[int, ...], Tensor[complex])

    def __call__(self, other):
        if isinstance(other, Ket):
            if not other.bits: return Tensor.id(())
            head, *tail = other.bits
            return Tensor[complex]([[head, not head]], (), (2, ))\
                @ self(Ket(*tail))
        if isinstance(other, Bra):
            return self(other.dagger()).dagger()
        return super().__call__(other)

Circuit.eval = Eval(
    ob={qubit: 2},
    ar={X: [[0, 1], [1, 0]], Y: [[0, -1j], [1j, 0]], Z: [[1, 0], [0, -1]],
        H: [[1 / sqrt(2), 1 / sqrt(2)], [1 / sqrt(2), -1 / sqrt(2)]],
        CX: [[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 0, 1], [0, 0, 1, 0]],
        sqrt2: [[sqrt(2)]]})

circuit = sqrt2 @ Ket(0, 0) >> H @ qubit >> CX
superposition = Ket(0, 0) + Ket(1, 1)
assert circuit.eval() == superposition.eval()
\end{minted}
\end{example}

\begin{remark}
DisCoPy uses a more compact encoding of diagrams than their list of layers.
Indeed, a diagram is uniquely specified by a domain, a list of boxes and a list of \emph{offsets}, i.e. the length of the type to the left of each box.

\begin{minted}{python}
@dataclass
class Encoding:
    dom: Ty
    boxes_and_offsets: tuple[tuple[Box, int], ...]

Diagram.boxes = property(lambda self: tuple(box for _, box, _ in self.inside))
Diagram.offsets = property(
    lambda self: tuple(len(left) for left, _, _ in self.inside))

def encode(diagram: Diagram) -> Encoding:
    return Encoding(diagram.dom, zip(diagram.boxes, diagram.offsets))

def decode(encoding: Encoding) -> Diagram:
    diagram = Diagram.id(encoding.dom)
    for box, offset in encoding.boxes_and_offsets:
        left, right = result.cod[:offset], result.cod[offset + len(box.dom):]
        diagram >>= left @ box @ right
    return diagram

x, y, z = map(Ty, "xyz")
f, g, h = Box('f', x, y), Box('g', y, z), Box('h', y @ z, x)
encoding = Encoding(dom=x @ y, boxes_and_offsets=((f, 0), (g, 1), (h, 0)))
assert decode(encoding) == f @ g >> h and encode(f @ g >> h) == encoding
\end{minted}
\end{remark}

\subsection{Quotient monoidal categories}\label{subsection:quotient-monoidal}

Once we have defined freeness, we need to define quotients.
The quotient $C / R$ of a monoidal category $C$ by a binary relation $R \sub \coprod_{x, y \in C_0^\star} C(x, y) \times C(x, y)$ has the same objects $C_0$ and arrows equivalence classes of arrows in $C_1$ under the smallest \emph{monoidal congruence} containing $R$.
A congruence $(\sim_R)$ is monoidal when $f \sim_R f'$ and $g \sim_R g'$ implies $f \otimes g \sim f' \otimes g'$.
Explicitly, we can construct $C / R$ as the quotient category for the rewriting relation $\to_R$ where:
$$u \s \fcmp \s b \otimes f \otimes c \s \fcmp \s v \quad
\to_R \quad u \s \fcmp \s b \otimes g \otimes c \s \fcmp \s v$$
for all $(f, g) \in R$, $u : a \to b \otimes \dom(f) \otimes c$ and $v : b \otimes \cod(f) \otimes c \to d$.
Intuitively, if we can equate $f$ and $g$ then we can equate them in any context, i.e. with any objects $b$ and $c$ tensored on the left and right and any arrows $u$ and $v$ composed above and below.
A proof that two diagrams are equal in the quotient can itself be thought of as a diagram in three dimensions, i.e. the movie of a diagram being rewritten into another.
These higher-dimensional diagrams will be mentioned in section~\ref{section:summary-and-future}.
Again, every monoidal category $C$ is isomorphic to the quotient of a free monoidal category $C = F(\Sigma) / R$: take $\Sigma = U(C)$ and the relation $R \sub F(U(C)) \times F(U(C))$ given by every binary composition and tensor.

The word problem for categories reduces to that of monoidal categories, indeed the signature of a category can be seen as a monoidal signature where boxes all have domain and codomain of length one.
Thus, deciding equality of diagrams in arbitrary quotient monoidal categories is just as undecidable.
The implementation of a quotient is nothing but a subclass of \py{Diagram} with an equality method that respects the axioms of a monoidal congruence.
The easy way is to define equality of diagrams to be equality of their evaluation by a monoidal functor into a category where equality is decidable.
The hard way is to define a \py{normal_form} method which sends every diagram to a chosen representative of its equivalence class.
DisCoPy provides some basic tools to define such a normal form: \emph{pattern matching} and \emph{substitution}.

\begin{python}
{\normalfont Implementation of diagram pattern matching and substitution.}

\begin{minted}{python}
@dataclass
class Match:
    top: Diagram
    bottom: Diagram
    left: Ty
    right: Ty

    def subs(self, target):
        return self.top >> self.left @ target @ self.right >> self.bottom

def match(self: Diagram, pattern: Diagram) -> Iterator[Match]:
    for i, layer in enumerate(self.inside + [self.id(self.cod)]):
        for j in range(len(layer.dom) + 1):
            match = Match(
                top=self[:i], bottom=self[i + len(pattern):],
                left=self[i].dom[:j], right=self[i].dom[j + len(pattern.dom):])
            if self == match.subs(pattern): yield match
\end{minted}
\end{python}

Now implementing a quotient reduces to implementing a \emph{rewriting strategy}, i.e. a function which inputs diagrams and returns either a choice of match or \py{StopIteration}, then proving that it is \emph{confluent} (i.e. the order in which we pick matches does not matter) and \emph{terminating} (i.e. there are no infinite sequences of rewrites).
Our simple pattern matching routine can be extended in several ways.
First, it can only find matches on the nose: we could apply interchangers to the diagram until we find a match (with the cubic-time complexity that this implies).
Second, it can only find and substitute one match at a time: we could iterate through lists of compatible matches and implement their simultaneous substitution.
Third, instead of looking for \py{pattern} as a subdiagram of \py{self} directly, we could iterate through the functors \py{F} such that \py{F(pattern)} is a subdiagram.
This would allow to implement infinite families of equations such as those between quantum gates parameterised by continuous phases.

Why should computer scientists care about such diagram rewriting?
One reason is that diagrams are free data structures in the same sense that lists are free: they are a two-dimensional generalisation of lists.
Another reason is that they allow an elegant definition of a Turing-complete problem: given a finite monoidal signature $\Sigma$ and a pair of lists $x, y \in \Sigma_0^\star$, decide whether there is a diagram $f : x \to y$ in $F(\Sigma)$.
Indeed, the word problem for monoids (which is equivalent to the halting problem for Turing machines) reduces to the existence problem for diagrams: given the presentation of a monoid $X^\star / R$,
take objects $\Sigma_0 = X$ and boxes $\Sigma_1 = R$ with $\dom, \cod : \Sigma_1 \injects X^\star \times X^\star \to X^\star$ the left and right hand-side of each related pair.
For any pair $x, y \in X^\star$, we have that $x \leq_R y$ if and only if there is a diagram $f : x \to y$ in $F(\Sigma)$: the preordered monoid generated by the relation $R$ is the preorder collapse of the free monoidal category $F(\Sigma)$.
While monoid presentations define \emph{decision problems} (i.e. with a Boolean output), free monoidal categories naturally define \emph{function problems}: given a pair of types, output a diagram.

If we compose the two reductions together, we get a free monoidal category where diagrams are the possible runs of a given Turing machine.
Moreover, a monoidal functor from the category of one machine to another corresponds to a reduction between the problems they solve, the domain machine being simulated by the codomain.
Thus, we could very well take finite monoidal signatures as our definition of machine and diagrams as our definition of computation: algorithmic complexity is given by the size of signatures, time and space complexity are given by the length and width\footnote
{The width of a diagram is the maximum width of its layers, which is not preserved by interchangers.
In the diagrams generated by Turing machines, we cannot apply interchangers anyway: every box is connected to the next by the head of the machine.}
of diagrams.
Now if two-dimensional diagrams encode computations on one-dimensional lists, we can think of three-dimensional diagrams either as computations on two-dimensional data, or as higher-order computations.
For example, the optimisation steps of a (classical or quantum) compiler can be thought of as a three-dimensional diagram, with (classical or quantum) circuits as domain and codomain.

\begin{example}\label{example:simplify-circuits}
We can simplify quantum circuits using pattern matching.

\begin{minted}{python}
def simplify(circuit, rules):
    for source, target in rules:
        for match in circuit.match(source):
            return simplify(match.subs(target), rules)
    return circuit

rules = [(Ket(b) >> X, Ket(not b))
         for b in [0, 1]] + [
         (Ket(b0) @ Ket(b1) >> CX, Ket(b0) @ Ket(not b1 if b0 else b1))
         for b0 in [0, 1] for b1 in [0, 1]]
circuit = Ket(0) @ Ket(0) >> X @ qubit >> CX >> qubit @ X

assert simplify(circuit, rules) == Ket(1) @ Ket(0)
\end{minted}
\end{example}

\subsection{Daggers, sums and bubbles}\label{subsection:monoidal-daggers-sums-bubbles}

As in the previous section, we introduce three extra pieces of implementation: daggers, sums and bubbles.
A $\dagger$-monoidal category is a monoidal category with a dagger (i.e. an identity-on-objects involutive contravariant endofunctor) that is also a monoidal functor, a $\dagger$-monoidal functor is both a $\dagger$-functor and a monoidal functor.
They are implemented by adding a \py{dagger} method to the \py{Layer} class.
For example, $\mathbf{Tensor}_\S$ is $\dagger$-monoidal with any conjugate transpose as dagger.
The category $\mathbf{Mat}_\S$ with direct sum as tensor is also $\dagger$-monoidal.

\begin{python}
{\normalfont Implementation of free $\dagger$-monoidal categories.}

\begin{minted}{python}
class Layer:
    ...
    def dagger(self) -> Layer:
        return Layer(self.left, self.box.dagger(), self.right)
\end{minted}
\end{python}

A monoidal category is commutative-monoid-enriched when it has sums that distribute over the tensor, i.e.
$$(f + f') \s \otimes \s (g + g')
\quad = \quad
f \otimes g \s + \s f \otimes g' \s + \s f' \otimes g \s + \s f' \otimes g'$$
$$\text{and} \quad f \otimes 0 \s = \s 0 \s = \s 0 \otimes f$$
They are implemented by a adding method a \py{tensor} method to \py{Sum}, as well as overriding \py{Diagram.tensor} so that \py{f @ (g + h) == Sum.cast(f) @ (g + h)} for all diagrams \py{f}.

\begin{python}
{\normalfont Implementation of free monoidal categories with sums.}

\begin{minted}{python}
class Diagram(monoidal.Diagram):
    @inductive
    def tensor(self, other):
        return self.sum.cast(self).tensor(other)\
            if isinstance(other, Sum) else super().tensor(other)

class Sum(cat.Sum, Box):
    @inductive
    def tensor(self, other: Sum) -> Sum:
        terms = tuple(f @ g for f in self.terms for g in self.cast(other).terms)
        return Sum(terms, self.dom @ other.dom, self.cod @ other.cod)

Diagram.sum = Sum
\end{minted}
\end{python}

Bubbles for monoidal categories are the same as bubbles for categories, their implementation requires no extra work.
As we mentioned in the previous section, bubbles do give us a strictly more expressive syntax however: they can encode operations on arrows that cannot be expressed in terms of composition or tensor.

\begin{python}
{\normalfont Implementation of free monoidal categories with bubbles.}

\begin{minted}{python}
class Bubble(cat.Bubble, Box): pass

Diagram.bubble = Bubble
\end{minted}
\end{python}

\begin{example}
As in example~\ref{example:endofunctor-bubbles}, any monoidal endofunctor $\beta : C \to C$ also defines a bubble on the monoidal category $C$, we can define a bubble-preserving functor $F(U(C)^\beta) \to C$ which interprets bubbled diagrams as functor application.
However, the disjoint union $C + D$ of two monoidal categories does not yield a well-defined monoidal category: we cannot tensor arrows of $C$ with those of $D$.
Thus, the case of monoidal functors $C \to D$ requires diagrams with different colours (for the inside and the outside of the bubble) which we will mention in section~\ref{section:extra structure}.
\end{example}

\begin{example}\label{example:postprocessed-circuit}
We can implement the Born rule as a bubble on $\py{Circ}$ interpreted as element-wise squared amplitude.
We can also implement any classical post-processing as a bubble.

\begin{minted}{python}
Born_rule = lambda x: abs(x) ** 2
Circuit.measure = lambda self: self.bubble(method="squared_amplitude")
Tensor.squared_amplitude = lambda self: self.map(Born_rule)

assert float((Ket(0) >> H >> Bra(0)).measure().eval()) == .5

biased_ReLU = lambda x: max(0, 2 * x - 1)
Circuit.post_process = lambda self: self.bubble(method="non_linearity")
Tensor.non_linearity = lambda self: self.map(biased_ReLU)

circuit = Ket(0, 0) >> H @ qubit >> CX >> Bra(0, 0)
post_processed_circuit = circuit.measure().post_process()
assert float(post_processed_circuit.eval())\
    == biased_ReLU(Born_rule(float(circuit.eval())))
\end{minted}
\end{example}

\begin{example}\label{example:monoidal-formula}
We can implement the formulae of first-order logic using Peirce's \emph{existential graphs}.
They are the first historical examples of string diagrams as well as the first definition of first-order logic~\cite{BradyTrimble98,BradyTrimble00,MelliesZeilberger16,HaydonSobocinski20}.
Predicates of arity $n$ are boxes with a codomain of length $n$, if there are more than one generating objects we get a many-sorted logic.
The wires of the diagram correspond to variables, open wires in the domain and codomain are free variables, the others are existentially quantified.
Thus, the composition of the diagrams $f : x \to y$ and $g : y \to z$ encodes the formula $\exists y \ f(x, y) \land g(y, z)$ with two free variables $x, z$ and $y$ bound.
The diagram obtained by composing a predicate $p$ with the dagger of a predicate $q$ encodes the formula $\exists x \ p(x) \land q(x)$.
Bubbles, which Peirce calls \emph{cuts}, encode negation.
The evaluation of a formula in a finite model corresponds to the application of a bubble-preserving functor into $\mathbf{Mat}_\B$.

\begin{minted}{python}
class Formula(Diagram):
    cut = lambda self: self.bubble(name="_not")
    # TODO: dagger of Bubble

class Predicate(Box, Formula):
    def __init__(self, name, dom): Box.__init__(self, name, Ty(), dom)

def model(size: dict[Ty, int], data: dict[Predicate, list[bool]]):
    return Functor(
        ob=size, ar={p: [data[p]] for p in data},
        dom=Category(Ty, Formula), cod=Category(tuple[int, ...], Tensor[bool]))

x = Ty('x')
dog, god, mortal = [Predicate(name, dom=x) for name in ("dog", "god", "mortal")]
all_dogs_are_mortal = (dog.cut() >> mortal.dagger()).cut()
gods_are_not_mortal = (god >> mortal.dagger()).cut()
there_is_no_god_but_god = god >> (Formula.id(x).cut() >> god.dagger()).cut()

size = {x: 2}

for dogs, gods, mortals in itertools.product(*3 * [
        itertools.product(*size[x] * [[0, 1]])]):
    F = model(size, {dog: dogs, god: gods, mortal: mortals})
    assert F(all_dogs_are_mortal) == all(
        not F(dog)[i] or F(mortal)[i] for i in range(size[x]))
    assert F(gods_are_not_mortal) == not any(
        F(god)[i] and F(mortal)[i] for i in range(size[x]))
    assert F(there_is_no_god_but_god) == any(F(god)[i] and not any(
        F(god)[j] and j != i for j in range(size[x])) for i in range(size[x]))
\end{minted}

Note that for now our syntax is somehow limited: we can only write formulae where each variable appears at most twice, once for the source and target of its wire.
In section~\ref{subsection:hypergraph} we will introduce the diagrammatic syntax for arbitrary formulae, essentially by adding explicit boxes for equality.
\end{example}

\subsection{From tacit to explicit programming}\label{subsection:tacit-to-explicit}

We get to the end of this section and the reader may have noticed that we have not drawn a single diagram yet: drawing will be the topic of the next section.
This absence of drawing intends to demonstrate that diagrams are not only a great tool for visual reasoning, they can also be thought of as a \emph{data structure for abstract pipelines}.
Monoidal functors then allow to evaluate these abstract pipelines in terms of concrete computation, be it Python functions, tensor operations or quantum circuits.
This abstract programming style, defining programs in terms of composition rather than arguments-and-return-value, is called \emph{point-free} or \emph{tacit programming}.
Because of the difficulty of writing any kind of complex program in that way, it has also been called the \emph{pointless style}.
DisCoPy provides a \py{@diagramize} decorator which allows the user to define diagrams using the standard \emph{explicit} syntax for Python functions instead of the point-free syntax.
Given \py{dom: Ty}, \py{cod: Ty} and \py{signature: tuple[Box, ...]} as parameters, it adds to each box a \py{__call__} method which takes the objects of its domain as input and returns the objects of its codomain.

\begin{example}
We can define quantum circuits as Python functions on qubits.

\begin{minted}{python}
kets0 = Ket(0, 0)

@diagramize(dom=Qubits(2), cod=Qubits(2), signature=(sqrt2, kets0, H, CX))
def circuit():
    sqrt2(); qubit0, qubit1 = kets0
    return CX(H(qubit0), qubit1)

assert circuit == sqrt2 @ kets0 >> H @ qubit >> CX
\end{minted}
\end{example}

The underlying algorithm constructs a graph with nodes for each object of the domain and the codomain of each box, as well as of the whole diagram.
There is an edge from a codomain node of a box (or a domain node of the whole diagram) to the domain node of another (or a codomain node of the whole diagram) whenever they are connected.
There is also a node for each box and an edge from that box node to its domain and codomain nodes.
First, we initialise the graph of the identity diagram and feed the objects of its codomain as input to the decorated function.
When a box is applied to a list of nodes, it adds edges going into each object of its domain and returns nodes for each object of its codomain.
Finally, the return value of the decorated function is taken as the codomain of the whole diagram.

The \py{graph2diagram} algorithm which translates the resulting graph into a diagram will be covered in the next section.
It will allow to automatically read \emph{pictures of diagrams} (i.e. matrices of pixels) and translate them into \py{Diagram} objects.
Listing~\ref{listing:diagram2graph} shows the implementation of the inverse translation \py{diagram2graph} which outputs only planar graphs as we will show in the next section by constructing their embedding in the plane, i.e. their drawing.

\begin{python}\label{listing:diagram2graph}
{\normalfont Translation from \py{Diagram} to \py{Graph}.}

We use the graph data structure from NetworkX~\cite{HagbergEtAl08}.

\begin{minted}{python}
from networkx import Graph

@dataclass
class Node:
    kind: str
    label: Ty | Box
    i: int
    j: int

def diagram2graph(diagram: Diagram) -> Graph:
    graph = Graph()
    scan = [Node('dom', x, i, -1) for i, x in enumerate(diagram.dom)]
    graph.add_edges(zip(scan, scan))
    for j, (left, box, _) in enumerate(diagram.inside):
        box_node = Node('box', box, -1, j)
        dom_nodes = [Node('dom', x, i, j) for i in enumerate(box.dom)]
        cod_nodes = [Node('cod', x, i, j) for i in enumerate(box.cod)]
        graph.add_edges(zip(scan[len(left): len(left @ box.dom)], dom_nodes))
        graph.add_edges(zip(dom_nodes, len(box.dom) * [box_node]))
        graph.add_edges(zip(len(box.cod) * [box_node], cod_nodes))
        scan = scan[len(left):] + cod_nodes + scan[len(left @ box.dom):]
    graph.add_edges(zip(scan, [
        Node('cod', x, i, len(diagram)) for i, x in enumerate(diagram.cod)]))
    return graph
\end{minted}
\end{python}

Note that in order to construct a \py{monoidal.Diagram} we need to assume \emph{plane graphs} as input, i.e. graphs with an embedding in the plane.
This means the \py{diagramize} method cannot accept functions which swap the order of variables such as \py{lambda x, y: y, x}.
We also need to assume that every codomain node is connected to exactly one domain node.
In terms of Python functions, this means we have to use every variable exactly once.
In section~\ref{section:extra structure} we will discuss the case of diagrams induced by non-planar graphs, with potentially multiple edges between domain and codomain nodes.
