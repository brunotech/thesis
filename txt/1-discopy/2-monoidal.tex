%!TEX root = ../../THESIS.tex

\section{Diagrams in Python}

\subsection{Abstract monoidal categories}

In the previous section, we introduced the idea of arrows in free categories as formal data pipelines and functor application as their evaluation in concrete categories such as $\mathbf{Pyth}$, $\mathbf{Mat}$ or $\mathbf{Circ}$ where the computation happens.
For now, our pipelines are rather basic because they are linear: we cannot express functions of multiple arguments, nor tensors of order higher than 2, nor circuits with multiple qubits in any explicit way.
In this section, we move from the one-dimensional syntax of arrows in free categories to the two-dimensional syntax of \emph{string diagrams}, the arrows of free \emph{monoidal categories}.
The data for a (strict\footnote
{We will assume that our monoidal categories are strict, i.e. the axioms for monoids are equalities rather than natural isomorphisms subject to coherence conditions.}) monoidal category $C$ is that of a category together with:
an object $1 \in C_0$ called the \emph{unit} and a pair of overloaded binary operations called the \emph{tensor} on objects $\otimes : C_0 \times C_0 \to C_0$ and on arrows $\otimes : C_1 \times C_1 \to C_1$, translated to \py{@} in Python.
The axioms for monoidal categories are the following:
\begin{itemize}
\item $(C_0, \otimes, 1)$ and $(C_1, \otimes, \id(1))$ are monoids,
\item the tensor defines a functor $\otimes : C \times C \to C$, i.e. the following \emph{interchange law} $(f \fcmp f') \otimes (g \fcmp g') = (f \otimes g) \fcmp (f' \otimes g')$ holds for all arrows $f, f', g, g' \in C_1$.
\end{itemize}
We will use the following terminology: an arrow $f : 1 \to x$ from the unit is called a \emph{state} of the object $x$, an arrow $f : x \to 1$ into the unit is called an \emph{effect} of $x$ and an arrow $a : 1 \to 1$ from the unit to itself is called a \emph{scalar}.

A functor $F : C \to D$ between monoidal categories $C$ and $D$ is (strict\footnote
{We will assume that our monoidal functors are strict, i.e. $F(x \otimes y) = F(x) \otimes F(y)$ and $F(1) = 1$ are equalities rather than natural transformations.}) monoidal whenever it is also a monoid homomorphism on objects and arrows.
Thus, monoidal categories themselves form a category $\mathbf{MonCat}$ with monoidal functors as arrows.
A transformation $\alpha : F \to G$ between two monoidal functors $F, G : C \to D$ is monoidal itself when $\alpha(x \otimes y) = \alpha(x) \otimes \alpha(y)$ for all objects $x, y \in C$.

\begin{example}
Every monoid $M$ can also be seen as a discrete monoidal category, i.e. with only identity arrows.
\end{example}

\begin{example}
A monoidal category with one object is a commutative monoid.
Indeed in any monoidal category, the interchange law implies that scalars form a commutative monoid, by the following Eckmann-Hilton argument:
\begin{align*}
a \fcmp b
&\quad = \quad 1 \otimes a \s \fcmp \s b \otimes 1
\quad = \quad (1 \fcmp b) \s \otimes \s (a \fcmp 1)
\quad = \quad b \otimes a
\\
&\quad = \quad (b \fcmp 1) \s \otimes \s (1 \fcmp a)
\quad = \quad b \otimes 1 \s \fcmp \s 1 \otimes a
\quad = \quad b \fcmp a
\end{align*}
\end{example}

\begin{example}
A monoidal category with at most one arrow between any two objects is called a \emph{preordered monoid}.
The functoriality axiom implies that the preorder is in fact a pre-congruence, i.e. $a \leq b$ and $c \leq d$ implies $a \times c \leq b \times d$.
Given the presentation of a monoid $(X, R)$ with $R \sub X^\star \times X^\star$, we can construct a preordered monoid with $(\leq_R) = \bigcup_{n \in \N} R^n \sub X^\star \times X^\star$ the (non-symmetric) reflexive transitive closure of $R$.
Thus, the problem of deciding whether $x \leq_\R y$ given two lists $x, y \in X^\star$ and a presentation $(X, R)$ is a generalisation of the word problem for monoids.
\end{example}

\begin{example}
The category $\mathbf{FinSet}$ is monoidal with the singleton $1$ as unit and Cartesian product as tensor.
Again, this is not a strict monoidal category but it is equivalent to one: take the category with natural numbers $m, n \in \N$ as objects and functions $[m] \to [n]$ as arrows for $[n] = \{ 0, 1, \dots, n - 1 \}$.
The states can be identified with elements and discarding is the only effect.
$\mathbf{FinSet}$ is also monoidal with the empty set $0$ as unit and disjoint union as tensor.
\end{example}

\begin{example}
For any category $C$, there is a monoidal category $C^C$ where the objects are enfodunctors with composition as tensor and the arrows are natural transformations $\alpha : F \to F'$, $\beta : G \to G'$ with vertical composition $(\alpha \otimes \beta)(x) : G(F(x)) \to G'(F'(x))$ as tensor.
\end{example}

\subsection{Concrete monoidal categories}

\begin{example}
The category $\mathbf{Pyth}$ is monoidal with unit \py{()} and \py{tuple[t1, t2]} as the tensor of types \py{t1} and \py{t2}.
Given two functions \py{f} and \py{g}, we can define their tensor \py{f @ g = lambda x, y: f(x), g(y)}.

There are two caveats however.
First, $\mathbf{Pyth}$ is not strict monoidal: \py{(x, (y, z))} is not strictly equal to \py{((x, y), z)} but only naturally isomorphic, similarly for \py{((), x) != x != (x, ())}.
These natural isomorphisms are subject to coherence conditions which make sure that all the ways to rebracket \py{(((x, y), z), w)} into \py{(x, (y, (z, w)))} are the same.
In practice, this bureaucracy of parenthesis does not pose any problem: MacLane's coherence theorem~\cite[VII]{MacLane71} makes sure that every monoidal category is monoidally equivalent\footnote
{An \emph{equivalence} of categories is an adjunction where the unit and counit are in fact natural isomorphisms.
It is a \emph{monoidal equivalence} when they are also monoidal transformations.} to a strict one.
In the case of $\mathbf{Pyth}$, there is an equivalent monoidal structure with flattened tuples instead: \py{(t1 @ t2)  @ t3 = t1 @ (t2 @ t3)  = tuple[t1, t2, t3]}.

Second, the interchange law only holds for the subcategory of $\mathbf{Pyth}$ with \emph{pure functions} as arrows.
Indeed, if the functions \py{f} and \py{g} are impure (e.g. they call \py{random} or \py{print}) then their tensor \py{f @ g} will depend on the order in which they are evaluated, i.e. \py{f @ Id >> Id @ g != Id @ g >> f @ Id}.
As we will discuss in section~\ref{section:premonoidal}, $\mathbf{Pyth}$ is in fact a \emph{premonoidal category}.
The states, i.e. the functions \py{f : () -> t}, can be identified with their value \py{f(): t}.
There is only one pure effect, i.e. a unique pure function \py{f : t -> ()} called \emph{discarding}, and thus a unique pure scalar.
If we take all impure functions into account, the scalars form a non-commutative monoid of side-effects.
\end{example}

\begin{python}
{\normalfont Implementation of $\mathbf{Pyth}$ as a (non-strict pre)monoidal category.}

\begin{minted}{python}
def tensor(self: Function, other: Function) -> Function:
    dom, cod = tuple[self.dom, other.dom], tuple[self.cod, other.cod]
    return Function(dom, cod, lambda x, y: (self(x), self(y)))
\end{minted}
\end{python}

\begin{example}
With some effort, we can also make $\mathbf{Pyth}$ monoidal with the \emph{tagged union} as tensor on objects and \py{typing.NoReturn} as unit.
Given two types \py{t1, t2}, their tagged union \py{t1 + t2} is the union of the types \py{tuple[True, t1]} and \py{tuple[False, t2]}\footnote
{What we really mean is \py{tuple[Literal[True], t1] | tuple[Literal[False], t2]}.}, i.e. a term \py{(b, x): t1 + t2} is a pair of a Boolean \py{b: bool} and a term \py{x: t1} if \py{b} else \py{x: t2}.
Given two functions \py{f, g} we can define their tensor \py{f + g = lambda b, x: (b, f(x) if b else g(x))}.
\end{example}

\begin{example}
The category $\mathbf{Mat}_\S$ is monoidal with addition of natural numbers as tensor on objects and the \emph{direct sum} $f \oplus g = \big(\begin{smallmatrix}f & 0\\ 0 & g\end{smallmatrix}\big)$ as tensor on arrows.
When the rig $\S$ is commutative, $\mathbf{Mat}_\S$ is also monoidal with multiplication of natural numbers as tensor on objects and the \emph{Kronecker product} as tensor on arrows.
The inclusion functor $\mathbf{FinSet} \to \mathbf{Mat}_\B$ is monoidal in two ways: it sends disjoint unions to direct sums and Cartesian products to Kronecker products.
\end{example}

\begin{python}
{\normalfont Implementation of $\mathbf{Mat}_\S$ as a monoidal category with Kronecker product as tensor.}

\begin{minted}{python}
def tensor(self: Matrix, other: Matrix) -> Matrix:
    dom, cod = self.dom * other.dom, self.cod * other.cod
    inside = [[self[i_dom][i_cod] * other[j_dom][j_cod]
        for i_cod in range(self.cod) for j_cod in range(other.cod)]
        for i_dom in range(self.dom) for j_dom in range(other.dom)]
    return type(self)(inside, dom, cod)
\end{minted}
\end{python}

\begin{example}
The category $\mathbf{Circ}$ is monoidal with addition of natural numbers as tensor on objects and \emph{parallel composition} of circuits as tensor on arrows.
The evaluation functor $\mathtt{eval} : \mathbf{Circ} \to \mathbf{Mat}_\C$ is monoidal: it sends the parallel composition of circuits to the Kronecker product of their unitary matrices.
\end{example}

\subsection{Free monoidal categories}

Now, what does it mean to implement a monoidal category in Python?
Again, nothing more than defining a pair of classes for objects and arrows with a \py{tensor} method that satisfies the axioms.
Less trivially, we want to implement the arrows of \emph{free monoidal categories} which can then be interpreted in arbitrary monoidal categories via the application of monoidal functors: this is the content of the \py{discopy.monoidal} module.
As in the case of free categories, free monoidal categories will be the image of a functor $F : \mathbf{MonSig} \to \mathbf{MonCat}$, the left adjoint to the forgetful functor $U : \mathbf{MonCat} \to \mathbf{MonSig}$ from monoidal categories to \emph{monoidal signatures}.
A monoidal signature $\Sigma$ is a monoidal category without identity, composition or tensor: a pair of sets $\Sigma_0, \Sigma_1$ and a pair of functions $\dom, \cod : \Sigma_1 \to \Sigma_0^\star$ from boxes to lists of objects.
A morphism of monoidal signatures $f : \Sigma \to \Gamma$ is a pair of functions $f : \Sigma_0 \to \Gamma_0$ and $f : \Sigma_1 \to \Gamma_1$ with $f \fcmp \dom = \dom \fcmp f^\star$ and $f \fcmp \cod = \cod \fcmp f^\star$.
Thus, we have defined the category $\mathbf{MonSig}$ of monoidal signatures and their morphisms.
In order to define the forgetful functor $U : \mathbf{MonCat} \to \mathbf{MonSig}$, we will need the following technical lemma.

\begin{definition}
A monoidal category $C$ is \emph{foo} (free on objects) when its monoid of objects $(C_0, \otimes, 1)$ is a free monoid $C_0 = X^\star$ generated by some set of objects $X$.
\end{definition}

\begin{lemma}
Every monoidal category is monoidally equivalent to a foo one.
\end{lemma}

\begin{proof}
Given a monoidal category $C$, we construct $C'$ with objects $C_0^\star$ the free monoid over the objects of $C$ and $C'(x, y) = C(\epsilon_{C_0^\star}(x), \epsilon_{C_0^\star}(y))$ for $\epsilon_{C_0} : C_0^\star \to C_0$ the counit of the list adjunction.
That is, an arrow $f : x \to y$ between two lists $x, y \in C_0^\star$ in $C'$ is an arrow $f : \epsilon_{C_0}(x) \to \epsilon_{C_0}(y)$ between their multiplication in $C$.
From left to right, the monoidal equivalence $C \simeq C'$ sends every object $x \in C_0$ to its singleton list $x \in C_0^\star$ and every arrow to itself, from right to left it sends every list to its multiplication and every arrow to itself.
\end{proof}

This means we can take the data for a monoidal category $C$ to be the following:
\begin{itemize}
\item a class $C_0$ of \emph{generating objects} and a class $C_1$ of arrows,
\item domain and codomain functions $\dom, \cod : C_1 \to C_0^\star$,
\item a function $\id : C_0^\star \to C_1$ and a (partial) operation $\then : C_1 \times C_1 \to C_1$,
\item an operation on arrows $\tensor : C_1 \times C_1 \to C_1$ with $\dom (f \otimes g) = \dom(f) \dom(g)$ and $\cod (f \otimes g) = \cod(f) \cod(g)$.
\end{itemize}
The axioms for the objects to be a monoid now come for free, we only need to require that tensor on arrows is a monoid with the interchange law.
With this definition of (free-on-objects) monoidal category, we can define the forgetful functor $U : \mathbf{MonCat} \to \mathbf{MonSig}$: it forgets the identity, composition and tensor on arrows, but not the tensor on objects which is free.

\begin{example}
Take a monoid $M$ seen as a discrete monoidal category, we get an equivalent monoidal category $M'$ with objects the free monoid $M^\star$ and an isomorphism $x_1 \dots x_n \to y_1 \dots y_m$ whenever $x_1 \times \dots \times x_n = y_1 \times \dots \times y_m$ in $M$.
\end{example}

\begin{example}
In the cases of monoidal categories where the objects are the natural numbers with addition as tensor, such as $\mathbf{FinSet}$ with disjoint union, $\mathbf{Mat}_\S$ with direct sum or $\mathbf{Circ}$, the monoid of objects is already free: $(\N, +, 0)$ is the free monoid generated by the singleton set.
These monoidal categories are also called \emph{PROs} (for PROduct categories).
When the objects are generated by a more-than-one-element set they are called \emph{coloured PROs}, but a coloured PRO is precisely a foo-monoidal category.
For example, we can take all the Python types as colours and define $\mathbf{Pyth}$ as a foo-monoidal category.
\end{example}

\begin{python}
{\normalfont Implementation of the foo-monoidal category $\mathbf{Pyth}$ with \py{list[type]} as objects and \py{Function} as arrows.}

\begin{minted}{python}
untuple = lambda *xs: xs[0] if len(xs) == 1 else xs

class Function(cat.Function):
    dom: list[type]
    cod: list[type]

    def tensor(self, other: Tensor) -> Tensor:
        def inside(*xs):
            left, right = xs[:len(self.dom)], xs[len(self.dom):]
            return untuple(*(tuple(self(left)) + tuple(other(right))))
        return Function(inside, self.dom + other.dom, self.cod + other.cod)
\end{minted}
\end{python}

\begin{example}
In the case of $\mathbf{Mat}_\S$ with Kronecker product as tensor, we can define an equivalent category $\mathbf{Tensor}_\S$ where the objects are lists of natural numbers and the arrows $f : x_1 \dots x_n \to y_1 \dots y_m$ are $(x_1 \times \dots \times x_n) \times (y_1 \times \dots \times y_m)$ matrices, i.e. tensors of order $m + n$.
Note that we could define yet another equivalent category where the objects are lists of prime numbers instead.
\end{example}

\begin{python}
{\normalfont Implementation of the foo-monoidal category $\mathbf{Tensor}_\S \simeq \mathbf{Mat}_\S$ with \py{list[int]} as objects and \py{Tensor[dtype]} as arrows.}

\begin{minted}{python}
from functools import reduce as foldl
product = lambda x: foldl(lambda a, b: a * b, b, 1)

class Tensor(Matrix):
    dom: list[int]
    cod: list[int]

    def downgrade(self) -> Matrix:
        return Matrix[self.dtype](self.inside, product(self.dom), product(self.cod))

    @classmethod
    def id(cls, x: list[int]) -> Tensor:
        return cls(Matrix.id(product(x)).inside, x, x)

    def then(self, other: Tensor) -> Tensor:
        inside = self.downgrade().then(other.downgrade()).inside
        return type(self)(inside, self.dom, other.cod)

    def tensor(self, other: Tensor) -> Tensor:
        inside = self.downgrade().tensor(other.downgrade()).inside
        return type(self)(inside, self.dom + other.dom, self.cod + other.cod)
\end{minted}
\end{python}

Now how do we go on constructing the left adjoint $F : \mathbf{MonSig} \to \mathbf{MonCat}$?
In the same way that lists in the free monoid $X^\star$ can be defined as equivalence classes of expressions built from generators in $X$, product and unit, we can construct the arrows of the free monoidal category $F(\Sigma)$ as equivalence classes of expressions built from boxes in $\Sigma_1$, identity, composition and tensor.
In order to find good representatives for these equivalence classes, we will need the following technical lemma.

\begin{definition}
Given a monoidal signature $\Sigma$, we define a signature of \emph{layers} $L(\Sigma)$ with $\Sigma_0^\star$ as objects and triples $(x, f, y) \in \Sigma_0^\star \times \Sigma_1 \times \Sigma_0^\star$ as boxes with $\dom(x, f, y) = x \dom(f) y$ and $\cod(x, f, y) = x \cod(f) y$.
Given a morphism of monoidal signatures $f : \Sigma \to \Gamma$, we get a morphism between their signatures of layers $L(f) : L(\Sigma) \to L(\Gamma)$.
Thus, we have defined a functor $L : \mathbf{MonSig} \to \mathbf{Sig}$.
\end{definition}

\begin{lemma}
Fix a monoidal signature $\Sigma$.
Every well-typed expression built from boxes in $\Sigma_1$, identity of objects in $\Sigma_0^\star$, composition and tensor is equal to:
$$
\id(x) \s \text{for} \s x \in \Sigma_0^\star \quad \text{or} \quad
\id(x_1) \otimes f_1 \otimes \id(y_1)
\s \fcmp \s \dots \s \fcmp \s
\id(x_n) \otimes f_n \otimes \id(y_n)$$
for some list of layers $(x_1, f_1, y_1), \dots, (x_n, f_n, y_n) \in L(\Sigma)$.
\end{lemma}

\begin{proof}
By induction on the structure of well-typed expressions.
The only non-trivial case is for the tensor $f \otimes g$ of two expressions $f : x \to y$ and $g : z \to w$, where we need to apply the interchange law to push the tensor through the composition $f \otimes g = (f \fcmp \id(y)) \otimes (\id(z) \fcmp g) = f \otimes \id(z) \fcmp \id(y) \otimes g$.
\end{proof}

We have all the ingredients to define the free monoidal category $F(\Sigma)$: it is a quotient $F(L(\Sigma)) / R$ of the free category generated by the signature of layers $L(\Sigma)$.
Its objects, which we call \emph{types}, are lists in the free monoid $\Sigma_0^\star$.
Its arrows, which we call \emph{diagrams}, are paths with lists in $\Sigma_0^\star$ as nodes and layers $(x, f : s \to t, y) \in L(\Sigma)$ as edges $x s y \to x t y$.
The equality of diagrams is the smallest congruence generated by the \emph{right interchanger}:
$$
(a x b, \ g, \ c) \s \fcmp \s (a, \ f, \ b w c)
\quad \to_R \quad
(a, \ f, \ b z c) \s \fcmp \s (a y b, \ g, \ c)
$$
for all types $a, b, c \in \Sigma_0^\star$ and boxes $f : x \to y$ and $g : z \to w$.
That is, we can interchange two consecutive layers whenever the output of the first box is not connected to the input of the second, i.e. there is an identity arrow $\id(b)$ separating them.
Note that for an effect $f : x \to 1$ followed by a state $g : 1 \to y$, we have two options: we can apply the right interchanger $(1, f, 1) \fcmp (1, g, 1) \to_R (1, g, x) \fcmp (y, f, 1)$ or its opposite $(1, f, 1) \fcmp (1, g, 1) \leftarrow_R (x, g, 1) \fcmp (1, f, y)$.
For the composition of two scalars $a : 1 \to 1$ and $b : 1 \to 1$, we can apply interchangers indefinitely $a \fcmp b \to_R b \fcmp a \to_R a \fcmp b$: this is the Eckmann-Hilton argument.
Delpeuch and Vicary~\cite{DelpeuchVicary18} give a quadratic solution to the word problem for free monoidal categories, i.e. deciding when two diagrams are equal.

\begin{theorem}[\cite{DelpeuchVicary18}]
The equality of diagrams is decidable in linear time in the connected case, and quadratic in the general case.
The right interchanger is confluent and for connected diagrams, i.e. when the Eckmann-Hilton argument does not apply, it reaches a normal form in a cubic number of steps.
\end{theorem}

We have defined the equality of diagrams, there remains to define the tensor operation.
First, we define the \emph{whiskering} $f \otimes z$ of a diagram $f$ by an object $z \in \Sigma_0^\star$ on the right: we tensor $z$ to the right-hand side of each layer $(x_i, f_i, y_i)$, i.e. $f \otimes z = (x_1, f_1, y_1 z) \fcmp \dots \fcmp (x_n, f_n, y_n z)$ and symmetrically for the whiskering $z \otimes f$ on the left.
Then, we can define the tensor $f \otimes g$ of two diagrams $f : x \to y$ and $g : z \to w$ in terms of whiskering $f \otimes g = f \otimes z \s \fcmp \s y \otimes g$.
Note that we could have chosen to define $f \otimes g = x \otimes g \fcmp f \otimes w$, the two definitions are equated by the interchanger.

Given a morphism of monoidal signatures $f : \Sigma \to \Gamma$, we get a monoidal functor $F(f) : F(\Sigma) \to F(\Gamma)$ by relabeling: we have defined a functor $F : \mathbf{MonSig} \to \mathbf{MonCat}$.
We now have to show that it is indeed the left adjoint of $U : \mathbf{MonCat} \to \mathbf{MonSig}$.
This is very similar to the monoid case.
The unit $\eta_\Sigma : \Sigma \to U(F(\Sigma))$ sends objects to themselves and boxes $f : x \to y \in \Sigma$ to diagrams $(1, f, 1) \in L(\Sigma)$, i.e. the layer with empty lists on both sides of $f$.
The counit $\epsilon_C : F(U(C)) \to C$ is the functor which sends diagrams with boxes in $C$ to their evaluation, i.e. the formal composition and tensor of diagrams in $F(U(C))$ is sent to the concrete composition and tensor of arrows in $C$.
In the next section, we will show that this construction is in fact equivalent to the topological definition of diagrams as labeled graphs embedded in the plane.

\begin{python}\label{listing:Ty}
{\normalfont Outline of the class \py{monoidal.Ty}.}
\begin{minted}{python}
class Ty(Ob):
    def __init__(self, objects: list[Ob | str]):
        self.objects = [x if isinstance(x, Ob) else Ob(x) for x in objects]
        super().__init__("{}".format(' @ '.join([x.name for x in self.objects])))

    @classmethod
    def upgrade(cls, old: Ob) -> Ty:
        if isinstance(old, cls): return old
        return cls(old.objects) if isinstance(old, Ty) else cls(old)

    def tensor(self, *others: Ty) -> Ty:
        if any(not isinstance(other, Ty) for other in others):
            return NotImplemented  # This will allow whiskering on the left.
        return self.upgrade(Ty(
            self.objects + sum([other.objects for other in others], [])))

    __matmul__ = tensor
    __getitem__ = lambda self, key: self.upgrade(Ty([self.objects[key]]))
    __pow__ = lambda self, n: self.upgrade(Ty(n * self.objects))
\end{minted}
\end{python}

The implementation of the class \py{Ty} for types (i.e. lists of objects) is straightforward, it is sketched in listing~\ref{listing:Ty}.
The only subtlety is in the method \py{upgrade} which allows the user to subclass \py{Ty} in a way that the tensor of subclassed objects stays within the subclass, without having to redefine the \py{tensor} method.

\begin{example}
We can define a \py{Qubits} subclass and be sure that the tensor of qubits is still an instance of \py{Qubits}, not merely \py{Ty}.
\begin{minted}[fontsize=\footnotesize]{python}
class Qubits(Ty):
    def __init__(self, n: int):
        super().__init__(self, n * [Ob('1')])

    def upgrade(old):
        return Qubits(len(old.boxes))

qubit = Qubits(1)
assert qubit @ qubit == Qubits(2) and isinstance(qubit @ qubit, Qubits)
\end{minted}
\end{example}

The implementation of \py{Layer} as a subclass of \py{cat.Box} is sketched in listing~\ref{listing:Layer}.
It has methods \py{__matmul__} and  \py{__rmatmul__} for whiskering on the right and left respectively, and \py{upgrade} for turning boxes into layers with units on both sides.

\begin{python}\label{listing:Layer}
{\normalfont Outline of the class \py{monoidal.Layer}.}
\begin{minted}[fontsize=\footnotesize]{python}
class Layer(cat.Box):
    def __init__(self, left: Ty, box: cat.Box, right: Ty):
        self.left, self.box, self.right = left, box, right
        name = "{} @ {} @ {}".format(left, box, right)
        dom, cod = left @ box.dom @ right, left @ box.cod @ right
        super().__init__(name, dom, cod)

    def __matmul__(self, other: Ty) -> Layer:
        return Layer(self.left, self.box, self.right @ other)

    def __rmatmul__(self, other: Ty) -> Layer:
        return Layer(other @ self.left, self.box, self.right)

    @staticmethod
    def upgrade(old: cat.Box) -> Layer:
        return old if isinstance(old, Layer) else Layer(Ty(), old, Ty())
\end{minted}
\end{python}

Now we have all the ingredients to define \py{Diagram} as a subclass of \py{Arrow} with instances of \py{Layer} as boxes.
The \py{tensor} method accepts is defined in terms of left and right whiskering, it also accepts \py{Ty} as.
The \py{interchange} method takes an integer \py{i < len(self.layers)} and returns the diagram with layers \py{i} and \py{i + 1} interchanged, or raises an \py{AxiomError} if their boxes are connected.
It also takes an optional argument \py{left: bool} which allows to choose between left and right interchangers.
The \py{normal_form} method applies \py{interchange} until it reaches a normal form, or raises \py{NotImplementedError} if the diagram is disconnected.
The \py{draw} method renders the diagram as an image, it implements the drawing algorithm discussed in the next section.

\begin{python}
{\normalfont Outline of the class \py{monoidal.Diagram}.}
\begin{minted}{python}
class Diagram(cat.Arrow):
    def __init__(self, dom: Ty, cod: Ty, layers: list[Layer]):
        self.layers = layers; super().__init__(dom, cod, boxes=layers)

    @classmethod
    def upgrade(cls, old: cat.Arrow) -> Diagram:
        if isinstance(old, cls): return old
        layers = list(map(Layer.update, old.boxes))
        dom, cod = map(Ty.upgrade, (old.dom, old.cod))
        return cls(dom, cod, layers)

    def tensor(self, other: Diagram | Ty) -> Diagram:
        if isinstance(other, Ty): other = self.id(other)
        dom, cod = self.dom @ other.dom, self.cod @ other.cod
        layers = [layer @ other.dom for layer in self.layers]
        layers += [self.cod @ layer for layer in other.layers]
        return self.upgrade(Diagram(dom, cod, layers))

    def interchange(self, i: int, left=False) -> Diagram: ...
    def normal_form(self, left=False) -> Diagram: ...
    def draw(self, **params): ...
    __matmul__, __rmatmul__ = tensor, lambda self, other:\
        other @ self if isinstance(other, Diagram) else self.id(other) @ self
\end{minted}
\end{python}

Again, we have a class method \py{upgrade} which takes an old \py{cat.Arrow} and turns it into a new object of type \py{cls}, a given subclass of \py{Diagram}.
This means we do not need to repeat the code for identity or composition which is already implemented by \py{cat.Arrow}.
In turn, when the user defines a subclass of \py{Diagram}, they do not need to repeat the code for identity, composition or tensor.

\begin{example}
We can define \py{Circuit} as a subclass of \py{Diagram}. \py{Gate} and \py{Ket} are subclasses of \py{Circuit} and \py{Box}.
Now we can compose and tensor gates together and the result will be an instance of \py{Circuit}.

\begin{minted}{python}
class Circuit(Diagram): pass

class Gate(Circuit, Box):
    def __init__(self, name: str, n_qubits: int):
        Box.__init__(self, name, Qubits(n_qubits), Qubits(n_qubits))

class Ket(Circuit, Box):
    def __init__(self, *bits: bool):
        self.bits, dom, cod = bits, Qubits(0), Qubits(len(bits))
        name = "Ket({})".format(', '.join(map(str, bits)))
        Box.__init__(self, name, dom, cod)

Gate.upgrade = Ket.upgrade = Circuit.upgrade

H, CX = Gate("H", n_qubits=1), Gate("CX", n_qubits=2)
Id, sqrt2 = Circuit.id(Qubits(1)), Gate("sqrt(2)", n_qubits=0)
assert isinstance(sqrt2 @ Ket(0, 0) >> H @ Id >> CX, Circuit)
\end{minted}
\end{example}

The implementation of \py{monoidal.Box} as a subclass of \py{Diagram} and \py{cat.Box} is relatively straightforward, we only need to make sure that a box is equal to the diagram of just itself.
We also want the \py{upgrade} method of \py{Box} to be that of \py{Diagram}.

\begin{python}
{\normalfont Outline of the class \py{monoidal.Box}.}
\begin{minted}[fontsize=\footnotesize]{python}
class Box(Diagram, cat.Box):
    upgrade = Diagram.upgrade

    def __init__(self, name: str, dom: Ty, cod: Ty):
        cat.Box.__init__(self, name, dom, cod)
        Diagram.__init__(self, dom, cod, [Layer.upgrade(self)])

    def __eq__(self, other):
        if isinstance(other, Box): return cat.Box.__eq__(self, other)
        return isinstance(other, Diagram) and other.layers == [Layer.upgrade(self)]
\end{minted}
\end{python}

The \py{monoidal.Functor} class is a subclass of \py{cat.Functor}.
It overrides the \py{__call__} method to define the image of types and layers, and it delegates to its superclass for the image of objects, boxes and composition.

\begin{python}
{\normalfont Outline of the class \py{monoidal.Functor}.}
\begin{minted}{python}
class Functor(cat.Functor):
    def __call__(self, other):
        if isinstance(other, Ty):
            return self.ob_factory([self(x) for x in other.objects])
        if isinstance(other, Ob):
            return self.ob[other] if other in self.ob else self.ob[Ty(other)]
        if isinstance(other, Layer):
            left, box, right = other
            id_left, id_right = map(other.id, (left, right))
            return self(id_left) @ self(box) @ self(id_right)
        return super().__call__(other)
\end{minted}

Note that the domain the dictionary \py{ob} can be either an \py{Ob} or a \py{Ty} of length $1$.
\end{python}

\begin{example}
We can simulate quantum circuits by applying a functor from \py{Circuit} to \py{Tensor}.
\begin{minted}{python}
class Eval(Functor):
    def __init__(self):
        ob = {Ob('1'): 2}
        ar = {H: [[1 / sqrt(2), 1 / sqrt(2)],
                  [1 / sqrt(2), -1 / sqrt(2)]],
              CX: [[1, 0, 0, 0],
                   [0, 1, 0, 0],
                   [0, 0, 0, 1],
                   [0, 0, 1, 0]],
              sqrt2: [[sqrt(2)]]}
       super().__init__(ob, ar, ob_factory=tuple[int], ar_factory=Tensor[complex])

    def __call__(self, other):
        if isinstance(other, Ket):
            if not other.bits: return Tensor.id([])
            state = Tensor[complex]([[other.bits[0], not other.bits[0]]], [], [2])
            return state @ self(Ket(*others[1:]))
        return super().__call__(other)

Circuit.eval = Eval()
circuit = sqrt2 @ Ket(0, 0) >> H @ Id >> CX
superposition = Ket(0, 0) + Ket(1, 1)
assert circuit.eval() == superposition.eval()
\end{minted}
\end{example}

\begin{remark}
DisCoPy uses a more compact encoding of diagrams than their list of layers.
Indeed, a diagram is uniquely specified by a domain, a list of boxes and a list of \emph{offsets}, i.e. the length of the type to the left of each box.

\begin{minted}{python}
Encoding = tuple[Ty, list[tuple[Box, int]]]

def encode(diagram: Diagram) -> Encoding:
    return diagram.dom, [(box, len(left)) for left, box, _ in diagram.layers]

def decode(encoding: Encoding) -> Diagram:
    dom, boxes_and_offsets = encoding
    result = Diagram.id(dom)
    for box, offset in boxes_and_offsets:
        left, right = result.cod[:offset], result.cod[offset + len(box.dom):]
        result >>= Diagram.id(left) @ box @ Diagram.id(right)
    return result

x, y, z = map(Ty, "xyz")
f, g, h = Box('f', x, y), Box('g', y, z), Box('h', y @ z, x)
encoding = (x @ y, [(f, 0), (g, 1), (h, 0)])
assert decode(encoding) == f @ g >> h and encode(f @ g >> h) == encoding
\end{minted}
\end{remark}

\subsection{Quotient monoidal categories}

Once we have defined freeness, we need to define quotients.
The quotient $C / R$ of a monoidal category $C$ by a binary relation $R \sub \coprod_{x, y \in C_0^\star} C(x, y) \times C(x, y)$ is the quotient category for the rewriting relation $\to_R$ where:
$$u \fcmp \id(b) \otimes f \otimes \id(c) \fcmp v \quad
\to_R u \fcmp \id(b) \otimes f \otimes \id(c) \fcmp v$$
for all $b, c \in C_0^\star$, $u : a \to b x c$ and $f, g : x \to y \in R$.
Intuitively, if we can equate $f$ and $g$ then we can equate them in any context, i.e. with any objects $b$ and $c$ tensored on the left and right and any arrows $u$ and $v$ composed above and below.
A proof that two diagrams are equal in the quotient can itself be thought of as a diagram in three dimensions, i.e. the movie of a diagram being rewritten into another.
These higher-dimensional diagrams will be mentioned in section~\ref{section:related and future}.
Again, every monoidal category $C$ is isomorphic to the quotient of a free monoidal category $C = F(\Sigma) / R$: take $\Sigma = U(C)$ and the relation $R \sub F(U(C)) \times F(U(C))$ given by every binary composition and tensor.

Why should computer scientists care about diagrams?
One reason is that they are free data structures in the same sense that lists are free: they are a two-dimensional generalisation of lists.
Another reason is that they allow an elegant definition of a Turing-complete problem: given a finite monoidal signature $\Sigma$ and a pair of lists $x, y \in \Sigma_0^\star$, decide whether there is a diagram $f : x \to y$ in $F(\Sigma)$.
Indeed, the word problem for monoids (which is equivalent to the halting problem for Turing machines) reduces to the existence problem for diagrams: given the presentation of a monoid $X^\star / R$,
take objects $\Sigma_0 = X$ and boxes $\Sigma_1 = R$ with $\dom, \cod : \Sigma_1 \injects X^\star \times X^\star \to X^\star$ the left and right hand-side of each related pair.
For any pair $x, y \in X^\star$, we have that $x \leq_R y$ if and only if there is a diagram $f : x \to y$ in $F(\Sigma)$: the preordered monoid generated by the relation $R$ is the preorder collapse of the free monoidal category $F(\Sigma)$.
While monoid presentations define \emph{decision problems} (i.e. with a Boolean output), free monoidal categories naturally define \emph{function problems}: given a pair of types, output a diagram.

If we compose the two reductions together, we get a free monoidal category where diagrams are the possible runs of a given Turing machine.
Moreover, a monoidal functor from the category of one machine to another corresponds to a reduction between the problems they solve, the domain machine being simulated by the codomain.
Thus, we could very well take finite monoidal signatures as our definition of machine and diagrams as our definition of computation: algorithmic complexity is given by the size of signatures, time and space complexity are given by the length and width\footnote
{The width of a diagram is the maximum width of its layers, which is not preserved by interchangers.
In the diagrams generated by Turing machines, we cannot apply interchangers anyway: every box is connected to the next by the head of the machine.}
of diagrams.
The categories of complexity and the complexity of categories are not the subject of this thesis however, let's get back to Python programming.

\subsection{Daggers, sums and bubbles}

As in the previous section, we introduce three extra pieces of implementation: daggers, sums and bubbles.
A $\dagger$-monoidal category is a monoidal category with a $\dagger$ (i.e. an identity-on-objects involutive contravariant endofunctor) that is also a monoidal functor, a $\dagger$-monoidal functor is both a $\dagger$-functor and a monoidal functor.
They are implemented by adding a \py{dagger} method to the \py{Layer} class.

\begin{python}
{\normalfont Implementation of free $\dagger$-monoidal categories.}

\begin{minted}{python}
def dagger(self: Layer) -> Layer:
    return Layer(self.left, self.box.dagger(), self.right)
\end{minted}
\end{python}

A monoidal category is commutative-monoid-enriched when it has sums that distribute over the tensor, i.e. $(f + f') \otimes (g + g') = f \otimes g + f \otimes g' + f' \otimes g + f' \otimes g'$
and $f \otimes 0 = 0 = 0 \otimes f$.
They are implemented by a method \py{Sum.tensor}.

\begin{python}
{\normalfont Implementation of free monoidal categories with sums.}

\begin{minted}{python}
def tensor(self: Sum, other: Sum) -> Sum:
    dom, cod = self.dom @ other.dom, self.cod @ other.cod
    return Sum([f @ g for f in self.terms for g in self.terms], dom, cod)
\end{minted}
\end{python}

Bubbles for monoidal categories are the same as bubbles for categories, their implementation requires no extra work.
As we mentioned in the previous section, bubbles do give us a strictly more expressive syntax however: they can encode operations on arrows that cannot be expressed in terms of composition or tensor.

\begin{example}
As in example~\ref{example:endofunctor-bubbles}, any monoidal endofunctor $\beta : C \to C$ also defines a bubble on the monoidal category $C$, we can define a bubble-preserving functor $F(U(C)^\beta) \to C$ which interprets bubbled diagrams as functor application.
However, the disjoint union $C + D$ of two monoidal categories does not yield a well-defined monoidal category: we cannot tensor arrows of $C$ with those of $D$.
Thus, the case of monoidal functors $C \to D$ requires diagrams with different colours (for the inside and the outside of the bubble) which we will mention in section~\ref{section:extra structure}.
\end{example}

\begin{example}
We can implement the Born rule as a bubble on $\py{Circ}$ interpreted as element-wise squared amplitude.
We can also implement any classical post-processing as a bubble.

\begin{minted}{python}
Bra = lambda *bits: Ket(*bits)[::-1]
Born_rule = lambda x: abs(x) ** 2
Circuit.measure = lambda self: self.bubble(name="squared_amplitude")
Tensor.squared_amplitude = lambda self: self.map(Born_rule)

assert (Ket(0) >> H >> Bra(0)).measure().eval()[0][0] == .5

biased_ReLU = lambda x: max(0, 2 * x - 1)
Circuit.post_process = lambda self: self.bubble(name="non_linearity")
Tensor.non_linearity = lambda self: self.map(biased_ReLU)

circuit = Ket(0, 0) >> H @ Id >> CX >> Bra(0, 0)
post_processed_circuit = circuit.measure().post_process()
assert post_processed_circuit.eval()[0][0]\
    == biased_ReLU(Born_rule(circuit.eval()[0][0]))
\end{minted}
\end{example}

\begin{example}
We can implement the formulae of first-order logic using Peirce's \emph{existential graphs} which happen to be the first examples of string diagrams~\cite{BradyTrimble98,BradyTrimble00,MelliesZeilberger16,HaydonSobocinski20} as well as the first definition of first-order logic.
Bubbles, which Peirce calls \emph{cuts}, encode negation.
The evaluation of a formula in a finite model corresponds to the application of a bubble-preserving functor into $\mathbf{Mat}_\B$.

\begin{minted}{python}
class Formula(Diagram):
    cut = lambda self: self.bubble(name="_not")

class Predicate(Box, Formula):
    def __init__(self, name): Box.__init__(self, name, Ty(), Ty('x'))

def model(size, data: dict[Predicate, list[bool]]):
    Functor(ob={Ty('x'): size},
            ar={p: [data[p]] for p in data},
            ob_factory=list[int], ar_factory=Tensor[B])

men, mortal = map(Predicate, ("men", "mortal"))
all_men_are_mortal = (men.cut() >> mortal.dagger()).cut()

for a, b, c, d in itertools.product(*4 * [[0, 1]]):
    F = model(size=2, {men: [a, b], mortal: [c, d]})
    assert F(all_men_are_mortal) == all(
        not F(men)[i][0] or F(mortal)[i][0] for i in range(2))
\end{minted}
\end{example}

We get to the end of this section and the reader may have noticed that we have not drawn a single diagram yet: drawing will be the topic of the next section.
This absence of drawing intends to demonstrate that diagrams are not only a great tool for visual reasoning, they can also be thought of as a \emph{data structure for abstract pipelines}.
Monoidal functors then allow to evaluate these abstract pipelines in terms of concrete computation, be it Python functions, tensor operations or quantum circuits.
This abstract programming style, defining programs in terms of composition rather than arguments-and-return-value, is called \emph{point-free} or \emph{tacit programming}.
Because of the difficulty of writing any kind of complex program in that way, it has also been called the \emph{pointless style}.
DisCoPy provides a \py{@diagramize} decorator which allows the user to define diagrams using the standard syntax for Python functions instead of the point-free syntax.
Given \py{dom: Ty}, \py{cod: Ty} and \py{boxes: list[Box]} as parameters, it adds to each box a \py{__call__} method which takes the objects of its domain as input and returns the objects of its codomain.

\begin{example}
We can define quantum circuits as Python functions on qubits.

\begin{minted}{python}
kets0 = Ket(0, 0)

@diagramize(dom=Qubits(2), cod=Qubits(2), boxes=[sqrt2, kets0, H, CX])
def circuit():
    sqrt2(); qubit0, qubit1 = kets0
    return CX(H(qubit0), qubit1)

assert circuit == sqrt2 @ kets0 >> H @ Id >> CX
\end{minted}
\end{example}

The underlying algorithm constructs a graph with nodes for each object of the domain and the codomain of each box, as well as of the whole diagram.
There is an edge from a codomain node of a box (or a domain node of the whole diagram) to a domain node of a box (or a codomain node of the whole diagram) whenever the corresponding boxes are connected.
There is also a node for each box and an edge from that box node to its domain and codomain nodes.
First, we initialise the graph of the identity diagram and feed the objects of its codomain as input to the decorated function.
When a box is applied to a list of nodes, it adds edges going into each object of its domain and returns nodes for each object of its codomain.
Finally, the return value of the decorated function is taken as the codomain of the whole diagram.

\begin{python}\label{listing:diagram2graph}
{\normalfont Translation from \py{Diagram} to \py{Graph}.}

We use the graph data structure from \py{networkx}~\cite{HagbergEtAl08}.

\begin{minted}{python}
from networkx import Graph

Node = namedtuple('Node', ['kind', 'label', 'i', 'j'])

def diagram2graph(diagram: Diagram) -> Graph:
    graph = Graph()
    scan = [Node('dom', x, i, -1) for i, x in enumerate(diagram.dom)]
    graph.add_edges(zip(scan, scan))
    for j, (left, box, _) in enumerate(diagram.layers):
        box_node = Node('box', box, -1, j)
        dom_nodes = [Node('dom', x, i, j) for i in enumerate(box.dom)]
        cod_nodes = [Node('cod', x, i, j) for i in enumerate(box.cod)]
        graph.add_edges(zip(scan[len(left): len(left @ box.dom)], dom_nodes))
        graph.add_edges(zip(dom_nodes, len(box.dom) * [box_node]))
        graph.add_edges(zip(len(box.cod) * [box_node], cod_nodes))
        scan = scan[len(left):] + cod_nodes + scan[len(left @ box.dom):]
    graph.add_edges(zip(scan, [
        Node('cod', x, i, len(diagram)) for i, x in enumerate(diagram.cod)]))
    return graph
\end{minted}
\end{python}

The \py{graph2diagram} algorithm which translates the resulting graph into a diagram will be covered in the next section.
It will allow to automatically read \emph{pictures of diagrams} (i.e. matrices of pixels) and translate them into \py{Diagram} objects.
Note that in order to construct a \py{monoidal.Diagram} we need to assume \emph{plane graphs} as input, i.e. graphs with an embedding in the plane.
We also need to assume that every codomain node is connected to exactly one domain node.
In sections~\ref{section:extra structure} and \ref{section:related and future} we will discuss the case of diagrams induced by non-planar graphs, with potentially multiple edges between domain and codomain nodes.
Listing~\ref{listing:diagram2graph} shows the implementation of the inverse translation \py{diagram2graph} which outputs only planar graphs as we will show in the next section by constructing their embedding in the plane, i.e. their drawing.
