%!TEX root = ../../THESIS.tex

\section{A premonoidal approach} \label{section:premonoidal}

In the previous section, we have seen that cartesian closed categories give us enough syntax to interpret (simply typed) lambda terms.
Thus, we can execute the diagrams in a free cartesian closed category as functions by applying a functor into $\mathbf{Set}$ or $\mathbf{Pyth}$, we can also interpret them as functors by applying a functor into $\mathbf{Cat}$ with the cartesian product as tensor.
Now if we remove the cartesian assumption, the diagrams of free closed categories give us a programming language with higher-order functions where we cannot copy, discard or even swap data: the (non-commutative) \emph{linear lambda calculus}.
With a more restricted language, we get a broader range of possible interpretations.
For example, there can be only one cartesian closed structure on $\mathbf{Cat}$ (because any other would be naturally isomorphic) but are there any other monoidal closed structures?
Foltz, Lair and Kelly~\cite{FoltzEtAl80} answer the question with the positive: $\mathbf{Cat}$ has exactly two closed structures: the usual cartesian closed structure with the exponential $D^C$ given by the category of functors $C \to D$ and natural transformations, and a second one where the exponential $C \Rightarrow D$ is given by the category of functors $C \to D$ and \emph{transformations}, with no naturality requirement.

The corresponding tensor product on $\mathbf{Cat}$, i.e. the left adjoint $C \Box - \dashv C \Rightarrow -$, is called the \emph{funny tensor product}, maybe because mathematicians thought it was funny not to require naturality.
More explicitly, the funny tensor $C \Box D$ can be described as the push-out of $C \times D_0 \leftarrow C_0 \times D_0 \to C_0 \times D$ where $C_0, D_0$ are the discrete categories of objects, or equivalently as a quotient of the coproduct $(C \times D_0 + C_0 \times D) / R$ where the relations are given by $(0, \id(x), y) = (1, x, \id(y))$.
Even more explicitly, the objects of $C \Box D$ are given by the cartesian product $C_0 \times D_0$, the arrows are alternating compositions $(0, f_1, y_1) \fcmp (1, x_2, g_2) \fcmp \dots \fcmp (0, f_{n - 1}, y_{n -1}) \fcmp (1, x_n, g_n)$ of arrows in one category paired with an object of the other.
When the two categories are in fact monoids, the funny tensor is called the \emph{free product} because it sends free monoids to free monoids, i.e. $X^\star \Box Y^\star = (X + Y)^\star$.
This is also true for free categories, i.e. $F(\Sigma) \Box F(\Sigma') = F(\Sigma \times \Sigma'_0 \cup \Sigma_0 \times \Sigma)$, so maybe $\Box$ should be called free rather than funny.
While a functor on a cartesian product $F : C \times D \to E$ can be seen as a functor of two arguments that is functorial in both simultaneously, i.e. $F(f \fcmp f', g \fcmp f') = F(f, g) \fcmp F(f', g')$, a functor on a funny product $F : C \Box D \to E$ is functorial separately in its $C$ and $D$ arguments, i.e. $F(0, f \fcmp f', y) = F(0, f, y) \fcmp F(0, f', y)$ and $F(1, x, g \fcmp g') = F(1, x, g) \fcmp F(1, x, g')$.

\subsection{Premonoidal categories \& state constructions}\label{subsection:state-construction}

Now recall that a (strict) monoidal category $C$ is a monoid in $(\mathbf{Cat}, \times)$, i.e. the tensor is a functor on a cartesian product $\otimes : C \times C \to C$.
In a similar way, we define a (strict) \emph{premonoidal category} as a monoid in $(\mathbf{Cat}, \Box)$, i.e. a category $C$ with an associative, unital functor on the funny product $\boxtimes : C \Box C \to C$.
A (strict) \emph{premonoidal functor} is a functor that commutes with $\boxtimes$, i.e. $F(f \boxtimes g) = F(f) \boxtimes F(g)$, thus we get a category $\mathbf{PreMonCat}$.
Similarly a \emph{premonoidal transformation} is a transformation $\alpha : F \to G$ between two premonoidal functors such that $\alpha(x \boxtimes y) = \alpha(x) \boxtimes \alpha(y)$.
As for monoidal categories, we can show that every premonoidal category is premonoidally equivalent to a foo one, i.e. where the monoid of objects is free, thus we get a forgetful functor $U : \mathbf{PreMonCat} \to \mathbf{MonSig}$.
The image of $\boxtimes$ on objects may be given by concatenation, its image on arrows is called \emph{whiskering}, it is denoted by $\boxtimes(0, f, x) = f \boxtimes x$ and $\boxtimes(1, x, f) = x \boxtimes f$.
As we have seen in section~\ref{section:monoidal}, from whiskering we can define a (biased) tensor product on arrows $f \boxtimes g = f \boxtimes \dom(g) \fcmp \cod(f) \boxtimes g$ and conversely, we can define whiskering as tensoring with identity arrows.

Thus, we can take the data for a premonoidal category $C$ to be the same as that of a foo-monoidal category and the only axioms to be those for $(C_1, \boxtimes, \id(1))$ being a monoid.
That is, a premonoidal category is almost a monoidal category, only the interchange law does not necessarily hold.
Every monoidal category (functor) is also a premonoidal category (functor), hence we have an inclusion functor $\mathbf{MonCat} \injects \mathbf{PreMonCat}$.
An arrow of a premonoidal category $C$ is called \emph{central} if it interchanges with every other arrow, a transformation is called central if every component is central.
Every identity is central and composition preserves centrality, thus we can define the \emph{center} $Z(C)$ as the subcategory of central arrows and show that $Z : \mathbf{PreMonCat} \to \mathbf{MonCat}$ is in fact the right adjoint of the inclusion.
A \emph{symmetric premonoidal category} is a premonoidal category with a central natural isomorphism $S : x \boxtimes y \to y \boxtimes x$ such that the hexagon equations hold and $S(x, 1) = \id(x) = S(1, x)$.
Again, we get an inclusion functor from symmetric monoidal categories to symmetric premonoidal, and its right adjoint given by the center.

\begin{example}
A premonoidal category with one object is just a set with two monoid structures.
They do not satisfy the interchange law so the Eckmann-Hilton argument does not apply, the two monoids need not coincide nor be commutative.
In this case, the notion of center coincides with the usual notion of center of a monoid, i.e. the submonoid of elements that commute with everything else.
Indeed, the monoidal center of a one-object premonoidal is the intersection of the centers of its two monoid structures.
\end{example}

\begin{example}
For any small category $C$, the category $C \Rightarrow C$ of endofunctors $C \to C$ with (not-necessarily-natural) transformations as arrows is premonoidal.
\end{example}

\begin{example}
The category of matrices $\mathbf{Mat}_\S$ with entries in a rig $\S$ with the Kronecker product as tensor is a premonoidal category, it is monoidal precisely when $\S$ is commutative.
\end{example}

\begin{example}
The category $\mathbf{Pyth}$ with \py{tuple} as tensor is premonoidal.
Every pure function is in the center $Z(\mathbf{Pyth})$, but the converse is not necessarily true: take the side effect $f : x \to 1$ which increments a private, internal counter every time it is called.
It is impure, but not enough that we can observe it by parallel composition, i.e. although it does not commute with copy and discard, it can still be interchanged with any other function.
In other words, it is in the monoidal center, but not the cartesian center (i.e. the subcategory of comonoid homomorphisms).
\end{example}

Premonoidal categories were introduced by Power and Robinson~\cite{PowerRobinson97} as a way to model programming languages with side effects, reformulating an earlier framework of Moggi~\cite{Moggi91} which captured notions of computation as \emph{monads}.
Our last two examples can be seen as special cases of a more general pattern: they are \emph{Kleisli categories} for a \emph{strong monad}.
Infamously, a monad is just a monoid $T : C \to C, \mu : T \fcmp T \to T$, $\eta : 1 \to T$ in the category $C^C$ of endofunctors with natural transformations as arrows.
Its Kleisli category $K(T)$ has the same objects as $C$ and arrows given by $K(T)(x, y) = C(x, T(y))$, with the identity given by the unit $\id_K(x) = \eta(x)$ and composition given by post-composition with the multiplication, i.e. $f \fcmp_K g = f \fcmp T(g) \fcmp \mu(z)$ for $f : x \to T(y)$ and $g : y \to T(z)$.
Now if $C$ happens to be a monoidal category, we can ask for $T$ to be a monoidal functor, but we also want the multiplication and unit of the monad to play well with the monoidal structure.
We could ask for a \emph{monoidal monad} where $\mu$ and $\eta$ are monoidal transformations, i.e. for the monad to be a monoid in the category of monoidal endofunctors and monoidal natural transformations and show that the Kleisli category $K(T)$ inherits a monoidal structure.
More generally, we can ask only for a (bi)\emph{strong monad}, equipped with two natural transformations $\sigma(a, b) : a \otimes T(b) \to T(a \otimes b)$ and $\tau(a, b) : T(a) \otimes b \to T(a \otimes b)$ subject to sufficient conditions for the Kleisli category $K(T)$ to inherit a premonoidal structure.
It is monoidal precisely when the monad is commutative, i.e. the two arrows from $T(x) \otimes T(y)$ to $T(x \otimes y)$ are equal.

\begin{example}
Take the category $C = \mathbf{FinSet}$ and the \emph{distribution monad} $T(X) = \S^X$ for a rig $\S$ with the image on arrows given by \emph{pushforward} $T(f : X \to Y)(p : X \to \S) : y \mapsto \sum_{x \in f^{-1}(y)} p(x)$, the multiplication and unit induced by the rig multiplication and unit.
Its Kleisli category is precisely the category $\mathbf{Mat}_S$ of matrices, i.e. functions $m : Y \to \S^X \simeq X \times Y \to \S$.
One can show this is a strong monad, and it is commutative precisely when the rig is commutative.
\end{example}

\begin{example}
Take any closed symmetric category $C$ and the \emph{state monad} $T(x) = s^{s \otimes x}$ for some object $s$, an arrow $f : x \to y$ in the Kleisli category $K(T)$ is given by an arrow $f : s \otimes x \to s \otimes y$ in $C$ (up to uncurrying).
One can show that $T$ is strong and thus $K(T)$ is premonoidal.
When $C = \mathbf{Set}$ the state monad is a non-commutative as it gets: $T$ is commutative if and only if $s$ is trivial.
Whiskering an arrow $f : s \otimes x \to s \otimes y$ by an object $z$ on the left is given by pre- and post-composition with swaps $z \boxtimes f = S(s, z) \otimes x \ \fcmp \ z \otimes f \ \fcmp \ S(z, s) \otimes y$, whiskering on the right is easier $f \boxtimes z = f \otimes z$.
\end{example}

Jeffrey~\cite{Jeffrey97} then gave the first definition of free premonoidal categories, his construction formalises the intuition that non-central arrows are to be thought as arrows with side effects.
The \emph{state construction} takes as input a symmetric monoidal category $C$ and an object $s$, and builds a symmetric premonoidal category $\mathbf{St}(C, s)$ with the same objects as $C$, arrows given by $\mathbf{St}(C, s)(x, y) = C(s \otimes x, s \otimes y)$ and whiskering defined as in the state monad.
Intuitively, an arrow in $\mathbf{St}(C, s)$ is an arrow in $C$ which also updates a global state encoded in the object $s$, which we can draw as an extra wire passing through every box of the diagram, preventing them from being interchanged.
More formally, given a monoidal signature $\Sigma$ we can construct the free symmetric premonoidal category $F^{SP}(\Sigma) = \mathbf{St}(F^S(\Sigma + \{ s \}), s)$ as the state construction over the free symmetric category with an extra object.
We can generalise this to (non-symmetric) free premonoidal categories but we still need symmetry at least for the extra object, i.e. natural isomorphisms $S(s, x) : s \otimes x \to x \otimes s$ for each object $x$, subject to hexagon and unit equations.

We call this definition of the free premonoidal category as a state construction over a free monoidal category with an extra swappable object the \emph{monoidal approach} to premonoidal categories.
In what we call the \emph{premonoidal approach} to monoidal categories, definitions go the other way around with free premonoidal categories as the fundamental notion and free monoidal categories as an interesting quotient.
Indeed, we have been using the arrows of free premonoidal categories all along: they are string diagrams, defined as lists of layers without quotienting by interchanger.
Equivalently, they are labeled generic progressive plane graphs up to generic deformation, i.e. with at most one box node at each height.
While in the monoidal approach, string diagrams are defined as non-planar graphs and the ordering of boxes is materalised by extra wires connecting the boxes in sequence, in the premonoidal approach we take this ordering as data: boxes are in a list.
This comes with an immediate advantage: equality of premonoidal diagrams can be defined in terms of equality of lists, hence it is decidable in linear time whereas equality of monoidal diagrams has quadratic complexity and equality of symmetric diagrams could be as hard as graph isomorphism.
Another advantage of representing string diagrams with lists rather than graphs is that the code for functor application, i.e. the interpretation of diagrams, is a simple \py{for} loop rather than an elaborate graph algorithm, it requires no choices.
Similarly, the algorithm for drawing premonoidal diagrams requires almost no choices, the order of wires and boxes is fixed, we can only choose their shape and the spacing between them.
On the other hand, drawing graphs requires complex heuristics and graphical interfaces in order to get satisfying results.

\subsection{Hypergraph versus premonoidal diagrams}\label{subsection:hypergraph-vs-premonoidal}

In order to compare the two approaches, we need to say a few words about how string diagrams for symmetric categories are implemented.
Recall from sections~\ref{subsection:symmetric} and \ref{subsection:hypergraph} that equality of diagrams in symmetric and hypergraph categories reduce to graph and hypergraph isomorphisms respectively.
This can be made explicit by implementing these diagrams as graphs and hypergraphs rather than lists of layers with explicit boxes for swaps and spiders.
Given a monoidal signature $\Sigma$, a \emph{hypergraph diagram} (also called hypergraphs with \emph{ports}) $f$ is given by:
\begin{itemize}
\item its domain and codomain $\dom(f), \cod(f) \in \Sigma_0^\star$,
\item a list of boxes $\boxes(f) \in \Sigma_1^\star$ from which we define:
\begin{itemize}
    \item $\mathtt{input\_ports}(f) = \cod(f) + \coprod_i \dom(f_i)$,
    \item $\mathtt{output\_ports}(f) = \dom(f) + \coprod_i \cod(f_i)$,
    \item and $\mathtt{ports}(f) = \mathtt{input\_ports}(f) + \mathtt{output\_ports}(f)$
\end{itemize}
\item a number of \emph{spiders} $\mathtt{spiders}(f) = n \in \N$ together with their list of types $\mathtt{spider\_types}(f) \in \Sigma_0^{n}$,
\item a set of \emph{wires} $\mathtt{wires}(f) : \mathtt{ports}(f) \to \mathtt{spiders}(f)$.
\end{itemize}
The tensor of two hypergraph diagrams is given by concatenating their domain, codomain, boxes and spiders.
The composition is defined in terms of \emph{pushouts}.
Given $f : x \to y$ and $g : y \to x$ we have a \emph{span} of functions $\mathtt{spiders}(f) \leftarrow y \rightarrow \mathtt{spiders}(g)$ induced by the wires from the codomain of $f$ and the domain of $g$, we define $\mathtt{spiders}(f \fcmp g)$ as the size of the quotient set $(\mathtt{spiders}(f) + \mathtt{spiders}(g)) / R$ under the relation given by the codomain wires of $f$ and the domain wires of $g$.
Concretely, this is computed as the reflexive transitive closure of the binary relation on $\mathtt{spiders}(f) + \mathtt{spiders}(g)$.
The identity diagram $\id(x)$ has $\mathtt{spiders}(f) = \vert x \vert$ and wires given by the two injections $\vert x \vert + \vert x \vert \to \mathtt{spiders}(f)$.
Now we can define a notion of interchanger which takes a hypergraph diagram $f$ and some index $i < \vert \boxes(f) \vert$ and returns the diagram with boxes $i$ and $i + 1$ interchanged, i.e. with the wires relabeled appropriately.
While the interchanger of monoidal diagrams is ill-defined when the boxes are connected, that of hypergraph diagrams is always defined.
The category $\mathbf{Hyp}(\Sigma)$ with equivalence classes of hypergraph diagrams is in fact isomorphic to the free hypergraph category $F^H(\Sigma)$ which we defined in section~\ref{subsection:hypergraph} in terms of special commutative Frobenius algebras~\cite[Theorem 3.3]{BonchiEtAl16}.
The data structure for hypergraph diagrams has swaps and spiders built-in: they are hypergraph diagrams with no boxes.

We say a hypergraph diagram is \emph{bijective} when each spider to be connected to either zero or two ports, so that they define a bijection $\mathtt{ports}(f) \to \mathtt{ports}(f)$.
We conjecture the subcategory of bijective hypergraph diagrams is isomorphic to the free compact-closed category defined in section~\ref{subsection:rigid} in terms of cups and caps.
Spiders connected to zero ports correspond to dimension scalars, i.e. circles composed of a cap then a cup.
A hypergraph diagram is \emph{monogamous} when each spider is connected to exactly one input port and one output port, so that they define a bijection $\mathtt{output\_ports}(f) \to \mathtt{input\_ports}(f)$.
We conjecture the subcategory of monogamous hypergraph diagrams is the free traced symmetric category as defined in section~\ref{subsection:traced}.
We have not been able to find a proof of this statement nor of the compact-closed case in the literature, although they are a straightforward generalisation of \cite[Theorem 3.3]{BonchiEtAl16}.

A hypergraph diagram is \emph{progressive} when it is monogamous and furthermore when the output port of box $i$ is connected to the input port of box $j$ we have $i < j$.
An equivalent condition is that the underlying hypergraph obtained by forgetting the ports is \emph{acyclic} and the order of boxes witnesses that acyclicity.
An interchanger between boxes $i$ and $i + 1$ is progressive when the two boxes are not connected, i.e. progressive interchangers preserve progressivity.
The resulting category of progressive hypergraph diagrams up to progressive interchangers is isomorphic to the free symmetric category defined in section~\ref{subsection:symmetric} in terms of braidings~\cite[Theorem~3.12]{BonchiEtAl16}.
If we remove the interchanger quotient, we get premonoidal versions of free hypergraph, compact closed, traced and symmetric categories.
Traced preonoidal categories were introduced by Benton and Hyland~\cite{BentonHyland03} in order to model recursion in the presence of side-effects.
To the best of our knowledge, no one has ever considered premonoidal compact closed categories: the snake equations still hold but we cannot yank the snakes away if there are obstructions, i.e. the snake removal algorithm of section~\ref{section:monoidal} does not apply.

At every level of this symmetric-traced-compact-hypergraph hierarchy, premonoidal diagrams have the same linear-time algorithm for deciding equality, the data structure for hypergraph diagrams faithfully encode the premonoidal axioms without needing to compute any quotient: normal form becomes identity.
Now suppose we want to compute the interpretation of such a hypergraph diagram in a category given only access to its methods for identity, composition, tensor, swaps and spiders.
This requires to compute the isomorphism $\mathbf{Hyp}(\Sigma) \to F^H(\Sigma)$, i.e. we want to describe the given hypergraph diagram as a chosen representative in its equivalence class of premonoidal diagrams with explicit boxes for swaps and spiders.
The inverse isomorphism $F^H(\Sigma) \to \mathbf{Hyp}(\Sigma)$ is computed by applying a premonoidal functor (i.e. a \py{for} loop on a list of layers) sending swap and spider boxes to hypergraph diagrams with no boxes.

This isomorphism is implemented in the \py{hypergraph} module of DisCoPy which is outlined below.
The composition method calls a \py{pushout} subroutine which takes as input the numbers of spiders on the left and right, the wires from some common boundary ports to the left and right spiders, and returns the two injections into their pushout.
The three properties for bijective, monogamous and progressive diagrams implement the subcategory of compact closed, traced and symmetric diagrams respectively.
The three corresponding methods take a diagram and add explicit boxes for spiders, cups and caps so that \py{f.make_bijective().is_bijective} for all \py{f: Diagram} and similarly for monogamous and progressive.
The \py{downgrade} method calls \py{make_progressive} to construct a \py{compact.Diagram} with explicit boxes for swaps and spiders.

The method \py{cast} applies a \py{compact.Functor} so that \py{cast(f.downgrade()) == f} on the nose for any \py{f: Diagram} and \py{cast(f).downgrade()} is equal to any \py{f: compact.Diagram} up to the special commutative Frobenius axioms.
The \py{draw} method uses a randomised force-based layout algorithm for graphs to compute an embedding from the hypergraph diagram to the plane where wires do not cross too much.
This is still an experimental feature and the results of \py{f.draw()} usually look much worse than the drawing of \py{f.downgrade().draw()} using the deterministic algorithm of section~\ref{section:drawing}.

\begin{python}\label{listing:discopy-hypergraph}
{\normalfont Outline of the \py{discopy.hypergraph} module.}

\begin{minted}{python}
def pushout(left: int, right: int,
            left_wires: tuple[int, ...], right_wires: tuple[int, ...]
            ) -> tuple[dict[int, int], dict[int, int]]: ...

@dataclass
class Diagram(Composable, Tensorable):
    dom: Ty
    cod: Ty
    boxes: tuple[Diagram, ...]
    wires: tuple[int, ...]
    spider_types: tuple[Ty, ...]

    @staticmethod
    def id(x: Ty) -> Diagram: ...
    def then(self, *others: Diagram) -> Diagram: ...
    def tensor(self, *others: Diagram) -> Diagram: ...
    def interchange(self, i: int) -> Diagram: ...

    swap: Callable[[Ty, Ty], Diagram] = staticmethod(...)
    spiders: Callable[[int, int, Ty], Diagram] = staticmethod(...)

    is_bijective: bool = property(...)
    is_monogamous: bool = property(...)
    is_progressive: bool = property(...)

    def make_bijective(self) -> Diagram: ...
    def make_monogamous(self) -> Diagram: ...
    def make_progressive(self) -> Diagram: ...

    def downgrade(self) -> compact.Diagram: ...

    cast = staticmethod(compact.Functor(
        ob=lambda x: Ty(x.inside[0]),
        ar=lambda box: Box(box.name, box.dom, box.cod),
        cod=Category(Ty, Diagram)))

    def draw(self, **params): ...

class Box(Diagram):
    def __init__(self, name: str, dom: Ty, cod: Ty):
        boxes, spider_types, wires = (self, ), tuple(map(Ty, dom @ cod)), ...
        self.name = name; super().__init__(dom, cod, boxes, wires, spider_types)

    __eq__ = lambda self, other: cat.Box.__eq__(self, other)\
            if isinstance(other, Box) else super().__eq__(other)
\end{minted}
\end{python}

In some cases however, we can compute the interpretation of hypergraph diagrams without having to downgrade them back to premonoidal diagrams.
This is the case for \emph{tensor networks}, i.e. hypergraph diagrams interpreted in the category $\mathbf{Tensor}_\S$.
Indeed, rather than applying premonoidal functors into our naive \py{Matrix} class, DisCoPy can translate hypergraph diagrams as input to \emph{tensor contraction} algorithms such as the Einstein summation of NumPy~\cite{VanDerWaltEtAl11} combined with the just-in-time compilation of JAX~\cite{BradburyEtAl20}, or the specialised TensorNetwork library~\cite{RobertsEtAl19}.
Another example is that of quantum circuits: they are inherently symmetric diagrams.
Indeed, the data structure for circuits in a quantum compiler such as t$\vert$ket$\rangle$~\cite{SivarajahEtAl20} is secretly some premonoidal symmetric category: objects are lists of qubit (and bit) identifiers, arrows (i.e. circuits) are lists of operations.
When circuits are encoded as premonoidal diagrams as we have done in example~\ref{example:circuit-diagrams}, qubits are forced into a line because their wires are ordered from left to right, thus applying gates to non-adjacent qubits is encoded in terms of swap boxes.
When we apply a premonoidal functor to the category of t$\vert$ket$\rangle$ circuits, those swap boxes are not interpreted as the physical operation of applying three CNOT gates, but as the logical operation of relabeling our qubit identifiers.
It is then the job of the compiler to map these symmetric diagrams (where every qubit can talk to every other) onto the architecture of the machine and potentially introduce physical swaps when a logical gate applies to physical qubits that are not adjacent.

The main advantage of representing diagrams as hypergraphs rather than lists is that we can use graph rewriting algorithms to implement quotient categories.
Indeed, the \emph{double push-out} (DPO) rewriting of Ehrig et al.~\cite{EhrigEtAl73} can be extended from graphs to hypergraph diagrams so that we can match the left-hand side of an axiom in a hypergraph diagram and then compute the substitution with the right-hand side~\cite{BonchiEtAl20}.
Abstractly, DPO rewriting takes two hypegraph diagrams \py{self} and \py{pattern} and iterates through all possible \py{match} (i.e. pairs of diagrams for top and bottom and pairs of types for left and right as defined in section~\ref{subsection:quotient-monoidal}) such that \py{match.subs(pattern)} is equal to \py{self} up to interchanger.
This can be extended to the case of symmetric diagrams by implementing a Boolean property \py{match.is_convex} that makes sure that pattern matching does not introduce spiders~\cite{BonchiEtAl16}.
DPO rewriting has been the basis of tools such as Quantomatic and its successor PyZX~\cite{KissingerVanDeWetering19}~\cite{KissingerZamdzhiev15} for automated diagrammatic reasoning, it is also at the core of circuit optimisation in the t$\vert$ket$\rangle$ compiler.
DisCoPy implements back and forth translations from diagrams to both PyZX and t$\vert$ket$\rangle$, thus we can use their rewriting engines to implement quotient categories, i.e. to define normal forms.

However, the hypergraph approach breaks down in the case of non-symmetric monoidal categories.
Indeed, the monoidal functor from the free monoidal category to the free symmetric category is not faithful, for example it sends two nested circles and two circles side by side to the same hypergraph diagram.
We conjecture that the category of planar\footnote
{A hypergraph diagram is planar when we can embed it in the plane, or equivalently it is the image of a swap-free premonoidal diagram.} progressive hypergraph diagrams is the free \emph{spacial category}, i.e. one with $s \otimes x = x \otimes s$ for all scalars $s : 1 \to 1$ and objects $x$.
Translated in terms of the topological definition of string diagrams, this would correspond to taking labeled progressive plane graphs up to deformation of three-dimensional space rather than up to deformation of the plane~\cite[Conjecture~3.4]{Selinger10}.
When presented as quotients of free monoidal categories, spacial categories require an infinite family of axioms indexed by all possible scalar diagrams: in the absence of symmetry we cannot decompose the equation $(f \fcmp g) \otimes x = x \otimes (f \fcmp g)$ for a state $f : 1 \to y$ followed by an effect $g : y \to 1$ in terms of two smaller equations about $f$ and $g$ passing through the wire $x$.
That every braided monoidal category is spacial follows from the naturality of the braiding, we do not know of any natural example of non-free non-braided spacial category.
Moreover, it is an open question whether we can extend DPO rewriting to the case of spacial monoidal categories, i.e. whether there is an efficiently checkable condition that ensures that pattern matching does not introduce swaps.

Thus, DisCoPy's planar premonoidal approach to string diagrams allows to define diagrams in non-symmetric categories that cannot be defined as hypergraphs.
Although the concrete examples of categories we have discussed so far (functions, matrices, circuits) are all symmetric, planarity is essential if we are to model grammatical structure in terms of string diagrams as we will in section~\ref{section:NLP}.
Indeed, the left to right order of wires in a planar diagram encode the chronological order of words in a sentence, allowing arbitrary swaps would make grammaticality permutation-invariant: if a sentence is grammatical, then so would be any random shuffling of it.
More impotantly, planarity in grammar has been given a cognitive explanation.
In order to minimise the computational resources needed by the brain, human languages tend to minimise the distance between words that are syntactically connected~\cite{FutrellEtAl15} and the minimisation of swaps comes as a side-effect~\cite{Cancho06}.
It can also be given a complexity-theoretic explanation: planar grammatical structures such as Chomsky's syntax trees, Lambek's pregroup diagrams or Gaifman's dependency trees (which we introduce in section~\ref{section:NLP}) are all \emph{context-free}, they have the same expressive power as \emph{push-down automaton}.
In languages such as Dutch and Swiss German, \emph{cross-serial dependencies} are counter examples where grammatical wires are allowed to cross, albeit in a restricted way that makes them \emph{mildly context-sensitive}~\cite{Stabler04}.
Yeung and Kartsaklis~\cite{YeungKartsaklis21} showed that up to word reordering, the diagrams for these cross-serial dependencies can always be rewritten in a planar way using naturality.
They then used DisCoPy to encode every sentence of Alice in Wonderland as a diagram, ready to be translated into a circuit and sent to a quantum computer.

\subsection{Towards higher-dimensional diagrams}\label{subsection:towards-higher}

The premonoidal approach is also well-suited to be generalised from two- to arbitrary-dimensional diagrams.
The first step would be to add some colours to our diagrams, generalising them from monoidal categories to (strict) \emph{2-categories}, or equivalently from premonoidal categories to \emph{sesquicategories}.
The data for a sesquicategory $C$ is given by:
\begin{itemize}
    \item the data for a category $(C_0, C_1, \dom_0, \cod_0, \fcmp_0, \id_0)$ where the objects $C_0$ and arrows $C_1$ are called the class of $\emph{0- and 1-cells}$,
    \item a class $C_2$ of \emph{2-cells},
    \item domain and codomain $\dom_1, \cod_1 : C_2 \to C_1$,
    \item an identity $\id_1 : C_1 \to C_2$ and a partial composition $(\fcmp_1) : C_2 \times C_2 \to C_1$.
\end{itemize}
such that the following holds
\begin{itemize}
    \item $C(x, y) = \{ f \in C_2 \ \vert f : x \to y \}$ is a category for every pair of 1-cells $x, y \in C_1$,
    \item composition of 1-cells is a functor $(\fcmp)_0 : C(x, y) \Box C(y, z) \to C(x, z)$ for $\Box$ the funny tensor product on $\mathbf{Cat}$.
\end{itemize}
The axioms for 2-categories are the same but now composition is a bifunctor $\fcmp_1 : C(x, y) \times C(y, z) \to C(x, z)$ on a cartesian product.
Every bifunctor is also functorial in its two arguments separately thus every 2-category is also a sesquicategory.
The canonical example of a (2-category) sesquicategory is $\mathbf{Cat}$ with categories as 0-cells, functors as 1-cells and (natural) transformations as 2-cells.
Every monoidal (premonoidal) category is a 2-category (sesquicategory) with one 0-cell.
A 2-functor $F : C \to D$ between two 2-categories is given by three functions $\{ F_i : C_i \to D_i \}_{0 \leq i \leq 2}$ such that $(F_0, F_1) : (C_0, C_1) \to (D_0, D_1)$ and $(F_1, F_2) : C(x, y) \to D(F_1(x), F_1(y))$ are functors for all $x, y \in C_1$.

Free sesquicategories are defined in the same way as free premonoidal categories (i.e. as lists of layers) except that now every type comes itself with a domain and codomain, represented as the background colours on the left and right of the wire.
Thus we need a \emph{2-signature} $\Sigma = (\Sigma_0, \Sigma_1, \Sigma_2, \dom, \cod)$ where
\begin{itemize}
    \item $\Sigma_0$ is a set of colours,
    \item $\Sigma_1$ is a set of objects with colours as domain and codomain,
    \item $\Sigma_2$ is a set of boxes with domain and codomain in the free category $F(\Sigma_0, \Sigma_1)$, i.e. lists of generating objects with composable colours.
\end{itemize}
We also need to require the \emph{globular conditions} $\dom(\dom(f)) = \dom(\cod(f))$ and $\cod(\dom(f)) = \cod(\cod(f))$ that ensure that the top-left (top-right) colour is the same as the bottom-left (bottom-right, respectively).
Intuitively, the only changes in background colour happen at the wires, labeled by a generating object with the appropriate domain and codomain.
The free 2-category $F^{2C}(\Sigma)$ can then be described by its set of \emph{0-cells} $\Sigma_0$ (the colours), its category of \emph{1-cells} $F(\Sigma_0, \Sigma_1)$ (the types) and a category for every pair of 1-cells: the category of coloured diagrams up to interchanger.
The implementation is straightforward: we just need to make \py{Ty} a subclass of both \py{monoidal.Ty} (so that it can be used as domain and codomain for diagrams) and \py{Arrow} (so that it can have a domain and codomain itself).

\begin{python}\label{listing:free-sesquicategory}
{\normalfont Implementation of the free sesquicategory with \py{Colour} as 0-cells, \py{Ty} as 1-cells and \py{Diagram} as 2-cells.}

\begin{minted}{python}
class Colour(cat.Ob):
    def __init__(self, name="white"):
        super().__init__(name)

class Ty(cat.Arrow, monoidal.Ty):
    def __init__(self, inside: cat.Arrow | str, dom=Colour(), cod=Colour()):
        inside = inside if isinstance(inside, Arrow) else cat.Box(inside, dom, cod)
        Arrow.__init__(self, inside.inside, inside.dom, inside.cod)

    @classmethod
    def cast(cls, old: Arrow | monoidal.Ty) -> Ty:
        return old if isinstance(old, cls) else cls(
            old.inside if isinstance(old, monoidal.Ty) else old)

    tensor = Arrow.then

class Layer(monoidal.Layer): pass

class Diagram(monoidal.Diagram): pass

class Box(monoidal.Box, Diagram):
    def __init__(self, name: str, dom: Ty, cod: Ty):
        assert (dom.dom, dom.cod) == (cod.dom, cod.cod)
        monoidal.Box.__init__(self, name, dom, cod)

@dataclass
class TwoCategory(Category):
    colours: type

@dataclass
class TwoFunctor(monoidal.Functor):
    colours: dict[Ob, Ob]

    dom = cod = TwoCategory(colours=Colour, ob=Ty, ar=Diagram)

    def __call__(self, other):
        if isinstance(other, (Diagram, Layer)): return super().__call__(other)
        dom, cod = (Category(C.colours, C.ob) for C in [self.dom, self.cod])
        return cat.Functor(ob=self.colours, ar=self.ob, dom=dom, cod=cod)(other)
\end{minted}
\end{python}

\begin{python}\label{listing:Transformation}
{\normalfont Implementation of $\mathbf{Cat}$ as a sesquicategory with transformations as 2-cells.}

\begin{minted}{python}
class Transformation(Composable, Tensorable):
    def __init__(self, inside: Callable, dom: Functor, cod: Functor):
        assert (dom.dom, dom.cod) == (cod.dom, cod.cod)
        self.inside, self.dom, self.cod = inside, dom, cod

    @staticmethod
    def id(F: Functor):
        return Transformation(lambda x: F.cod.ar.id(x), dom=F, cod=F)

    def then(self, other: Transformation) -> Transformation:
        assert self.cod == other.dom
        return Transformation(lambda x: other(self(x)), self.dom, other.cod)

    def tensor(self, other: Transformation | Functor) -> Transformation:
        if isinstance(other, Transformation): return self @ other.dom >> self.cod @ other
        return Transformation(
            lambda x: other(self(x)), self.dom >> other, self.cod >> other)

    def __rmatmul__(self, other: Functor) -> Transformation:
        return Transformation(
            lambda x: self(other(x)), other >> self.dom, other >> self.cod)

    def __call__(self, other: Ty):
        inside, dom, cod = self.inside(other), self.dom(other), self.cod(other)
        return inside if isinstance(inside, self.cod.ar)\
            else self.cod.ar(inside, dom, cod)

Cat = TwoCategory(colours=Category, ob=Functor, ar=Transformation)
\end{minted}
\end{python}

\begin{example}
We can interpret colours as categories, types as functors and diagrams as transformations.

\begin{minted}{python}
a = Colour('a')
x = Ty('x', dom=a, cod=a)
f, g = Box('f', Ty.id(a), x), Box('g', x @ x, x)

Pyth = Category(tuple[type, ...], Function)
List = Functor(
    ob=lambda xs: [list[xs]], ar=lambda f: lambda xs: map(f, xs), dom=Pyth, cod=Pyth)
Unit = Transformation(lambda _: lambda x: [x], dom=Functor.id(Pyth), cod=List)
Mult = Transformation(lambda _: lambda xs: sum(xs, []), dom=List >> List, cod=List)

F = TwoFunctor(colours={a: Pyth}, ob={x: List}, ar: {f: Unit, g: Mult}, cod=Cat)
assert F(f)(int)(42) == [42] and F(g)(int)([[1], [2], [3]]) == [1, 2, 3]
assert F(f @ x >> g)(int)([1, 2, 3]) == [1, 2, 3]
\end{minted}
\end{example}

We have already discussed another way to construct a 2-categories: taking types as 0-cells, diagrams as 1-cells and rewrites as 2-cells, in fact this gives a \emph{premonoidal sesquicategory}.
A monoidal 2-signature $\Sigma$ is a 2-signature where the objects in $\Sigma_1$ have lists of colours $\Sigma_0^\star$ as domain and codomain and the boxes in $\Sigma_2$ have domain and codomain in the free premonoidal category $F^P(\Sigma_0, \Sigma_1)$.
Thus, a box $r : f \to g$ in a monoidal 2-signature may be seen as a rewrite rule with parallel diagrams $f : x \to y$ and $g : x \to y$ as domain and codomain.
It generates a free premonoidal sesquicategory with types $\Sigma_0^\star$ as 0-cells, diagrams $F^P(\Sigma_0, \Sigma_1)$ as 1-cells and rewrites as 2-cells.
We can construct it explicitly by generalising layers to \emph{slices} with not only types on the left and right but also diagrams on the top and bottom, i.e. a rewrite rule together with a match.
\py{Rule} is a subclass of \py{Box} with diagrams as domain and codomain, \py{Slice} is a box made of a rule inside a match with methods for left and right whiskering as well as pre- and post-composition.
\py{Rewrite} is a subclass of \py{Diagram} with \py{Slice} as layers, it inherits its vertical composition (i.e. two rewrites applied in sequence) from the diagram class as well as its tensor product (i.e. two rewrites applied in parallel on the tensor of two diagrams).
The horizontal composition (i.e. two rewrites applied in parallel on the composition of two diagrams) is given by an optional argument to \py{then} which temporarily replaces left and right whiskering by pre- and post-composition before calling \py{Diagram.tensor}.

\begin{python}\label{listing:free-monoidal-2-category}
{\normalfont Outline of the implementation of free premonoidal sesquicategories.}

\begin{minted}{python}
class Rule(Box):
    def __init__(self, name: str, dom: Diagram, cod: Diagram):
        super().__init__(name, dom, cod)

class Slice(Box):
    def __init__(self, rule: Rule, match: Match):
        dom, cod = match.subs(rule.dom), matchs.subs(rule.cod)
        super().__init__("Slice({}, {})".format(rule, match), dom, cod)

    __matmul__ = lambda self, other: Slice(self.rule, self.match @ other)
    __rmatmul__ = lambda self, other: Slice(self.rule, other @ self.match)
    __lshift__ = __rrshift__ = lambda self, other: Slice(self.rule, self.match >> other)
    __rshift__ = __rlshift__ = lambda self, other: Slice(self.rule, other >> self.match)

Match.__matmul__ = lambda self, other: Match(
    self.top @ other.dom, self.bottom @ other, self.left, self.right @ other.dom)
Match.__rmatmul__ = lambda self, other: Match(
    other @ self.top, other.cod @ self.bottom, other.cod @ self.left, self.right)
Match.__lshift__ = Match.__rrshift__ = lambda self, other: Match(
    self.top, self.bottom >> other, self.left, self.right)
Match.__rshift__ = Match.__rlshift__ = lambda self, other: Match(
    other >> self.top, self.bottom, self.left, self.right)

class Rewrite(Diagram):
    def __init__(self, slices: tuple[Slice, ...], dom: Ty | Diagram, cod: Ty | Diagram):
        dom, cod = (x if isinstance(x, Diagram) else Diagram.id(x) for x in (dom, cod))
        super().__init__(slices, dom, cod)

    def then(self, other, horizontal=False):
        if not horizontal: return super().then(other)
        tmp = Slice.__matmul__, Slice.__rmatmul__
        Slice.__matmul__, Slice.__rmatmul__ = Slice.__lshift__, Slice.__rshift__
        result = super().tensor(other)
        Slice.__matmul__, Slice.__rmatmul__ = tmp
        return result
\end{minted}
\end{python}

Note that when the monoidal 2-signature $\Sigma$ is in fact a simple 2-signature, i.e. every box $f \in \Sigma_1$ has domain and codomain of length one, the definition of a rewrite coincides with the definition of coloured diagram.
Indeed we can relabel everything one level down: the types are colours, the boxes are types and the rules are boxes: a coloured diagram can be seen as a rewrite of one dimensional diagrams, i.e. lists of types with composable colours.
Symmetrically, rewriting an 2-dimensional diagram can itself be seen as a 3-dimensional diagram.
If we compose the two constructions (colours and rewrites) together, we get the free 3-sesquicategory with rewrites of coloured diagrams as 3-cells.
We can keep on going with \emph{modifications} of rewrites, i.e. 4-dimensional diagrams, by generalising layers one step further with not only a pair of types (left and right) and a pair of diagrams (top and bottom) but also a pair of rewrites (before and after).
What could be the use of a such four-dimensional diagram?
For example, a free 4-category with a single 0-, 1- and 2-cell is the same as a free symmetric category (once we relabel everything three levels down).
Indeed, the swaps are given by the interchange law and the 4d space in which the diagrams live allows wires to cross and every knot to be untied: every diagram interpreted in $\mathbf{Pyth}$ or $\mathbf{Mat}_\S$ is secretly four-dimensional.
One dimension lower, a free 3-category with a single 0- and 1-cell is the same as a free braided category, this is only the tip of the \emph{periodic table} of k-tuply monoidal n-categories~\cite[Section~2.5]{BaezStay09}.

The proof assistant Globular~\cite{BarEtAl18} allows to construct 4-dimensional diagrams using a graphical interface for drawing slices and projections in two dimensions.
In fact, the drawing algorithm presented in section~\ref{section:drawing} was reverse engineered from that of Globular.
Its successor homotopy.io~\cite{ReutterVicary19} went from four to arbitrary dimensions based on a data structure for diagrams in free n-sesquicategories~\cite{BarVicary17}.
Interfacing DisCoPy with homotopy.io is in the backlog of features yet to be implemented, so that the user can define diagrams by drag-and-dropping boxes then interpret them in arbitrary n-categories.
One of the new feature of homotopy.io compared to its predecessor is the possibility of drawing non-generic diagrams, i.e. with more than one box on the same layer.
This amounts to taking the free category over $L^+(\Sigma) = (\Sigma_0 + \Sigma_1)^\star \simeq \Sigma_0^\star \Box \Sigma_1^\star$ rather than $L(\Sigma) = \Sigma_0^\star \times \Sigma_1 \times \Sigma_0^\star$.
This is also in DisCoPy's backlog, implementing the syntax is straightforward but then it requires to extend the algorithms for functors, drawing, normal forms, etc.

Layers with arbitrarily many boxes also allow to define the \emph{depth} of an arrow in any quotient of a free premonoidal category as the minimum number of layers in its equivalence class of diagrams.
As we mentioned in section~\ref{subsection:quotient-monoidal}, premonoidal diagrams also have a well-defined notion of \emph{width} (the maximum number of parallel wires) which we can extend in the same way to define the width of any quotient.
This makes diagrams a foundational data structure for computational complexity theory: a signature can be seen as both a machine and a language, a diagram as both code and data.
In the other direction, this also allows to borrow results from complexity theory to characterise the computational resources required in solving problems about diagrams.
This will be needed in the next chapter when we will look at NLP problems through the lens of diagrams.
