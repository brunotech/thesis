%!TEX root = ../../THESIS.tex

\subsection{Cartesian closed categories}

With hypergraph diagrams, we have enough syntax to discuss quantum protocols and first-order logic.
However, the spiders of hypergraph categories are of no use if we want to interpret our diagrams as (pure) Python functions with \py{tuple} as tensor.
Indeed, $\mathbf{Pyth}$ has the property that every function $f : x \to y \otimes z$ into a composite system $y \otimes z$ is in fact a tensor product $f = f_0 \otimes f_1$ of two separate functions $f_0 : x \to y$ and $f_1 : x \to z$.
If a Python type $x$ had caps (let alone spiders) then we could break them in two with the consequence that the identity function on $x$ is constant, i.e. $x$ is trivial~\cite[?]{CoeckeKissinger17}.
Moreover, there is only one (pure) effect of every type, discarding it.
Thus if a Python type $x$ had cups then we could break them apart as well with the same consequence: only the trivial Python type can have spiders.
A similar argument destroys our hopes for time reversal in Python: if we had a monoidal dagger on $\mathbf{Pyth}$, every state would be equal to every other.

Now if we go back to the intuition of diagrams as pipelines and their wires as carrying data, not all might be lost about spiders.
Indeed, it makes sense to split a data-carrying wire: it means we are copying information.
Closing a data-carrying wire is the counit of the copying comonoid, it means we are deleting information.
In this context, the special condition would translate as follows: if we copy some data then merge the two copies back together, then we haven't done anything.
In order for the spider fusion equations to hold, we would need the monoid to take any two inputs and assert that they are equal or abort the computation otherwise, i.e. we would need side effects.
Even more weirdly, we would need the unit of the monoid to be equal to anything else.

Rather than complaining that classical computing is weird because we cannot coherently merge data back together, we should embrace this as a feature, not a bug: in Python we can copy and discard data (at least assuming that we have enough RAM and that the garbage collector is doing its job).
This means we can still keep the comonoid half of our spiders, forget that they are spiders and come to realise that they are in fact \emph{natural comonoids}.
Indeed, the functions \py{copy = lambda *xs: xs + xs} and \py{delete = lambda *xs: ()} define a pair of natural transformations $x \to x \otimes x$ and $x \to 1$ in $\mathbf{Pyth}$:
\begin{itemize}
    \item \py{copy(f(xs)) == f(copy(xs)[:n]), f(copy(xs)[n:])}
    \item \py{delete(f(xs)) == delete(xs)}
\end{itemize}
for all pure functions \py{f} and inputs \py{xs} with \py{n = len(xs)}.

A \emph{cartesian category} is a symmetric category with coherent, natural commutative comonoids.
The category $\mathbf{Pyth}$ is an example of cartesian category, as well as the categories $\mathbf{Set}$, $\mathbf{Mon}$, $\mathbf{Cat}$, $\mathbf{MonCat}$, etc.
The category $\mathbf{Mat}_\S$ is also a cartesian category with the direct sum as tensor.
Our definition of cartesian is convenient if we want to draw diagrams and interpret them as functions but it is rather cumbersome: checking that a given category fits the definition involves a lot of structure (tensor, swaps and comonoids) and many axioms relating them.
In practice, we usually take an equivalent definition: a category $C$ is cartesian if it has \emph{categorical products} and a \emph{terminal object}.
An object $1 \in C_0$ is terminal if there is a unique arrow $\counit(x) : x \to 1$ from each object $C_0$.
An object $x_0 \times x_1 \in C_0$ is the product of two objects $x_0, x_1 \in C_0$ if it comes equipped with a pair of arrows $\pi_0 : x_0 \times x_1 \to x_0$ and $\pi_1 : x_0 \times x_1 \to x_1$
such that for all pairs of arrows $f_0 : y \to x_0$ and $f_1 : y \to x_1$ there is a unique $f = \langle f_0, f_1 \rangle : y \to x_0 \times x_1$ such that $f \fcmp \pi_0 = f_0$ and $f \fcmp \pi_1 = f_1$.
These two properties are usually drawn as the following commutative diagrams where the full lines are universally quantified and the dotted line is uniquely existentially quantified.

TODO DRAW

From these two \emph{universal properties} we can deduce that terminal objects and categorical products are unique up to a unique isomorphism and that they form a monoid on objects $(C_0, \times, 1)$, up to natural isomorphism.
Given two arrows $f : a \to b$ and $g : c \to d$ we have two arrows $\pi_0 \fcmp f : a \times c \to b$ and $\pi_1 \fcmp g : a \times c \to d$, thus there is a unique $f \times  g = \langle \pi_0 \fcmp f, \pi_1 \fcmp g \rangle : a \times b \to c \times d$.
One can show that this makes the category $C$ a monoidal category, i.e. $(C_1, \times, \id(1))$ is a monoid and the interchange law holds.
Furthermore, we can show $C$ is symmetric with the swaps given by $S(x, y) = \langle \pi_1, \pi_0 \rangle : x \times y \to y \times x$.
Finally, we can show $C$ has coherent natural commutative comonoids given by $\ttsplit(x) = \langle \id(x), \id(x) \rangle : x \to x \times x$ and $\counit(x) : x \to 1$.

In the other direction, if $C$ has coherent natural commutative comonoids we can deduce that $1$ a terminal object from the naturality of the counit.
For any arrows $f_0 : y \to x_0$ and $f_1 : y \to x_1$ we can define
\begin{itemize}
\item $\langle f_0, f_1 \rangle = \ttsplit(y) \fcmp f_0 \otimes f_1$,
\item $\pi_0 = \id(x_0) \otimes \counit(x_1)$ and $\pi_1 = \counit(x_0) \otimes \id(x_1)$,
\end{itemize}
and show that $\otimes = \times$ is in fact a categorical product, see Selinger's survey~\cite[Section 6.1]{Selinger10}.
A functor is cartesian when it preserves the categorical product, or equivalently if it is a symmetric functor that preserves the comonoid.
This defines a category $\mathbf{CCat}$ of cartesian categories and functors.
From lemma~\ref{lemma:foo-monoidal} we can assume that cartesian categories are free-on-objects, i.e. the monoid axioms for objects are equalities rather than natural transformations.
Thus, we get a forgetful functor $U : \mathbf{CCat} \to \mathbf{MonSig}$ with its left-adjoint given by a quotient of the free symmetric category $F^C(\Sigma) = F^S(\Sigma \cup \ttsplit \cup \counit) / R$ with the relations $R$ given by the naturality equations for each box.

A cartesian category that is also a PROP is called a \emph{Lawvere theory}~\cite{Lawvere63}, they were first introduced as a high-level language for \emph{universal algebra}. take the boxes $x^n \to x$ to be the primitive $n$-ary operations of your language (e.g. for rigs we have unary boxes for $0$ and $1$, binary boxes for $+$ and $\times$) then the diagrams in the free Lawvere theory are all the terms of your language.
We can write down any universally quantified axiom as a relation between diagrams and the cartesian functors from the resulting quotient to $\mathbf{Set}$ are \emph{algebras}, i.e. sets equipped with operations that satisfy the axioms.
The natural transformations between models are precisely the homomorphisms between the algebras, i.e. the functions that commute with the operations.
If we add colours back in and allow many generating objects, we can define many-sorted theories such as that of modules, with a ring acting on a group.
If we take every pair of objects $(x, y) \in C_0 \times C_0$ as colour and a box $(x, y) \otimes (y, z) \to (x, z)$ for every possible composition, then we can even define the Lawvere theory of categories with $C_0$ as objects.
Thus, categories (with some fixed objects) can also be seen as the functors from this Lawvere theory to $\mathbf{Set}$, functors can also be seen as the natural transformations between such functors.

The free Lawvere theory with no boxes (only swaps, coproducts and counits) is equivalent to $\mathbf{FinSet}^{op}$, the opposite category to finite sets and functions, with the disjoint union as tensor.
Indeed, a cartesian diagram $f : x^n \to x^m$ can be seen as the graph of a function from the $m$ to $n$ elements.
This free Lawvere theory is also called the \emph{theory of equality}, a functor from it to $\mathbf{Set}$ (i.e. an algebra for the theory) is just a set with its equality relation, a natural transformation between those functors is just a function.
Thus, equality of cartesian diagrams with no boxes reduces to equality of functions between finite sets, which can be implemented as equality of finite dictionaries in Python.
It is easy to show that the rules for naturality are confluent and terminating when applied from left to right, i.e. we copy (delete) every box by passing it down through all possible coproducts (counits).
At each rewrite step there is one fewer box node above a comonoid node, thus we can reduce the word problem for free cartesian categories to that of free symmetric categories and then to graph isomorphism.

Taking the opposite definition, a \emph{cocartesian category} is one with a categorical coproduct, or equivalently with a coherent natural commutative monoid.
For example, the category $\mathbf{Set}$ is cocartesian with the disjoint union, the category $\mathbf{Pyth}$ is cocartesian with the tagged union: the merging function takes a tagged element of an n-fold disjoint union and forgets the tag.
While cartesian structures can be thought of in terms of product types and data copying, cocartesian structures formalise tagged unions and conditional branching.
Indeed, when we interpret cocartesian diagrams in $\mathbf{Pyth}$ parallel wires encode the different branches of a program, merging two wires of the same type means forgetting the difference between two branches.

A category with distinct cartesian and cocartesian structures is an example of a \emph{rig category}, i.e. it has two monoidal structures $\oplus$ and $\otimes$ that satisfy the equations of a rig up to natural isomorphism.
This is the case for the category $\mathbf{Set}$ as well as for $\mathbf{Pyth}$.
The Kronecker product is not a cartesian product for $\mathbf{Mat}_\S$ (because this role is taken by direct sums) but it does form a rig category with the direct sum.
The arrows of free rig categories can be described as (equivalence classes of) three-dimensional \emph{sheet diagrams} where composition, additive and multiplicative tensor are encoded in three orthogonal axes~\cite{ComfortEtAl20}.
These 3d diagrams are a complete language for \emph{dataflow programming}~\cite{Delpeuch20a}, they are not implemented in DisCoPy yet.

DisCoPy implements free (co)cartesian categories with a subclass of \py{Box} for making (merging) \py{n} copies of a type \py{x} of length one.
The class method \py{Diagram.copy} allows to make \py{n} copies of an arbitrary type \py{x} by calling the \py{coherence} subroutine of the previous section, it takes an optional argument \py{is_dagger} that allows to merge copies instead.
Cartesian functors take \py{Copy} boxes of its domain to the \py{copy} method of its codomain.

\begin{python}
{\normalfont Implementation of free (co)cartesian categories and functors.}

\begin{minted}{python}
class Diagram(symmetric.Diagram):
    @classmethod
    def copy(cls, x: Ty, n: int, is_dagger=False):
        def factory(a, b, y):
            assert b == 1 if is_dagger else a == 1
            return Copy(a, y)[::-1] if is_dagger else Copy(b, x)
        a, b = (n, 1) if is_dagger else (1, n)
        return coherence(factory)(cls, a, b, x)

class Box(symmetric.Box, Diagram):
    upgrade = Diagram.upgrade

class Copy(Box):
    def __init__(self, x: Ty, n: int, is_dagger=False):
        assert len(x) == 1
        name = "Copy({}, {}){}".format(x, n, "[::-1]" if is_dagger else "")
        dom, cod = (x ** n, x) if is_dagger else (x, x ** n)
        super().__init__(name, dom, cod, is_dagger)

    def dagger(self):
        x = self.cod if self.is_dagger else self.dom
        n = len(self.dom) if self.is_dagger else len(self.cod)
        return Copy(x, n, not self.is_dagger)

class Functor(symmetric.Functor):
    dom = cod = Category(monoidal.Ty, Diagram)

    def __call__(self, other):
        if isinstance(other, Copy):
            return self.cod.ar.copy(self(other.dom), len(other.cod), other.is_dagger)
        return super().__call__(other)
\end{minted}
\end{python}

Example: $\mathbf{FinSet}^{op}$

Example: $\mathbf{NeuralNet}$


The implementation of $\mathbf{Pyth}$ as a cartesian category with \py{tuple} and a cocartesian category with \py{tagged_union} is straightforward.
What is more challenging is to make both monoidal structures fit in the same class, i.e. implementing a rig category.
Indeed, if we take $(\mathbf{Pyth}, \py{tuple})$ as the foo-monoidal category implemented in section~\ref{section:monoidal}, \py{dom: list[type]} and \py{cod: list[type]} are interpreted as a \py{tuple}.
On the other hand, if we implement $(\mathbf{Pyth}, \py{tagged_union})$ as a foo-monoidal category, lists of types will be interpreted as a \py{TaggedUnion} instead.
Hence, we need to add an optional argument \py{is_additive: bool} which tells us how we should interpret \py{dom} and \py{cod}, and a pair of methods for converting additive into multiplicative functions.
In order to keep the syntax simple, we keep the notation \py{f @ g} for \py{tuple} and override the vertical line symbol \py{f | g} to denote the \py{tagged_union}.
We use the same syntax for the direct sum of two tensors, as well as for the free bicompletion.

\begin{python}
{\normalfont Implementation of $\mathbf{Pyth}$ as a cartesian category with \py{tuple} and a cocartesian category with \py{tagged_union}.}

\begin{minted}{python}
is_tuple = lambda typ: hasattr(typ, "__origin__") and typ.__origin__ is tuple
is_union = lambda typ: hasattr(typ, "__origin__") and typ.__origin__ is TaggedUnion

class Function(monoidal.Function):
    is_additive = False

    @classmethod
    @property
    def additive(cls):
        class C(cls): pass
        C.is_additive = True; return C

    def __repr__(self): super().__repr__().replace(
        "Function", "Function.additive" if self.is_additive else "Function")

    def make_additive(self) -> Function:
        if self.is_additive: return self
        dom, cod = (
            [tuple[types]] if len(types) != 1
            else list(types[0].__args__) if is_union(types[0])
            else types for types in (self.dom, self.cod))
        return Function.additive(self.inside, dom, cod)

    def make_multiplicative(self) -> Function:
        if not self.is_additive: return self
        dom, cod = (
            [TaggedUnion[types]] if len(types) != 1
            else list(types[0].__args__) if is_tuple(types[0])
            else types for types in (self.dom, self.cod))
        return Function(self.inside, dom, cod)

    def tuple(self, other: Function) -> Function:
        if self.is_additive: return self.make_multiplicative().tuple(other)
        if other.is_additive: return self.tuple(other.make_multiplicative())
        return super().tuple(other)

    def tagged_union(self, other: Function) -> Function:
        if not self.is_additive: return self.make_additive().tagged_union(other)
        if not other.is_additive: return self.tagged_union(other.make_additive())
        dom, cod = self.dom + other.dom, self.cod + other.cod
        inside = self.inside if len(self.dom) == 1 and len(other.dom) == 0\
            else other.inside if len(self.dom) == 0 and len(other.dom) == 1\
            else lambda i, x: self(i, x) if i < len(self.dom) else other(i - len(self.dom), x)
        return Function(inside, dom, cod)

    @staticmethod
    def copy(x: list[type], n: int, is_dagger=False):
        if n == 1: return Function.additive.id(x) if is_dagger else Function.id(x)
        dom, cod = (x ** n, x) if is_dagger else (x, x ** n)
        inside = (lambda _, x: x) if is_dagger else (lambda *xs: return n * xs)
        return (Function.additive if is_dagger else Function)(inside, dom, cod)

    def tensor(self, other: Function) -> Function:
        return self.tagged_union(other) if self.is_additive else self.tuple(other)

    __or__ = tagged_union
\end{minted}
\end{python}

\begin{example}
We can check the axioms for cartesian and cocartesian categories hold in $\mathbf{Pyth}$.

TODO
\end{example}

\begin{python}
{\normalfont Implementation of $\mathbf{Tensor}_\S$ as a rig category with direct sum and Kronecker product.}

\begin{minted}{python}
class Tensor:
    ...
    def direct_sum(self, other: Tensor | Matrix) -> Tensor:
        if not isinstance(other, Matrix): return self.direct_sum(other.downgrade())
        dom, cod = [product(self.dom) + other.dom], [product(self.cod) + other.cod]
        inside = self.downgrade().direct_sum(other).inside
        return type(self)(inside, dom, cod)

    __or__ = direct_sum
\end{minted}
\end{python}

\begin{example}
We can check the axioms for rig-categories hold in $\mathbf{Tensor}_\S$.

TODO
\end{example}

A category has \emph{biproducts} if the cartesian and cocartesian structures coincide,
a $\dagger$-category has \emph{$\dagger$-biproducts} when furthermore the monoid is the dagger of the comonoid.
This is the case in the $\dagger$-category $\mathbf{Mat}_\S$ with direct sum $\oplus$ as tensor.
In fact, biproducts and matrices are intimately related.
Indeed, given any category $C$ with sums we can construct its \emph{free biproduct completion} $\mathbf{Mat}_C$ as the monoidal category with objects given by $C_0^\star$ and arrows $f : x \to y$ given by matrices $f_{ij} : x_i \to y_j$ of arrows in $C_1$.
Composition in $\mathbf{Mat}_C$ is an extension of the usual matrix multiplication with composition as product.
In particular, if $C = \S$ is a rig, i.e. a one-object category with sums, then this definition coincides with the usual one.
Any category with biproducts also has sums $f + g : x \to y$ given by $\ttsplit(x) \fcmp f \oplus g \fcmp \merge(x)$ and a zero morphism $0 = \counit(x) \fcmp \unit(y)$.
One can verify that the free completion is indeed the left-adjoint to the forgetful functor from biproducts to sums, see~\cite[Exercise VIII.2.6]{MacLane71}.
Similarly, if $C$ is a $\dagger$-category then $\mathbf{Mat}_C$ is its a free $\dagger$-biproduct completion.
If $C$ is also a monoidal category, then $\mathbf{Mat}_C$ is a rig category with the tensor given by an extension of the usual Kronecker product with tensor as product.

\begin{python}
{\normalfont Implementation of $\dagger$-biproducts for $\mathbf{Mat}_\S$.}

\begin{minted}{python}
class Matrix:
    ...
    @classmethod
    def copy(cls, x: int, n: int, is_dagger=False):
        dom, cod = (x ** n, x ** 1) if is_dagger else (x ** 1, x ** n)
        inside = [[i % n == j for j in range(x)] for i in range(x ** n)] if is_dagger\
            else [[i == j % n for j in range(x ** n)] for i in range(x)]]
        return cls(inside, dom, cod)
\end{minted}
\end{python}

\begin{example}
We can check the axioms for $\dagger$-biproducts hold in $\mathbf{Mat}_\S$.

TODO
\end{example}

\begin{python}
{\normalfont Implementation of free $\dagger$-biproduct completion as a subclass of \py{Matrix[Diagram]} with \py{list[Ty]} as objects.}

\begin{minted}{python}
@dataclass
class FakeInt:
    inside: list[Ty]
    __mul__ = lambda self, other: [x0 @ x1 for x0 in self.inside for x1 in other]
    __pow__ = lambda self, n: n * self.inside
    __len__ = lambda self: len(self.inside)
    __iter__ = property(lambda self: self.inside.__iter__)

class Biproduct(Matrix):
    dtype = Diagram

    @classmethod
    def upgrade(cls, old: Diagram):
        if isinstance(old, cls): return old
        return cls([[old]], [old.dom], [old.cod])

    def __init__(self, inside: list[list[Diagram]], dom: list[Ty], cod: list[Ty]):
        inside = [[
            cls.dtype.id(x) if val is 1 and x == y
            else cls.dtype.zero(x, y) if val is 0
            else val for y, val in zip(cod, row)] for x, row in zip(dom, inside)]
        super().__init__(inside, dom, cod)

    def then(self, other: Biproduct | Diagram) -> Biproduct:
        self.dtype.__mul__ = self.dtype.then
        result = Matrix.then(self, self.upgrade(other))
        del self.dtype.__mul__; return result

    def tensor(self, other: Biproduct | Diagram) -> Biproduct:
        self.dtype.__mul__ = self.dtype.tensor
        fake_self = type(self)(self.inside, FakeInt(self.dom), FakeInt(self.cod))
        result = Matrix.Kronecker(fake_self, self.upgrade(other))
        del self.dtype.__mul__; return result

    @classmethod
    def copy(cls, x: int, n: int, is_dagger=False):
        old = Matrix.copy(FakeInt(x), n, is_dagger)
        return cls(old.inside, old.dom, old.cod)

    dagger = lambda self: self.transpose().map(lambda f: f.dagger())

Diagram.biproduct = Biproduct
Diagram.__or__ = lambda self, other:\
    Biproduct.upgrade(self).direct_sum(Biproduct.upgrade(other))
\end{minted}
\end{python}


Pointless style and diagrammize


Cartesian monoid implies bialgebra, bialgebra and Frobenius imply trivial

$\mathbf{Pyth}$ cannot be be rigid but it does share a common structure with rigid categories: both are \emph{biclosed categories}...

A category is \emph{cartesian closed} when it is both cartesian and biclosed.

Listing: \py{closed}

Listing: closed structure on \py{rigid.Diagram}

Listing: $\mathbf{Pyth}$ as a cartesian closed category

Example: preordered monoids that are also biclosed categories, categorial grammars and Montague semantics, see section~\ref{section:NLP}.
