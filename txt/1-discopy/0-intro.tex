%!TEX root = ../../THESIS.tex

\chapter{DisCoPy: Python for the applied category theorist}\label{chapter:discopy}

Python has become the programming language of choice for most applications in both natural language processing (e.g. Stanford NLP~\cite{ManningEtAl14}, NLTK~\cite{LoperBird02} and SpaCy~\cite{HonnibalMontani17}) and quantum computing (with development kits like Qiskit~\cite{Cross18} and PennyLane~\cite{BergholmEtAl20} and interfaces to compilers like pytket~\cite{SivarajahEtAl20}).
Thus, it was the obvious choice of language for an implementation of QNLP.
However, unlike functional programming languages like Haskell, Python has little support for category theory.
Indeed, before the release of DisCoPy, the only existing Python framework for category theory was a module of SymPy~\cite{MeurerEtAl17} that can draw commutative diagrams in finite categories.
Hence, the first step in implementing QNLP was to develop our own framework for applied category theory in Python: DisCoPy.
Its main feature are the drawing of string diagrams (e.g. the grammatical structure of sentences) and the application of functors (e.g. to quantum circuits, either executed on quantum hardware or classically simulated).

String diagrams have become the lingua franca of applied category theory.
However, the definitions one can find in the literature usually fall into one of two extremes: either definitions by general abstract nonsense or definitions by example and appeal to intuition.
On one side of the spectrum, the standard technical reference has become the \emph{Geometry of tensor calculus}~\cite{JoyalStreet91} where Joyal and Street define string diagrams as equivalence classes of labeled topological graphs embedded in the plane and then characterise them as the arrows of free monoidal categories.
On the other, \emph{Picturing quantum processes}~\cite{CoeckeKissinger17} contains over a thousand string diagrams but their formal definition as well as any mention of category theory are relegated to mere appendices.

The aims of this chapter are three-fold: 1) it gives an overview of the DisCoPy package and its design principles, 2) it introduces elementary category theory to the Python programmer and 3) it introduces object-oriented programming to the applied category theorist.
The first section introduces categories and functors with no mathematical prerequisites apart from sets and monoids.
The second section introduces monoidal categories, defining string diagrams from first principles.
The third section defines the drawing and reading algorithms for string diagrams, which arise as the two sides of the equivalence between the premonoidal and the topological definitions.
The fourth section introduces monoidal categories with extra structure and the inheritence mechanism which implements this hierarchy of structure.
The fifth section gives the category theoretic foundations for our definition of diagrams, which we call the premonoidal approach, it discusses the relationship between this approach and the exisiting graph-based data structures for diagrams in symmetric monoidal categories.

Note that the code presented in this thesis represents a significant refactoring of the original implementation of DisCoPy as available online at the time this thesis is submitted\footnote
{\url{https://github.com/oxford-quantum-group/discopy}}.
We list some of the significant changes between the two versions.
\begin{itemize}
\item We add type annotations throughout the codebase, using the postponed evaluation of annotations introduced in Python \py{3.7}~\cite{Langa17}.
\item We simplify the inheritance mechanism using Python's \py{classmethod} decorator.
This improves the code reuse for composition of diagrams, application of functors, etc.
\item We reorganise the codebase so that it follows more closely the hierarchy of categorical structures.
For example, we move the code for \py{Braid} outside of the \py{monoidal} module into its own \py{braided} module, we also introduce e.g. the \py{tortile} module which imports from both \py{rigid} and \py{braided}.
\item We make the syntax more uniform for arrows in different categories, which are all initialised with the same attributes \py{inside}, \py{dom} and \py{cod}.
\item We implement whiskering, i.e. tensoring arrows with the identity on a given object on the left and right. This avoids cluttering diagram definitions with \py{Id}.
\item Arrows in concrete categories like \py{Matrix}, \py{Tensor} and \py{Function} are no longer subclasses of \py{Box}. Instead, we implement the syntactic sugar for composition, whiskering, etc. with abstract classes \py{Composable} and \py{Tensorable}.
\item We make the \py{Matrix} and \py{Tensor} classes parameterised by the datatype of their entries.
This makes use of the magic method \py{__class_getitem__} which appeared in Python \py{3.10}~\cite{Levkivskyi17}.
\end{itemize}
