%!TEX root = ../../THESIS.tex

\subsection{Braided categories \& wire crossing} \label{subsection:symmetric}

With rigid and pivotal categories, we have removed the assumption that diagrams are progressive: we can bend wires.
With braided and symmetric monoidal categories, we now remove the planarity assumption: wires can cross.

A monoidal category $C$ is \emph{braided} when it comes with a natural isomorphism $B(x, y) : x \otimes y \to y \otimes x$ subject to the following \emph{hexagon equations}:
\begin{itemize}
\item $B(x, y \otimes z) = B(x,y) \otimes z \s \fcmp \s y \otimes B(x,z)$
\item $B(x \otimes y, z) = x \otimes B(y,z) \s \fcmp \s B(x,z) \otimes y$
\end{itemize}
which owe their name to the shape of the corresponding commutative diagrams when $C$ is non-strict monoidal.
The box for the braiding $B(x, y)$ (its inverse $B^{-1}(x, y)$) is drawn as a wire for $x$ crossing under (over) a wire $y$.
We can draw the hexagon equations as non-free-on-objects diagrams, i.e. with explicit equality boxes:
\begin{center}
\tikzfig{img/symmetric/hexagon-left}\\
\vspace{10pt}
and \hspace{10pt} \tikzfig{img/symmetric/hexagon-right}
\end{center}
This can be taken as an inductive definition: the braiding $B(x,1)$ of an object with the unit $1$ is the identity, and we can decompose the braiding $B(x, y \otimes z)$ of an object with a tensor in terms of two simpler braids $B(x,y)$ and $B(x,z)$.
Thus, we can take the data for a braided category to be that of a foo-monoidal category together with a pair of functions $B, B^{-1} : C_0 \times C_0 \to C_1$ which send a pair of generating objects to their braiding and its inverse.
Once we have specified the braids of generating objects, the braids of any type (i.e. list of objects) is uniquely determined.
A monoidal functor $F : C \to D$ between two braided categories $C$ and $D$ is braided when $F(B(x, y)) = B(F(x), F(y))$, thus we get a category $\mathbf{BraidCat}$.

A braided category $C$ is \emph{symmetric} if the braiding $B$ is its own inverse $B = B^{-1} = S$, in this case it is called a \emph{swap}.
A symmetric functor is a braided functor between symmetric categories, thus we get a category $\mathbf{SymCat}$, with a forgetful functor $U : \mathbf{SymCat} \to \mathbf{MonSig}$.
We now describe its left adjoint.
Given a monoidal signature $\Sigma$, the free symmetric category is a quotient $F^s(\Sigma) = F(\Sigma \cup \{ S(x, y) \}_{x, y \in \Sigma_0}) / R$ of the free monoidal category generated by $\Sigma$ and the swaps $S$ for each pair of generating objects $x, y \in \Sigma_0$.
The relation $R$ is given by the following axioms for a self-inverse natural transformation:
\begin{itemize}
\item $S(x, y) \fcmp S(y, x) \s = \s \id(x \otimes y)$,
\item $f \otimes x \ \fcmp \ S(b, x) \s = \s S(a, x) \ \fcmp \ x \otimes f$,
\item $x \otimes f \ \fcmp \ S(x, b) \s = \s S(x, a) \ \fcmp \ f \otimes x$,
\end{itemize}
for all generating objects $x, y \in \Sigma_0$ and boxes (including swaps) $f : a \to b$ in $\Sigma_1 \cup \{ S(x, y) \}_{x, y \in \Sigma_0}$.
From $S$ being self-inverse on generating objects, we can prove it is self-inverse on any type by induction.
Similarly, from $S$ being natural on the left and right for each box, we can prove by induction that it is in fact natural for any diagram.
Drawing the box $S$ as a swap, i.e. two wires intersecting, we get the following diagrammatic equations:
\ctikzfig{img/symmetric/self-inverse}
\begin{center}
\tikzfig{img/symmetric/naturality-left}
\hspace{100pt}
\tikzfig{img/symmetric/naturality-right}
\end{center}
Note that the naturality axiom holds for boxes with domains and codomains of arbitrary length.
In particular, it holds for $f = S(y, z)$ in which case we get the following Yang-Baxter equation:
\ctikzfig{img/symmetric/yang-baxter}
It also holds for any scalar $f : 1 \to 1$, which allows to pass them through a wire:
\ctikzfig{img/symmetric/naturality-scalars}
A $\dagger$-braided category is a braided category with a dagger structure, such that the braidings are unitaries, i.e. their inverse is also their dagger.
A $\dagger$-symmetric category is a $\dagger$-braided category that is also symmetric.
DisCoPy implements free $\dagger$-symmetric ($\dagger$-braided) categories with a class \py{Swap} (\py{Braid}) initialised by types of length one and a class method \py{Diagram.swap} (\py{Diagram.braid}) for types of arbitrary length.

\begin{python}
{\normalfont Implementation of free $\dagger$-braided and $\dagger$-symmetric categories.}

\begin{minted}{python}
class Braid(monoidal.Box):
    def __init__(self, x: Ty, y: Ty, is_dagger=False):
        assert len(x) == len(y) == 1
        super().__init__("Braid({}, {})".format(x, y), x @ y, y @ x, is_dagger)

    def dagger(self): return Braid(self.dom[1], self.dom[0], not self.is_dagger)

class Swap(Braid):
    def __init__(self, x: Ty, y: Ty):
        super().__init__(x, y); self.name = self.name.replace("Braid", "Swap")

    def dagger(self): return Swap(self.dom[1], self.dom[0])

def hexagon(box_factory=Braid) -> Callable:
    @classmethod
    def method(cls, x: Ty, y: Ty) -> Diagram:
        if len(x) == 0: return cls.id(y)
        if len(x) == 1:
            if len(y) == 1: return box_factory(x[0], y[0])
            return method(cls, x, y[:1]) @ cls.id(y[1:])\
                >> cls.id(y[:1]) @ method(cls, x, y[1:])  # left hexagon equation.
        return cls.id(x[:1]) @ method(cls, x[1:], y)\
            >> method(cls, x[:1], y) @ cls.id(x[1:])  # right hexagon equation.
    return method

Diagram.braid, Diagram.swap = hexagon(), hexagon(Swap)

class Functor(monoidal.Functor):
    def __call__(self, other):
        if isinstance(other, Swap):
            return self.ar_factory.swap(self(other[0]), self(other[1]))
        if isinstance(other, Braid) and not other.is_dagger:
            return self.ar_factory.braid(self(other[0]), self(other[1]))
        return super().__call__(other)
\end{minted}
\end{python}

\begin{example}
We can check the hexagon equations hold on the nose.

\begin{minted}{python}
x, y, z = map(Ty, "xyz")

assert Diagram.swap(x, y @ z) == Swap(x, y) @ z >> y @ Swap(x, z)
assert Diagram.swap(x @ y, z) == x @ Swap(y, z) >> Swap(x, z) @ y
\end{minted}
\end{example}

\begin{python}
{\normalfont Implementation of $\mathbf{Pyth}$ and $\mathbf{Tensor}_\S$ as symmetric categories.}

\begin{minted}{python}
def function_swap(x: list[type], y: list[type]) -> Function:
    def inside(*xs):
        assert len(xs) == len(x + y)
        return untuple(xs[len(x):] + xs[:len(x)])
    return Function(inside, dom=x + y, cod=y + x)

Function.swap = Function.braid = function_swap

@classmethod
def tensor_swap(cls, x: list[int], y: list[int]) -> Tensor:
    inside = [[(i0, j0) == (i1, j1)
        for j0 in range(product(y)) for i0 in range(product(x))]
        for i1 in range(product(x)) for j1 in range(product(y))]
    return cls(inside, dom=x + y, cod=y + x)

Tensor.swap = Tensor.braid = tensor_swaps
\end{minted}
\end{python}

Note that the naturality axioms in $\mathbf{Pyth}$ hold only for its subcategory of pure functions, as we will see in section~\ref{section:premonoidal} $\mathbf{Pyth}$ is in fact a symmetric \emph{premonoidal} category.
This is also the case for $\mathbf{Tensor}_\S$ when the rig $\S$ is non-commutative.

\begin{example}
We can check the axioms for self-inverse natural transformations hold in $\mathbf{Tensor}_\S$ and $\mathbf{Pyth}$.

\begin{minted}{python}
swap_twice = Diagram.swap(x, y @ z) >> Diagram.swap(y @ z, x)

a, b = Ty('a'), Ty('b')
f = Box('f', a, b)

F = Functor(
    ob={a: 2, b: 3, x: 4, y: 5, z: 6},
    ar={f: [[1-2j, 3+4j]]},
    ob_factory=list[int], ar_factory=Tensor[complex])

assert F(swap_twice) == Tensor.id(F(x @ y @ z))
assert F(f @ x >> Swap(b, x)) == F(Swap(a, x) >> x @ f)
assert F(x @ f >> Swap(x, b)) == F(Swap(x, a) >> f @ x)

G = Functor(
    ob={a: complex, b: real, x: int, y: bool, z: str},
    ar={f: lambda z: abs(z) ** 2},
    ob_factory=list[type], ar_factory=Function)

assert G(swap_twice)(42, True, "meaning of life") == (42, True, "meaning of life")
assert G(f @ x >> Swap(b, x))(1j, 2) == G(Swap(a, x) >> x @ f)(1j, 2) == (2, f(1j))
assert G(x @ f >> Swap(x, b))(2, 1j) == G(Swap(x, a) >> f @ x)(2, 1j) == (f(1j), 2)
\end{minted}
\end{example}

Free braided categories are defined in a similar way, with generating boxes for both the braid $B$ and its inverse $B^{-1}$.
The arrows of the free symmetric PRO (i.e. with one generating object $x$) with no generating boxes (i.e. only swaps) are called \emph{permutations}, the arrows of the free braided PRO with no boxes are called \emph{braids}.
Both are \emph{groupoids}, i.e. all their arrows are isomorphisms.
For every $n \in \N$, the arrows $f : x^n \to x^n$ in the free symmetric (braided) PRO form the $n$-th symmetric group $S_n$ (braid group $B_n$).

A \emph{compact closed category} is one that is both rigid and symmetric, which implies that it is also pivotal, a $\dagger$-compact closed category is both $\dagger$-pivotal and $\dagger$-symmetric.
The arrows of free $\dagger$-compact closed categories (i.e. equivalence classes of diagrams with cups, caps and swaps) are also called \emph{tensor networks}, a graphical equivalent to \emph{Einstein notation} and \emph{abstract index notation}, first introduced by Penrose~\cite{Penrose71}.
Unlike the computer scientists however, physicists tend to identify the diagram (syntax) with its image under some interpretation functor to the category of tensors (semantics).

A \emph{tortile category}, also called a \emph{ribbon category}\footnote
{Here again we take a \emph{strict} definition, where the twist is an identity rather than an isomorphism.
In a non-strict tortile category, the wires would be drawn as ribbons, i.e. two wires side by side.
The twist isomorphism would be drawn as the two wires being braided twice.
In a strict tortile category, the ribbon has no width thus the twist is invisible.},
is a braided, pivotal category which furthermore satisfies the following \emph{untwisting} equation:
\ctikzfig{img/symmetric/untwisting}
The scalars of the free tortile category with no boxes (i.e. equivalence classes of diagrams with only cups, caps and braids) are called \emph{links} in general and \emph{knots} when they are connected.
Untwisting, the self-inverse equation and the Yang-Baxter equation (i.e. naturality with respect to braids) are called the three \emph{Reidemeister moves}, they completely characterise the continuous deformations of circles embedded in three-dimensional space~\cite{Reidemeister13}.

The \emph{unknotting problem} (given a knot, can it be untied, i.e. continuously deformed to a circle?) is a candidate NP-intermediate problem: it is decidable~\cite{Haken61} and in NP~\cite{Lackenby15}, but there is neither a proof of it being NP-complete nor a polynomial-time algorithm.
Delpeuch and Vicary~\cite{DelpeuchVicary21} proved that the word problem for free braided categories is unknotting-hard.
Hence, there is little hope of finding a simple polynomial-time algorithm for computing normal forms of braided diagrams.
Guiraud and Malbos~\cite{GuiraudMalbos12} do give a proof that the word problem for free braided categories is in fact decidable, however they do not give any complexity bounds.

The word problem for free symmetric categories reduces to the \emph{graph isomorphism problem}~\cite{PattersonEtAl21}, another potential NP-intermediate problem.
The word problem for free compact closed categories also reduces to graph isomorphism~\cite{Selinger07}.
To the best of our knowledge, it is not known whether they are graph-isomorphism-hard, i.e. whether there is a reduction the other around that sends any graph to a diagram with swaps (and cups and caps) so that graphs are isomorphic if and only their diagrams are equal.
Thus, there could be a simple polynomial-time algorithm for computing normal forms of diagrams in symmetric and compact closed categories.
In any case, DisCoPy does not implement any normal forms for diagrams with braids yet.

Of course, we can also enrich rigid and braided categories in commutative monoids, i.e. we can take formal sums of diagrams with cups, caps and braids in the same way as any other box.
We can also define bubbles and draw them in the same way as for monoidal diagrams.

\begin{example}
We can define knot polynomials such as the Kauffman bracket using pivotal functors into a category where braids are defined as a weighted sum of diagrams.

\begin{minted}{python}
x = pivotal.Ty('$x$')
A, A.inverse = Box('$A$', Ty(), Ty()), Box('$A^{-1}$', Ty(), Ty())

class Polynomial(pivotal.Diagram):
    def braid(x, y):
        assert x == y and len(x) == len(y) == 1
        return (A @ x @ y) + (Cup(x, y) >> A.inverse >> Cap(x, y))

Kauffman = Functor(
    ob={x: x}, ar={}
    ob_factory=pivotal.Ty, ar_factory=Polynomial)

drawing.equation(Braid(x, x).bubble(), Kauffman(Braid(x, x)))
\end{minted}

\ctikzfig{img/symmetric/kauffman-bracket}
\end{example}
