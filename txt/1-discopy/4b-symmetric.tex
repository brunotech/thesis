%!TEX root = ../../THESIS.tex

\subsection{Braided categories \& wire crossing} \label{subsection:symmetric}

With rigid and pivotal categories, we have removed the assumption that diagrams are progressive: we can bend wires.
With braided and symmetric monoidal categories, we now remove the planarity assumption: wires can cross.

The data for a \emph{braided category} is that of a monoidal category $C$ together with a \emph{brading} natural isomorphism $B(x, y) : x \otimes y \to y \otimes x$ (and its inverse $B^{-1}$) drawn as a wire for $x$ crossing under (over) a wire $y$.
Braidings are subject to the following \emph{hexagon equations}:
\begin{itemize}
\item $B(x, y \otimes z) \s = \s B(x,y) \otimes z \ \fcmp \ y \otimes B(x,z)$,
\ctikzfig{img/symmetric/hexagon-left}
\item $B(x \otimes y, z) \s = \s x \otimes B(y,z) \ \fcmp \ B(x,z) \otimes y$
\ctikzfig{img/symmetric/hexagon-right}
\end{itemize}
which owe their name to the shape of the corresponding commutative diagrams when $C$ is non-strict monoidal.
We also require that $B(x, 1) = \id(x) = B(1, x)$\footnote
{Note that in a non-strict monoidal category this axiom is unnecessary, it follows from the coherence conditions.},
i.e. braiding a wire $x$ with the unit $1$ does nothing, we do not need to draw it.
The hexagon equations may be taken as an inductive definition: we can decompose the braiding $B(x, y \otimes z)$ of an object with a tensor in terms of two simpler braids $B(x,y)$ and $B(x,z)$.
Thus, we can take the data for a braided category to be that of a foo-monoidal category together with a pair of functions $B, B^{-1} : C_0 \times C_0 \to C_1$ which send a pair of generating objects to their braiding and its inverse.
Once we have specified the braids of generating objects, the braids of any type (i.e. list of objects) is uniquely determined.
A monoidal functor $F : C \to D$ between two braided categories $C$ and $D$ is braided when $F(B(x, y)) = B(F(x), F(y))$.
Thus, we get a category $\mathbf{BraidCat}$ with a forgetful functor $U : \mathbf{BraidCat} \to \mathbf{MonSig}$, we now describe its left adjoint.

Given a monoidal signature $\Sigma$, the free braided category is a quotient $F^B(\Sigma) = F(\Sigma^B) / R$ of the free monoidal category generated by $\Sigma^B =  \Sigma \cup B \cup B^{-1}$ for the braiding $B(x, y) : x \otimes y \to y \otimes x$ and its inverse $B^{-1}(x, y) : y \otimes x \to x \otimes y$ for each pair of generating objects $x, y \in \Sigma_0$.
The relation $R$ is given by the following axioms for a natural isomorphism:
\begin{itemize}
\item $B(x, y) \fcmp B^{-1}(y, x)
\s = \s \id(x \otimes y) \s = \s B^{-1}(y, x) \fcmp B(x, y)$,
\ctikzfig{img/symmetric/isomorphism}
\item $f \otimes x \ \fcmp \ B(b, x) \s = \s B(a, x) \ \fcmp \ x \otimes f \s$ and $\s x \otimes f \ \fcmp \ B(x, b) \s = \s B(x, a) \ \fcmp \ f \otimes x$.
\begin{center}
\tikzfig{img/symmetric/naturality-left}
\hfill
\tikzfig{img/symmetric/naturality-right}
\end{center}
\end{itemize}
for all generating objects $x, y \in \Sigma_0$ and boxes (including braidings) $f : a \to b$ in $\Sigma^B$.
From $B$ being an isomorphism on generating objects, we can prove it is self-inverse on any type by induction.
Similarly, from $B$ being natural on the left and right for each box, we can prove by induction that it is in fact natural for any diagram.
Note that the naturality axiom holds for boxes with domains and codomains of arbitrary length.
In particular, it holds for $f = B(y, z)$ in which case we get the following Yang-Baxter equation:
\ctikzfig{img/symmetric/yang-baxter}
It also holds for any scalar $f : 1 \to 1$, which allows to pass them through a wire:
\ctikzfig{img/symmetric/naturality-scalars}

A braided category $C$ is \emph{symmetric} if the braiding $B$ is its own inverse $B = B^{-1} = S$, in this case it is called a \emph{swap} and drawn as the intersection of two wires.
A symmetric functor is a braided functor between symmetric categories.
A $\dagger$-braided category is a braided category with a dagger structure, such that the braidings are unitaries, i.e. their inverse is also their dagger.
A $\dagger$-symmetric category is a $\dagger$-braided category that is also symmetric.

\begin{remark}
A symmetric (braided) category with one generating object is called a PROP (PROB) for PROduct and Permutation (Braid).
Indeed, the arrows of the free PROP with no generating boxes (i.e. only swaps) are \emph{permutations}, the arrows of the free braided PRO with no boxes are called \emph{braids}.

Both are \emph{groupoids}, i.e. all their arrows are isomorphisms, which also implies that they are $\dagger$-braided with the dagger given by the inverse.
For every $n \in \N$, the arrows $f : x^n \to x^n$ in the free PROP (PROB) are the elements of the $n$-th symmetric group $S_n$ (braid group $B_n$).
\end{remark}

DisCoPy implements free $\dagger$-symmetric ($\dagger$-braided) categories with a class \py{Swap} (\py{Braid}) initialised by types of length one and a class method \py{swap} (\py{braid}) for types of arbitrary length.
The method \py{simplify} cancels every braid followed by its inverse.
The \py{naturality} method applies the naturality axiom to the box at a given index \py{i: int}.
The optional argument \py{left: bool} allows to choose between left and right naturality axioms, \py{down: bool} allows to move the box either up or down the braid and \py{braid: Callable} allows to apply naturality to any subclass of \py{Braid}.

\begin{python}
{\normalfont Implementation of free $\dagger$-braided and $\dagger$-symmetric categories.}

\begin{minted}{python}
class Diagram(monoidal.Diagram):
    def simplify(self):
        for i, ((x, f, _), (y, g, _)) in enumerate(
                zip(self.inside, self.inside[1:])):
            if x == y and isinstance(f, Braid) and f == g[::-1]:
                inside = self.inside[:i] + self.inside[i + 2:]
                return self.cast(Diagram(inside, self.dom, self.cod)).simplify()
        return self

class Box(monoidal.Box, Diagram):
    cast = Diagram.cast

class Braid(Box):
    def __init__(self, x: Ty, y: Ty, is_dagger=False):
        assert len(x) == len(y) == 1
        name = "{}({}, {})[::-1]".format(type(self), y, x) if is_dagger\
            else "{}({}, {})".format(type(self), x, y)
        super().__init__(name, x @ y, y @ x, is_dagger)

    def dagger(self): return Braid(*self.cod, is_dagger=not self.is_dagger)

class Swap(Braid):
    def dagger(self): return Swap(*self.cod)

def hexagon(factory) -> Callable:
    def method(cls, x: Ty, y: Ty) -> Diagram:
        if len(x) == 0: return cls.id(y)
        if len(x) == 1:
            if len(y) == 1: return factory(x[0], y[0])
            return method(cls, x, y[:1]) @ cls.id(y[1:])\
                >> cls.id(y[:1]) @ method(cls, x, y[1:])  # left hexagon equation.
        return cls.id(x[:1]) @ method(cls, x[1:], y)\
            >> method(cls, x[:1], y) @ cls.id(x[1:])  # right hexagon equation.
    return classmethod(method)

Diagram.braid, Diagram.swap = hexagon(Braid), hexagon(Swap)

def naturality(self: Diagram, i: int, left=True, down=True, braid=None):
    braid = braid or self.braid
    layer, box = self.inside[i], self.inside[i].box
    if left and down:
        source = layer.left[-1] @ box >> braid(layer.left[-1], box.cod)
        target = braid(layer.left[-1], box.dom) >> box @ layer.left[-1]
    elif left: ...
    elif down: ...
    else:
        source = braid(layer.right[0], box.dom) >> box @ layer.right[0]
        target = layer.right[0] @ box >> braid(layer.right[0], box.cod)
    match = Match(top=self[:i] if down else self[:i - len(source) + 1],
                  bottom=self[i + len(source):] if down else self[i + 1:],
                  left=layer.left[:-1] if left else layer.left,
                  right=layer.right if left else layer.right[1:])
    assert self == match.subs(source)
    return match.subs(target)

Diagram.naturality = naturality

class Functor(monoidal.Functor):
    dom = cod = Category(Ty, Diagram)

    def __call__(self, other):
        if isinstance(other, Swap):
            return self.cod.ar.swap(self(other.dom[0]), self(other.dom[1]))
        if isinstance(other, Braid) and not other.is_dagger:
            return self.cod.ar.braid(self(other.dom[0]), self(other.dom[1]))
        return super().__call__(other)
\end{minted}
\end{python}

\begin{example}
We can check the hexagon equations hold on the nose.

\begin{minted}{python}
x, y, z = map(Ty, "xyz")

assert Diagram.braid(x, y @ z) == Braid(x, y) @ z >> y @ Braid(x, z)
assert Diagram.braid(x @ y, z) == x @ Braid(y, z) >> Braid(x, z) @ y
\end{minted}

We can check that \py{Braid} is an isomorphism up to a \py{simplify} call.

\begin{minted}{python}
assert (Diagram.braid(x, y @ z) >> Diagram.braid(x, y @ z)[::-1]).simplify()\
    == Diagram.id(x @ y @ z)\
    == (Diagram.braid(y @ z, x)[::-1] >> Diagram.braid(y @ z, x)).simplify()
\end{minted}

We can check that \py{Braid}, its inverse and \py{Swap} are all natural.

\begin{minted}{python}
a, b = Ty('a'), Ty('b')
f = Box('f', a, b)

for braid in [
        Diagram.braid, (lambda x, y: Diagram.braid(y, x)[::-1]), Diagram.swap]:
    source, target = x @ f >> braid(x, b), braid(x, a) >> f @ x
    assert source.naturality(0, braid=braid) == target
    assert target.naturality(1, left=False, down=False, braid=braid) == source
\end{minted}
\end{example}

\begin{python}
{\normalfont Implementation of $\mathbf{Pyth}$ and $\mathbf{Tensor}_\S$ as symmetric categories.}

\begin{minted}{python}
@staticmethod
def function_swap(x: tuple[type, ...], y: tuple[type, ...]) -> Function:
    def inside(*xs):
        assert len(xs) == len(x + y)
        return untuplify(xs[len(x):] + xs[:len(x)])
    return Function(inside, dom=x + y, cod=y + x)

Function.swap = Function.braid = function_swap

@classmethod
def tensor_swap(cls, x: tuple[int, ...], y: tuple[int, ...]) -> Tensor:
    inside = [[(i0, j0) == (i1, j1)
        for j0 in range(product(y)) for i0 in range(product(x))]
        for i1 in range(product(x)) for j1 in range(product(y))]
    return cls(inside, dom=x + y, cod=y + x)

Tensor.swap = Tensor.braid = tensor_swap
\end{minted}
\end{python}

\begin{example}
We can check the axioms for symmetric categories hold in $\mathbf{Tensor}_\S$ and $\mathbf{Pyth}$.

\begin{minted}{python}
swap_twice = Diagram.swap(x, y @ z) >> Diagram.swap(y @ z, x)

F = Functor(
    ob={a: 1, b: 2, x: 3, y: 4, z: 5},
    ar={f: [[1-2j, 3+4j]]},
    cod=Category(tuple[int, ...], Tensor[complex]))

assert F(f @ x >> Swap(b, x)) == F(Swap(a, x) >> x @ f)
assert F(x @ f >> Swap(x, b)) == F(Swap(x, a) >> f @ x)
assert F(swap_twice) == Tensor.id(F(x @ y @ z))

G = Functor(
    ob={a: complex, b: float, x: int, y: bool, z: str},
    ar={f: lambda z: abs(z) ** 2},
    cod=Category(tuple[type, ...], Function))

assert G(f @ x >> Swap(b, x))(1j, 2) == G(Swap(a, x) >> x @ f)(1j, 2)
assert G(x @ f >> Swap(x, b))(2, 1j) == G(Swap(x, a) >> f @ x)(2, 1j)
assert G(swap_twice)(42, True, "foo") == (42, True, "foo")
\end{minted}
\end{example}

\begin{remark}
Note that the naturality axioms in $\mathbf{Pyth}$ hold only for its subcategory of pure functions, as we will see in section~\ref{section:premonoidal} $\mathbf{Pyth}$ is in fact a symmetric \emph{premonoidal} category.
This is also the case for $\mathbf{Tensor}_\S$ when the rig $\S$ is non-commutative.
\end{remark}

A \emph{compact closed category} is one that is both rigid and symmetric, which implies that it is also pivotal; a $\dagger$-compact closed category is both $\dagger$-pivotal and $\dagger$-symmetric.
The arrows of free $\dagger$-compact closed categories (i.e. equivalence classes of diagrams with cups, caps and swaps) are also called \emph{tensor networks}, a graphical equivalent to \emph{Einstein notation} and \emph{abstract index notation}, first introduced by Penrose~\cite{Penrose71}.
Unlike the computer scientists however, physicists tend to identify the diagram (syntax) with its image under some interpretation functor to the category of tensors (semantics).

A \emph{tortile category}, also called a \emph{ribbon category}\footnote
{Here again we take a \emph{strict} definition, where the twist is an identity rather than an isomorphism.
In a non-strict tortile category, the wires would be drawn as ribbons, i.e. two wires side by side.
The twist isomorphism would be drawn as the two wires being braided twice.
In a strict tortile category, the ribbon has no width thus the twist is invisible.},
is a braided, pivotal category which furthermore satisfies the following \emph{untwisting} equation:
\ctikzfig{img/symmetric/untwisting}
The scalars of the free tortile category with no boxes (i.e. equivalence classes of diagrams with only cups, caps and braids) are called \emph{links} in general and \emph{knots} when they are connected.
Untwisting, the self-inverse equation and the Yang-Baxter equation (i.e. naturality with respect to braids) are called the three \emph{Reidemeister moves}, they completely characterise the continuous deformations of circles embedded in three-dimensional space~\cite{Reidemeister13}.

The \emph{unknotting problem} (given a knot, can it be untied, i.e. continuously deformed to a circle?) is a candidate NP-intermediate problem: it is decidable~\cite{Haken61} and in NP~\cite{Lackenby15}, but there is neither a proof of it being NP-complete nor a polynomial-time algorithm.
Delpeuch and Vicary~\cite{DelpeuchVicary21} proved that the word problem for free braided categories is unknotting-hard.
Hence, there is little hope of finding a simple polynomial-time algorithm for computing normal forms of braided diagrams.
It is not known whether it is even decidable.

The word problem for free symmetric categories reduces to the \emph{graph isomorphism problem}~\cite{PattersonEtAl21}, another potential NP-intermediate problem.
The word problem for free compact closed categories also reduces to graph isomorphism~\cite{Selinger07}.
To the best of our knowledge, it is not known whether they are graph-isomorphism-hard, i.e. whether there is a reduction the other way around that sends any graph to a diagram with swaps (and cups and caps) so that graphs are isomorphic if and only their diagrams are equal.
Thus, there could be a simple polynomial-time algorithm for computing normal forms of diagrams in symmetric and compact closed categories.
In any case, DisCoPy does not implement any normal forms for diagrams with braids yet.

Of course, we can also enrich rigid and braided categories in commutative monoids, i.e. we can take formal sums of diagrams with cups, caps and braids in the same way as any other box.
We can also define bubbles and draw them in the same way as for monoidal diagrams.

\begin{python}
{\normalfont Implementation of free tortile categories and functors.}

\begin{minted}{python}
class Ty(pivotal.Ty, braided.Ty): pass

class Diagram(pivotal.Diagram, braided.Diagram): pass

class Box(pivotal.Box, braided.Box, Diagram):
    cast = Diagram.cast

class Cup(pivotal.Cup, Box): pass

class Cap(pivotal.Cap, Box): pass

class Braid(braided.Braid, Box): pass

Diagram.braid = hexagon(Braid)
Diagram.cups, Diagram.caps = nesting(Cup), nesting(Cap)

class Functor(pivotal.Functor, braided.Functor):
    dom = cod = Category(Ty, Diagram)

    def __call__(self, other):
        if isinstance(other, Braid):
            return braided.Functor.__call__(self, other)
        return pivotal.Functor.__call__(self, other)
\end{minted}
\end{python}

\begin{example}
We can define knot polynomials such as the Kauffman bracket using tortile functors into a category where the braiding is defined as a weighted sum of diagrams.

\begin{minted}{python}
x, A = Ty('x'), Box('A', Ty(), Ty())

class Polynomial(Diagram):
    def braid(x, y):
        assert x == y and len(x) == len(y) == 1
        return (A @ x @ y) + (Cup(x, y) >> A.dagger() >> Cap(x, y))

Kauffman = Functor(
    ob={x: x}, ar={}, cod=Category(Ty, Polynomial))

drawing.equation(Braid(x, x).bubble(), Kauffman(Braid(x, x)))
\end{minted}

\ctikzfig{img/symmetric/kauffman-bracket}
\end{example}
