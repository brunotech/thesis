%!TEX root = ../../THESIS.tex

\section{Categories in Python}

\subsection{Abstract categories}

What are categories and how can they be useful to the Python programmer?
This section will answer this question by taking the standard mathematical definitions and breaking them into \emph{data}, which can be translated into Python code, and \emph{axioms}, which cannot be formally verified in Python, but can be translated into test cases.
The data for a category is given by a tuple $C = (C_0, C_1, \dom, \cod, \id, \then)$ where:
\begin{itemize}
\item $C_0$ and $C_1$ are classes of \emph{objects} and \emph{arrows} respectively,
\item $\dom, \cod : C_1 \to C_0$ are functions called \emph{domain} and \emph{codomain},
\item $\id : C_0 \to C_1$ is a function called \emph{identity},
\item $\then : C_1 \times C_1 \to C_1$ is a partial function called \emph{composition}, denoted by $(\fcmp)$.
\end{itemize}
Given two objects $x, y \in C_0$, the set\footnote
{We will assume that this forms a set rather than a proper class, i.e. we will only work with \emph{locally small} categories.}
$C(x, y) = \{f \in C_1 \s \vert \s \dom(f), \cod(f) = x, y \}$ is called a \emph{homset} and we write $f : x \to y$ whenever $f \in C(x, y)$.
We denote the composition $\then(f, g)$ by $f \fcmp g$, translated to \py{f >> g} or \py{g << f} in Python.
The axioms for the category $C$ are the following:
\begin{itemize}
\item $\id(x) : x \to x$ for all objects $x \in C_0$,
\item for all arrows $f, g \in C_1$, the composition $f \fcmp g$ is defined iff $\cod(f) = \dom(g)$, moreover we have $f \fcmp g : \dom(f) \to \cod(g)$,
\item $\id(\dom(f)) \fcmp f = f = f \fcmp \id(\cod(f))$ for all arrows $f \in C_1$,
\item $f \fcmp (g \fcmp h) = (f \fcmp g) \fcmp h$ whenever either side is defined for $f, g, h \in C_1$.
\end{itemize}

Note that we play with the overloaded meaning of the word \emph{class}: we use it to mean both a mathematical collection that need not be a set, and a Python class with its methods and attributes.
Reading it in the latter sense, $\dom$ and $\cod$ are \emph{attributes} of the arrow class, $\then$ is a \emph{method}, $\id$ is a \emph{static method}.
Thus, implementing a category in Python means nothing more than subclassing the  abstract classes \py{Object} and \py{Arrow} of listing~\ref{listing:abstract classes}, and then checking that the axioms hold via some (necessarily non-exhaustive) software tests.

\begin{python}\label{listing:abstract classes}
{\normalfont AbstractÂ classes for categories, functors and transformations.}

Note that annotations with dependent types are not supported by any Python implementation yet.
Since Python could not statically check that compositions are well-typed, DisCoPy has no type hints and raises an \py{AxiomError} at runtime instead.
\begin{minted}{python}
class Object: ...

class Arrow:
    dom: Object, cod: Object

    @staticmethod
    def id(x: Object) -> Arrow[x, x]: ...

    def then(self, other: Arrow[self.cod, y]) -> Arrow[self.dom, y]: ...

class Functor:
    @overload
    def __call__(self, x: Object) -> Object: ...

    @overload
    def __call__(self, f: Arrow[x, y]) -> Arrow[self(x), self(y)]: ...

class Transformation:
    dom: Functor, cod: Functor

    def __call__(self, x: Object) -> Arrow[self.dom(x), self.cod(x)]: ...
\end{minted}
\end{python}

The data for a \emph{functor} $F : C \to D$ between two categories $C$ and $D$ is given by a pair of overloaded functions $F : C_0 \to D_0$ and $F : C_1 \to D_1$ such that:
\begin{itemize}
    \item $F(\dom(f)) = \dom(F(f))$ and $F(\cod(f)) = \cod(F(f))$ for all $f \in C_1$,
    \item $F(\id(x)) = \id(F(x))$ and $F(f \fcmp g) = F(f) \fcmp F(g)$ for all $x \in C_0$ and $f, g \in C_1$.
\end{itemize}
Thus, implementing a functor in Python amounts to subclassing the \py{Functor} class of listing~\ref{listing:abstract classes} (and then implementing software tests to check that the axioms hold).

The data for a \emph{transformation} $\alpha : F \to G$ between two parallel functors $F, G : C \to D$ is given by a function from objects $x \in C_0$ to components $\alpha(x) : F(x) \to G(x)$ in $D$.
A \emph{natural transformation} is one where $\alpha(x) \fcmp G(f) = F(f) \fcmp \alpha(y)$ for all arrows $f : x \to y$ in $C$.
The \py{Transformation} class is given in listing~\ref{listing:abstract classes}, checking that a transformation is natural cannot be done formally in Python.
In the same way that there is a set $Y^X$ of functions $X \to Y$ for any two sets $X$ and $Y$, for any two categories $C$ and $D$ there is a category $D^C$ with functors $C \to D$ as objects and natural transformations as arrows.

\subsection{Concrete categories}

\begin{example}\label{ex:python categories}
We can define the category $\mathbf{Pyth}$ with objects the class of all Python types and arrows the class of all Python functions.
Domain and codomain of may be extracted from type annotations.
Identity may given by \py{lambda *xs: xs} and the composition by \py{lambda f, g: lambda *xs: f(*g(*xs)))}. (The star takes care of functions with multiple arguments.)
However, equality of functions in Python is undecidable so there will be no way to check the axioms hold in general.

Endofunctors $\mathbf{Pyth} \to \mathbf{Pyth}$ can be thought of as some kind of data containers.
For example, we can define a $\mathbf{List}$ functor which sends a type \py{t} to \py{List[t]} and a function \py{f} to \py{lambda *xs: map(f, xs)}.
There is a natural transformation $\eta : \mathbf{Id} \to \mathbf{List}$ from the obvious identity functor, implemented by the built-in function \py{id}.
Its components send objects \py{x : t} of any type \py{t} to the singleton list \py{[x] : List[t]}.
\end{example}

\begin{python}
{\normalfont Implementation of the category $\mathbf{Pyth}$ with \py{type} as objects and \py{Function} as arrows.}

\begin{minted}{python}
@dataclass
class Function:
    inside: Callable
    dom: type
    cod: type

    @staticmethod
    def id(x: type) -> Function:
        return Function(lambda *xs: xs, x, x)

    def then(self, other: Function) -> Function:
        return Function(lambda *xs: other(*self(*xs)), self.dom, other.cod)

    def __call__(self, *xs): return self.inside(*xs)
\end{minted}
\end{python}

\begin{example}
When the class of objects and arrows are in fact sets, $C$ is called a \emph{small category}.
For example, the category $\mathbf{FinSet}$ has the set of all finite sets as objects and the set of all functions between them as arrows.
This time equality of functions between finite sets is decidable, so we can write unit tests that check that the axioms hold on specific examples.
\end{example}

\begin{example}
When the class of objects and arrow are finite sets, we can draw the category as a directed multigraph with objects as nodes and arrows as edges, together with the list of equations between paths.
A functor $F : C \to D$ from such a finite category $C$ is called a \emph{commutative diagram} in $D$.
For example, the following commutative diagram denotes a functor $3 \to \mathbf{Pyth}$ from the finite category $3$ with three objects $\{ 0, 1, 2 \}$ and three non-identity arrow $f : 0 \to 1, g : 1 \to 2$ and $h : 0 \to 2$, with the only non-trivial composition $f \fcmp g = h$.
\[ \begin{tikzcd}
\py{int}
\ar{rrrrrr}{\py{lambda n: n * (n - 1) // 2}}
\ar{rrrd}[']{\py{range}}
& & & & & & \py{int} \\
& & & \py{Iterable}
\ar{urrr}[']{\py{sum}} & & &
\end{tikzcd}
\]
Thus, this commutative diagram is the equation \py{sum(range(n)) = n * (n - 1) // 2}.
When the finite category is bigger than a triangle, one commutative diagram can state a large number of equations, which can be read by \emph{diagram chasing}.
\end{example}

\begin{example}
The category $\mathbf{Mat}_\S$ has natural numbers as objects and $n \times m$ matrices with values in $\S$ as arrows $n \to m$.
The identity and composition are given by the identity matrix and matrix multiplication respectively.
In order for matrix multiplication to be well-defined and for $\mathbf{Mat}_\S$ to be a category, the scalars $\S$ should have at least the structure of a \emph{rig} (a riNg without Negatives): a pair of monoids $(\S, +, 0)$ and $(\S, \times, 1)$ with the first one commutative and the second a homomorphism for the first, i.e. $a \times 0 = 0 = 0 \times a$ and $(a + b) \times (c + d) = a c + a d + b c + b d$.
The category $\mathbf{Mat}_\C$ is equivalent to the category of finite dimensional vector spaces and linear maps.
When the scalars are Booleans with disjunction and conjunction as addition and multiplication, the category $\mathbf{Mat}_\B$ is equivalent to the category of finite sets and relations.
There is a faithful functor (i.e. injective on arrows with the same domain and codomain) $\mathbf{FinSet} \to \mathbf{Mat}_\B$ which sends finite sets to their cardinality and functions to their graph.
\end{example}

\begin{python}
{\normalfont Implementation of the Boolean rig $\B$ with addition and multiplication defined as disjunction and conjunction.}

\begin{minted}{python}
class B:
    def __init__(self, inside: bool): self.inside = bool(inside)
    __add__ = __radd__ = lambda self, other: B(self.inside or other)
    __mul__ = __rmul__ = lambda self, other: B(self.inside and other)
    __bool__ = lambda self: self.inside
    __eq__ = lambda self, other: bool(self) == bool(other)
    __repr__ = __str__ = lambda self: repr(int(self.inside))
\end{minted}
\end{python}

\begin{python}
{\normalfont Implementation of $\mathbf{Mat}_\S$ with \py{int} as objects and \py{Matrix} with entries in $\S = \py{dtype}$ as arrows.}

\begin{minted}{python}
class Matrix:
    dtype = B

    def __init__(self, inside: list[list[dtype]], dom: int, cod: int):
        self.dom, self.cod, self.inside = dom, cod, [
            list(map(self.dtype, row)) for row in inside]

    @staticmethod
    def id(x: int) -> Matrix:
        return Matrix([[i == j for i in range(x)] for j in range(x)], x, x)

    def then(self, other: Matrix) -> Matrix:
        inside = [[
            sum([self[i][j] * other[j][k] for j in range(other.dom)])
            for k in range(other.cod)] for i in range(self.dom)]
        return Matrix(inside, self.dom, other.cod)

    __getitem__ = lambda self, key: self.inside[key]
    __eq__ = lambda self, other: isinstance(other, Matrix) and (
        self.inside, self.dom, self.cod) == (other.inside, other.dom, other.cod)
    __repr__ = lambda self: "Matrix({}, {}, {})".format(
        self.inside, self.dom, self.cod)
\end{minted}
\end{python}

\begin{example}
The category $\mathbf{Circ}$ has natural numbers as objects and $n$-qubit quantum circuits as arrows $n \to n$.
There is a functor $\mathtt{eval} : \mathbf{Circ} \to \mathbf{Mat}_\C$ which sends $n$ qubits to $2^n$ dimensions and evaluates each circuit to its unitary matrix.
\end{example}

\begin{example}
A monoid is the same as a category with one object, i.e. every arrow (element) can be composed with (multiplied by) every other.
A preorder, i.e. a set with a reflexive transitive relation, is the same as a category with at most one arrow $x \leq y$ between any two objects $x$ and $y$.
Functors between monoids are the same as homomorphisms, functors between preorders are monotone functions.
\end{example}

\begin{example}
Just about any class of mathematical structures will be the objects of a category with the transformations between them as arrows.
For example, the category $\mathbf{Set}$ of sets and functions, the category $\mathbf{Mon}$ of monoids and homomorphisms, the category $\mathbf{Cat}$ of small categories and functors, etc.
The faithful functor $U : \mathbf{Mon} \to \mathbf{Set}$ which sends monoids to their underlying set and homomorphisms to functions is called a \emph{forgetful functor}.
\end{example}

\subsection{Free categories}

The main principles behind the implementation of DisCoPy follow from the concept of a \emph{free object}.
Let's start from a simple example.
Given a set $X$, we can construct a monoid $X^\star$ with underlying set $\coprod_{n \in \N} X^n$ the set of all finite lists with elements in $X$.
The associative multiplication is given by list concatenation $X^m \times X^n \to X^{m + n}$ and the unit is given by the empty list denoted $1 \in X^0$.
Given a function $f : X \to Y$, we can construct a homomorphism $f^\star : X^\star \to Y^\star$ defined by element-wise application of $f$ (this is what the built-in \py{map} does in Python).
We can easily check that $(f \fcmp g)^\star = f^\star \fcmp g^\star$ and $(\id_X)^\star = \id_{X^\star}$.
Thus, we have defined a functor $F : \mathbf{Set} \to \mathbf{Mon}$.

Why is this functor so special? Because it is the \emph{left adjoint} to the forgetful functor $U : \mathbf{Mon} \to \mathbf{Set}$.
An \emph{adjunction} $F \dashv U$ between two functors $F : C \to D$ and $U : D \to C$ is a pair of natural transformations $\eta : \id_C \to F \fcmp U$ and $\epsilon : U \fcmp F \to \id_D$ called the \emph{unit} and \emph{counit} respectively.
In the case of lists, we already mentioned the unit in example~\ref{ex:python categories}: it is the function that sends every object to a singleton list.
For a monoid $M$, the counit $\epsilon(M) : F(U(M)) \to M$ is the monoid homomorphism that takes lists of elements in $M$ and multiplies them.
We can easily check that these two transformations are indeed natural, thus we get that \emph{lists are free monoids}.
This may be taken as a mathematical explanation for why lists are so ubiquitous in programming.
Another equivalent definition of adjunction is in terms of an isomorphism $C(x, U(y)) \simeq D(F(x), y)$ which is natural\footnote
{The isomorphism $C(x, U(y)) \simeq D(F(x), y)$ is natural in $x$ if it is a natural transformation between the two functors $C(-, U(y)), D(F(-), y) : C \to \mathbf{Set}$.}
in $x \in C_0$ and $y \in D_0$.
In the adjunction for lists, functions $X \to U(M)$ from a set $X$ to the underlying set of a monoid $M$ are in a natural one-to-one correspondance with monoid homomorphisms $X^\star \to M$.
To define a homomorphism from a free monoid, it is sufficient to define the image of each generating element.

Now we want to play the same game with categories instead of monoids.
We can define a forgetful functor $U : \mathbf{Cat} \to \mathbf{Set}$ which sends a small category $C$ to its set of objects $C_0$, and its left adjoint $F : \mathbf{Set} \to \mathbf{Cat}$ which sends a set to the \emph{discrete category} with its elements as objects and only identity arrows.
However, this is a rather boring construction because forgetting the arrows of a categories is too much: the forgetful functor $U$ is not faithful.
Instead, we need to replace the category of sets with the category of \emph{signatures}.
The data for a signature is given by a tuple $\Sigma = (\Sigma_0, \Sigma_1, \dom, \cod)$ where:
\begin{itemize}
    \item $\Sigma_0$ is a set of \emph{generating objects},
    \item $\Sigma_1$ is a set of \emph{generating arrows}, which we will also call \emph{boxes},
    \item $\dom, \cod : \Sigma_1 \to \Sigma_0$ are the domain and codomain.
\end{itemize}
A morphism of signatures $f : \Sigma \to \Gamma$ is a pair of overloaded functions $f : \Sigma_0 \to \Gamma_0$ and $f : \Sigma_1 \to \Gamma_1$ such that $f \fcmp \dom = \dom \fcmp f$ and $f \fcmp \cod = \cod \fcmp f$.
Thus, signatures and their morphisms form a category $\mathbf{Sig}$ and there is a faithful functor $U : \mathbf{Cat} \to \mathbf{Sig}$ which sends a category to its underlying signature: it forgets the identity and composition.
Signatures may be thought of as directed multigraphs \emph{with an attitude}~\cite{NLab}.
Given a signature $\Sigma$, we can define a category $F(\Sigma)$ with nodes as objects and \emph{paths as arrows}.
More precisely, an arrow $f : x \to y$ is given by a length $n \in \N$ and a list $f_1, \dots, f_n \in \Sigma_1$ with $\dom(f_1) = x$, $\cod(f_n) = y$ and $\cod(f_i) = \dom(f_{i + 1})$ for all $i < n$.
Given a morphism of signatures $f : \Sigma \to \Gamma$, we get a functor $F(f) : F(\Sigma) \to F(\Gamma)$ relabeling boxes in $\Sigma$ by boxes in $\Gamma$.
Thus, we have defined a functor $F : \mathbf{Sig} \to \mathbf{Cat}$, it remains to show that it indeed forms an adjunction $F \dashv U$.
This is very similar to the monoid case: the unit sends a box in a signature to the path of just itself, the counit sends a path of arrows in a category to their composition.
Equivalently, we have a natural isomorphism $\mathbf{Cat}(F(\Sigma), C) \simeq \mathbf{Sig}(\Sigma, U(C))$: to define a functor $F(\Sigma) \to C$ from a free category is the same as to define a morphism of signatures $\Sigma \to U(C)$.

If lists are such fundamental data structures because they are free monoids, we argue that the arrows of free categories should be just as fundamental: they capture the basic notion of \emph{data pipelines}.
Free categories are implemented in the most basic module of DisCoPy, \py{discopy.cat}, which is sketched in listing~\ref{listing:cat.py}.

\begin{python}~\label{listing:cat.py}
{\normalfont Outline of the classes \py{Ob}, \py{Arrow} and \py{Box}.}
\begin{minted}{python}
@dataclass
class Ob:
    name: str
    __str__ = lambda self: self.name

@dataclass
class Arrow:
    dom: Ob
    cod: Ob
    boxes: list[Arrow]

    @classmethod
    def upgrade(cls, old: Arrow) -> Arrow:
        if isinstance(old, cls): return old
        return cls(old.dom, old.cod, old.boxes)

    @classmethod
    def id(cls, x: Ob) -> Arrow:
        return cls.upgrade(Arrow(x, x, []))

    def then(self, *others: Arrow) -> Arrow:
        for f, g in zip((self, ) + others, others): assert f.cod == g.dom
        dom, cod = self.dom, others[-1].cod if others else self.cod
        boxes = self.boxes + sum([other.boxes for other in others], [])
        return self.upgrade(Arrow(dom, cod, boxes))

    __rshift__, __lshift__ = then, lambda self, other: other.then(self)
    __len__ = lambda self: len(self.boxes)
    __str__ = lambda self: ' >> '.join(map(str, self.boxes))\
        if self.boxes else '{}.id({})'.format(type(self).__name__, self.dom)

class Box(Arrow):
    def __init__(self, name: str, dom: Ob, cod: Ob):
        self.name = name; super().__init__(dom, cod, [self])

    def __eq__(self, other):
        if isinstance(other, Box):
            return (self.name, self.dom, self.cod)\
                == (other.name, other.dom, other.cod)
        return isinstance(other, Arrow) and other.boxes == [self]

    upgrade = Arrow.upgrade
    __str__ = lambda self: self.name
\end{minted}
\end{python}

The classes \py{Ob} and \py{Arrow} for objects and arrows are implemented in a straightforward way, using the built-in \py{dataclass} decorator to avoid the bureaucracy of defining initialisation, equality, etc.
We define the method \py{__str__} so that \py{eval(str(f)) == f} for all \py{f: Arrow}, provided that the names of each object and box is in scope.
The method \py{Arrow.then} accepts any number of arrows \py{others}, which will prove useful when defining functors.
The \py{Box} class requires more attention: a box \py{f = Box('f', x, y)} is an arrow with the list of just itself as boxes, i.e. \py{f.boxes == [f]}.
In order for the axiom \py{f >> Id(y) == f == Id(x) >> f} to hold, we need to make sure that \py{f == Arrow(x, y, [f])}, i.e. a box is set to be equal to the arrow with just itself as boxes.
The main subtlety in the implementation is the class method \py{upgrade} which takes an \py{old: Arrow} as input and returns a new member of a given \py{cls}, subclass of \py{Arrow}.
This allows the composition of arrows in a subclass to remain within the subclass, without having to rewrite the method \py{then}.
This means we need to make \py{Arrow.id} a \py{classmethod} as well so that it can call \py{upgrade} and return an arrow of the appropriate subclass.
We also need to fix \py{Box.upgrade = Arrow.upgrade}, otherwise we would be able to compose a diagram then a box but not a box then a diagram.

\begin{example}
We can define \py{Circuit} as a subclass of \py{Arrow} and \py{Gate} as a subclass of \py{Circuit} and \py{Box} defined by a name and a number of qubits.

\begin{minted}{python}
class Circuit(Arrow): pass

class Gate(Box, Circuit):
    upgrade = Circuit.upgrade

    def __init__(self, name: str, n_qubits: int):
        dom, cod = Ob(str(n_qubits)), Ob(str(n_qubits))
        Box.__init__(self, name, dom, cod)

Id = Circuit.id(Ob('1'))
X, Y, Z, H = [Gate(name, n_qubits=1) for name in "XYZH"]

assert (X >> Y) >> Z == X >> (Y >> Z) and X >> Id == X == Id >> X
assert isinstance(Id, Circuit) and isinstance(X >> Y, Circuit)
\end{minted}
\end{example}

The \py{Functor} class listed in \ref{listing:Functor} has two mappings \py{ob} and \py{ar} as attributes, from objects to objects and from boxes to arrows respectively.
The domain of the functor is implicitly defined as the free category generated by the domain of the \py{ob} and \py{ar} mappings.
The optional arguments \py{ob_factory} and \py{ar_factory} serve to define functors with arbitrary categories as codomain.
At this point, their only use is for \py{ar_factory} to define identity arrows, otherwise the codomain of the functor is defined implicitly by the codomain of the \py{ob} and \py{ar} mappings.

\begin{python}~\label{listing:Functor}
{\normalfont Outline of the \py{Functor} class.}
\begin{minted}{python}
@dataclass
class Functor:
    ob: dict[Ob, Ob]
    ar: dict[Box, Arrow]
    ob_factory, ar_factory = Ob, Arrow

    def __call__(self, other):
        if isinstance(other, Ob): return self.ob[other]
        if isinstance(other, Box):
            result = self.ar[other]  # This will allow some nice syntactic sugar.
            if not isinstance(result, self.ar_factory):
                result = self.ar_factory(result, self(other.dom), self(other.cod))
            return result
        if isinstance(other, Arrow):
            return self.ar_factory.id(self(other.dom)).then(
                *self(box) for box in other.boxes)
        raise TypeError
\end{minted}
\end{python}

\begin{example}
A typical DisCoPy script starts by defining objects and boxes:
\begin{minted}{python}
x, y, z = map(Ob, "xyz")
f, g, h = Box('f', x, y), Box('g', y, z), Box('h', z, x)
\end{minted}
We can define a simple relabeling functor from the free category to itself:
\begin{minted}{python}
F = Functor(
    ob={x: y, y: z, z: x},
    ar={f: g, g: h, h: f})
assert F(f >> g >> h) == F(f) >> F(g) >> F(h) == g >> h >> f
\end{minted}
We can interpret our arrows as Python functions:
\begin{minted}{python}
G = Functor(
    ob={x: int, y: Iterable, z: int},
    ar={f: range, g: sum, h: lambda n: n * (n - 1) // 2},
    ob_factory=type, ar_factory=Function)
assert G(f >> g)(42) == G(h)(42) == 861
\end{minted}
We can interpret our arrows as matrices:
\begin{minted}{python}
H = Functor(
    ob={x: 1, y: 2, z: 2},
    ar={f: [[0, 1]], g: [[0, 1], [1, 0]], h: [[1], [0]]},
    ob_factory=int, ar_factory=Matrix)
assert H(f >> g) == H(h).transpose()
\end{minted}
Provided we implement \py{dom}, \py{cod}, \py{id} and \py{then} for the \py{Functor} class, we can even build functors into $\mathbf{Cat}$, i.e. interpret arrows as functors:
\begin{minted}{python}
I = Functor(
    ob={x: Arrow, y: Arrow, z: Tensor},
    ar={f: F, g: H}, ar_factory=Functor)
assert I(f >> g)(h) == H(F(h)) == H(f)
\end{minted}
\end{example}

\begin{remark}
We have chosen to implement functors in terms of Python \py{dict} rather than functions mainly because the syntax looked better for small examples.
However, nothing prevents us from making the most of Python's \emph{duck typing}: if it quacks like a \py{dict} and it has a \py{__getitem__} method like a \py{dict}, it must be a \py{dict}.
Thus, we can define functors with domains that are not finitely generated, such as the identity functor on $\mathbf{Cat}$ or more concretely the evaluation functor for quantum gates parameterised by a continuous angle.
The only downside is that we cannot print, save or export such an infinitely generated functor, we can only apply to objects and arrows.

\begin{minted}{python}
dictOrCallable = lambda x, y: dict[x, y] | Callable[[x], y]
obData, arData = dictOrCallable(Ob, Ob), dictOrCallable(Box, Ar)

@dataclass
class Dict:
    inside: Callable
    __getitem__ = lambda self, key: self.inside[key]

class Functor(cat.Functor):
    def __init__(self, ob: obData, ar: arData, ob_factory=Ob, ar_factory=Arrow):
        if isinstance(ob, Callable): ob = Dict(ob)
        if isinstance(ar, Callable): ar = Dict(ar)
        super().__init__(ob, ar, ob_factory, ar_factory)

    id = lambda _: Functor(lambda x: x, lambda f: f)

    def then(self: Functor, other: Functor) -> Functor:
        ob, ar = ((lambda x: g[f[x]])
                  if isinstance(f, Dict) or isinstance(g, Dict)
                  else {x: g[f[x]] for x in f.keys()}
                  for f, g in [(self.ob, other.ob), (self.ar, other.ar)])
        return Functor(ob, ar, other.ob_factory, other.ar_factory)
\end{minted}
\end{remark}

\subsection{Quotient categories}

After free objects, another concept behind DisCoPy is that of a \emph{quotient object}.
Again, let's start with the example of a monoid $M$.
Suppose we're given a binary relation $R \sub M \times M$, then we can construct a quotient monoid $M / R$ with underlying set the equivalence classes of the smallest congruence generated by $R$.
That is, the smallest relation $(\sim_R) \sub M \times M$ such that:
\begin{itemize}
\item $x \sim_R y$ for all $(x, y) \in R$,
\item $x \sim_R x$ and if $x \sim_R y$ and $y \sim_R z$ then $x \sim_R z$,
\item if $x \sim_R x'$ and $y \sim_R y'$ then $x \times y \sim_R x' \times y'$.
\end{itemize}
The first point says that $R \sub (\sim_R)$.
The second says that $(\sim_R)$ is an equivalence relation.
The third says that $(\sim_R)$ is closed under products, it is equivalent to the substitution axiom: if $x \sim_R y$ then $a x b \sim_R a y b$ for all $a, b \in M$.
Explicitly, the congruence $(\sim_R)$ can be constructed in two steps: first, we define the rewriting relation $(\to_R) \sub M \times M$ where $a x b \to_R a y b$ for all $(x, y) \in R$ and $a, b \in M$.
Second, we define $(\sim_R)$ as the \emph{symmetric, reflexive, transitive closure} of the rewriting relation, i.e. two elements $x, y \in M$ are equal in $M / R$ iff they are in the same connected component of the undirected graph induced by $(\to_R) \sub M \times M$.
Now there is a homomorphism $q : M \to M / R$ which sends monoid elements to their equivalence class with the following property: for any homomorphism $f : M \to N$ with $x \sim_R y$ implies $f(x) = f(y)$, there is a unique $f' : M / R \to N$ with $f = q \fcmp f'$.
Intuitively, a homomorphism from a quotient $M / R$ is nothing more than a homomorphism from $M$ which respects the axioms $R$.
Up to isomorphism, we can construct any monoid $M$ as the quotient $X^\star / R$ of a free monoid $X^\star$: take $X = U(M)$ and $R = \{ (x y, z) \in X^\star \times X^\star \s \vert \s x \times y = z \in M \}$.

The pair $(X, R \sub X^\star \times X^\star)$ of a set of generating elements $X$ and a binary relation $R$ on its free monoid is called a \emph{presentation} of the monoid $M \simeq X^\star / R$.
Arguably, the most fundamental computational problem is the \emph{word problem for monoids}: given a presentation $(X, R)$ and a pair of lists $x, y \in X^\star$, decide whether $x = y$ in $X^\star / R$.
As mentioned in the introduction, it was shown to be equivalent to Turing's halting problem, and thus undecidable, by Post~\cite{Post47} and Markov~\cite{Markov47}.
The proof is straightforward: we can encode the tape alphabet and the states of a Turing machine in the set $X$ and its transition table into the relation $R$, then whether the machine halts reduces to deciding $x = y$ for $x$ and $y$ the initial and accepting configurations respectively: a proof of equality corresponds precisely to a run of the Turing machine.

The case of quotient categories is similar, only we need to take care of objects now.
Given a category $C$ and a family of binary relations $\{ R_{x,y} \sub C(x, y) \times C(x, y) \}_{x, y \in C_0}$, we can construct a quotient category $C / R$ with equivalence classes as arrows.
There is a functor $Q : C \to C / R$ sending each arrow to its equivalence class, and for any functor $F : C \to D$ with $(f, g) \in R_{x, y}$ implies $F(f) = F(g)$,
there is a unique $F' : C / R \to D$ with $F = Q \fcmp F'$.
Intuitively, a functor from a quotient category $C / R$ is nothing more than a functor from $C$ which respects the axioms $R$.
Again, any small category $C$ is isomorphic to the quotient $F(\Sigma) / R$ of a free category $F(\Sigma)$: take $\Sigma = U(C)$ and $R = \{ (f \fcmp g, h) \in F(\Sigma) \times F(\Sigma) \s \vert \s f \fcmp g = h \in C \}$.
The pair $(\Sigma, R \sub \coprod_{x, y \in \Sigma_0} \Sigma(x, y) \times \Sigma(x, y))$ is called a presentation of the category $C \simeq F(\Sigma) / R$.
Since monoids are just categories with one object, the word problem for categories will be just as undecidable as for monoids.

What does it mean to implement a quotient category in Python?
Since presentations of categories are as expressive as Turing machines, we might as well avoid solving the halting problem and just use a Python function to define equality of arrows.
Implementing a quotient category is nothing more than implementing a free category and an equality function that respects the axioms of a congruence.
One straightforward way is to define equality of arrows $f, g$ in a free category $F(\Sigma)$ to be the equality of their interpretation $\eval{f} = \eval{g}$ under a functor $\eval{-} : F(\Sigma) \to D$ into a concrete category $D$ where equality is decidable.
Another method is to define a \emph{normal form} method which takes an arrow and returns the representative of its equivalence class, then identity of arrow is identity of their normal forms.

\begin{example} \label{example:1-qubit-presentation}
Take the signature $\Sigma$ with one object $\Sigma_0 = \{ 1 \}$ and four arrows $\Sigma_1  = \{ Z, X, H, -1 \}$ for the Z, X and Hadamard gate and the global $(-1)$ phase.
Let's define the relation $R$ induced by:
\begin{itemize}
    \item $H \fcmp X = Z \fcmp H$ and $Z \fcmp X = (-1) \fcmp X \fcmp Z$,
    \item $f \fcmp f = \id(1)$ and $f \fcmp (-1) = (-1) \fcmp f$ for all $f \in \Sigma_1$.
\end{itemize}
The quotient $F(\Sigma) / R$ is a subcategory of the category $\mathbf{Circ}$ of quantum circuits, it is isomorphic to the quotient induced by the interpretation $\eval{-} : F(\Sigma) \to \mathbf{Mat}_\C$.
Suppose we're given a functor $\mathtt{cost} : F(\Sigma) \to \R^+$, we can define the normal form of a circuit $f$ to be the representative of its equivalence class with the lowest cost.
Thus, deciding equality of circuits reduces to solving circuit optimisation perfectly.
\end{example}

\subsection{Daggers, sums and bubbles}

We conclude this section by discussing three extra pieces of implementation beyond the basics of category theory: daggers, sums and bubbles.
A \emph{dagger} for a category $C$ can be thought of as a kind of time-reversal for arrows.
More precisely, a dagger is a contravariant endofunctor $\dagger : C \to C^{op}$, i.e. from the category to its opposite with $\dom$ and $\cod$ swapped, which is the identity on objects and an involution, i.e. $(\dagger) \fcmp (\dagger) = \id_\C$.
A $\dagger$-functor is a functor between $\dagger$-categories that commutes with the dagger, thus we get a category $\dagger-\mathbf{Cat}$.
For example, the conjugate transpose defines a dagger on the category $\mathbf{Mat}_\S$, the adjoint defines a dagger on the category $\mathbf{Circ}$ and the evaluation $\mathbf{Circ} \to \mathbf{Mat}_\S$ is a $\dagger$-functor.
The free $\dagger$-category is constructed as follows.
Define the functor $\dagger : \mathbf{Sig} \to \mathbf{Sig}$ which sends a signature $\Sigma$ to $\dagger(\Sigma)$ with
$\dagger(\Sigma)_0 = \Sigma_0$ and $\dagger(\Sigma)_1 = \{ -1, 1 \} \times \Sigma_1$ with $\dom(b, f) = \cod(f)$ if $b = -1$ else $\dom(f)$ and symmetrically for $\cod$.
Then the free dagger category is the quotient category $F(\dagger(\Sigma)) / R$ for the congruence generated by $(1, f) \fcmp (-1, f) \to_R \id(\dom(f))$ and $(-1, f) \fcmp (1, f) \to_R \id(f.cod)$.

DisCoPy implements free $\dagger$-categories by adding an attribute \py{is_dagger: bool} to boxes and a method \py{Arrow.dagger}, shortened to the postfix operator \py{[::-1]}, which reverses the order of boxes and negates \py{is_dagger} elementwise.
The normal form is computable in linear time but it has not been implemented yet.
In order to implement the syntactic sugar \py{f[::-1] == f.dagger()}, we need to override the \py{__getitem__} method.
In general, DisCoPy defines indexing \py{f[i]} and slicing \py{f[start:stop:step]} so that \py{f[key].boxes == f.boxes[key]} for any \py{key: int} and any \py{key: slice} with \py{key.step in (-1, 1, None)}.
Although the case of negative indices (i.e. counting backwards from the end of the list) is implemented in DisCoPy, its interaction with list reversal is too complex to be listed here.

\begin{python}
{\normalfont Implementation of free $\dagger$-categories and $\dagger$-functors.}
\begin{minted}{python}
class Arrow(cat.Arrow):
    def dagger(self):
        return self.upgrade(Arrow(
            self.cod, self.dom, [box.dagger() for box in self.boxes[::-1]]))

    def __getitem__(self, key: int | slice) -> Arrow:
        if isinstance(key, int): return self.upgrade(self.boxes[key])
        if key.step not in (-1, 1, None): raise IndexError
        if key.step == -1:
            for i in (key.start, key.stop):
                if i is not None and i < 0: raise NotImplementedError
            return self[key.stop + 1:key.start + 1].dagger()
        dom, cod = self[key.start].dom, self[key.stop].cod
        return self.upgrade(Arrow(dom, cod, self.boxes[key]))

class Box(cat.Box, Arrow):
    upgrade = Arrow.upgrade

    def __init__(self, name: str, dom: Ob, cod: Ob, is_dagger=False):
        self.is_dagger = is_dagger; cat.Box.__init__(self, name, dom, cod)

    def dagger(self):
        return Box(self.name, self.cod, self.dom, not self.is_dagger)

class Functor(cat.Functor):
    def __call__(self, other):
        if isinstance(other, Box) and other.is_dagger:
            return self(other.dagger()).dagger()
        return super().__call__(other)
\end{minted}
\end{python}

\begin{python}
{\normalfont Implementation of $\mathbf{Mat}_\S$ as a $\dagger$-category.}

\begin{minted}{python}
def transpose(self: Matrix) -> Matrix:
    inside = [[self[j][i] for j in range(self.dom)] for i in range(self.cod)]
    return Matrix(inside, self.cod, self.dom)

def map(self: Matrix, func: Callable[[Number], Number]) -> Matrix:
    inside = [list(map(func, row)) for row in self.inside]
    return Matrix(inside, self.dom, self.cod)

Matrix.transpose, Matrix.map = transpose, map
Matrix.conjugate = lambda self: self.map(lambda x: x.conjugate())
Matrix.dagger = lambda self: self.conjugate().transpose()
\end{minted}
\end{python}

\begin{example}
We can implement a simulator for $1$-qubit circuits as a $\dagger$-functor and check the equations given in example~\ref{example:1-qubit-presentation}.

\begin{minted}{python}
Circuit.eval = Functor(
    ob={Ob('1'): 2},
    ar={X: [[0, 1], [1, 0]]
        Y: [[0, -1j], [1j, 0]],
        Z: [[1, 0], [0, -1]],
        H: [[x / sqrt(2) for x in row] for row in [[1, 1], [1, -1]]]}
    ob_factory=int, ar_factory=Matrix)

assert (Z >> H).eval() == (H >> X).eval()
assert (Z >> X).eval() == (X >> Z).eval().map(lambda x: -x)

for gate in [H, Z, X]:
    assert (gate >> gate).eval() == Id.eval()

for gate in [X, Y, Z, H]:
    assert (gate >> gate[::-1]).eval() == Id.eval() == (gate[::-1] >> gate).eval()
\end{minted}
\end{example}

A category $C$ has \emph{sums}, or equivalently $C$ is \emph{commutative-monoid-enriched}, when it comes equipped with a commutative monoid $(+, 0)$ on each homset $C(x, y)$ such that $f \fcmp 0 = 0 = 0 \fcmp f$ and $(f + f') \fcmp (g + g') = f \fcmp g + f \fcmp g' + f' \fcmp g + f' \fcmp g'$ for all arrows $f, g, f', g'$.
A functor $F : C \to D$ between categories with sums is commutative-monoid-enriched when $F(0) = 0$ and $F(f + g) = F(f) + F(g)$.
For example, the category $\mathbf{Mat}_\S$ has sums given by elementwise addition of matrices.
A commutative-monoid-enriched category with one object is precisely a rig.
Given a signature $\Sigma$, we construct the free category with sums $F^+(\Sigma)$ by taking the free commutative monoid over each homset of $F(\Sigma)$, i.e. arrows $f : x \to y$ in $F^+(\Sigma)$ are \emph{bags} (also called \emph{multisets}) of arrows $f_i : x \to y$ in $F(\Sigma)$.

In DisCoPy, free categories with sums are implemented by \py{Sum}, a subclass of \py{Box} with an attribute \py{terms: list[Arrow]}.
The method \py{then} is straightforward: the composition of a sum is the sum of the compositions of its terms.
Defining equality requires some extra care however: we want an arrow to be equal to the sum of just itself.
Checking equality of bags is the same as checking equality of lists sorted by any arbitrary ordering.
DisCoPy functors are commutative-monoid-enriched, i.e. a formal sum of arrows can be interpreted as a concrete sum of matrices.

\begin{python}
{\normalfont Implementation of free sum-enriched categories and functors.}

\begin{minted}{python}
class Arrow(cat.Arrow):
    def __add__(self, other):
        self, other = map(Sum.upgrade, (self, other))
        return Sum(self.terms + other.terms, self.dom, self.cod)

    def __eq__(self, other):
        return other.terms == [self]\
            if isinstance(other, Sum) else super().__eq__(other)

    def then(self, other: Arrow) -> Arrow:
        return Sum.upgrade(self).then(other)\
            if isinstance(other, Sum) else super().then(other)

    @staticmethod
    def zero(dom: Ob, cod: Ob) -> Arrow: return Sum([], dom, cod)

    __lt__ = lambda self, other: hash(self) < hash(other)  # An arbitrary order.

class Sum(cat.Box, Arrow):
    def __init__(self, terms: list[Arrow], dom: Ob, cod: Ob):
        assert all(f.dom == dom and f.cod == cod for f in terms)
        self.terms, name = terms, "Sum({}, {}, [{}])".format(
            dom, cod, ", ".join(map(str, terms)))
        cat.Box.__init__(self, name, dom, cod)

    def __eq__(self, other):
        if isinstance(other, Sum):
            return (self.dom, self.cod, sorted(self.terms))\
                == (other.dom, other.cod, sorted(other.terms))
        return self.terms == [other]

    def upgrade(old: cat.Arrow) -> Sum:
        return old if isinstance(old, Sum) else Sum([old], old.dom, old.cod)

    def then(self, other):
        terms = [f.then(g) for f in self.terms for g in Sum.upgrade(other).terms]
        return Sum(terms, self.dom, other.cod)

class Functor(cat.Functor):
    def __call__(self, other):
        if isinstance(other, Sum):
            unit = self.ar_factory.zero(self(other.dom), self(other.cod))
            return sum([self(f) for f in other.terms], unit)
        return super().__call__(other)
\end{minted}
\end{python}

\begin{python}
{\normalfont Implementation of $\mathbf{Mat}_\S$ as a category with sums.}

\begin{minted}{python}
def __add__(self: Matrix, other: Matrix) -> Matrix:
    inside = [[x + y for x, y in zip(u, v)]
              for u, v in zip(self.inside, other.inside)]
    return Matrix(inside, self.dom, self.cod)

def zero(dom: int, cod: int) -> Matrix:
    return Matrix([[0 for _ in range(cod)] for _ in range(dom)], dom, cod)
\end{minted}
\end{python}

A \emph{bubble} on a (subcategory of a) category $C$ is a pair of unary operators $b_\dom, b_\cod : C_0 \to C_0$ on objects and a unary operator between homsets $b : C(x, y) \to C(b_\dom(x), b_\cod(y))$ for (some) pairs of objects $x, y \in C_0$.
Given a signature $\Sigma$ and a pair $b_\dom, b_\cod : C_0 \to C_0$, we construct the free category with bubbles $F(\Sigma^b)$ by induction on the maximum level $n$ of bubble nesting: take the signature $\Sigma^b = \bigcup_{n \in \N} \Sigma^b_n$
for $\Sigma^b_0 = \Sigma$ and $\Sigma^b_{n + 1} = \Sigma + \{ b(f) \ \vert \ f \in F(\Sigma^b_n) \}$.
That is, box in $\Sigma^b$ is a box in $\Sigma^b_{n}$ for some $n \in \N$.
A box in $\Sigma^b_{n}$ is either a box in $\Sigma$ or an arrow $f : x \to y$ in $F(\Sigma^b_{n - 1})$ that we have put inside a bubble $b(f) : b_\dom(x) \to b_\cod(y)$.

\begin{example}
A functor between two categories $C$ and $D$ can be seen as a bubble on their disjoint union $C + D$.
Thus, we can define a bubble-preserving functor $F^b(C + D) \to C + D$ which interprets arrows with bubbles as functor application.
These functor bubbles have also been called \emph{functorial boxes}~\cite{Mellies06}.
\end{example}

\begin{example}
An \emph{exponential rig} is a one-object category $\S$ with sums and a bubble $\exp : \S \to \S$ which is a homomorphism from sum to product, i.e. $\exp(a + b) = \exp(a) \exp(b)$ and $\exp(0) = 1$.
Any rig $\S$ is an exponetial rig by taking $\exp(a) = 1$ for all $a \in \S$.
Non-trivial examples include the complex numbers as well as the Boolean rig with negation.
Thus, exponential rigs provide enough syntax to define the matrices of most quantum gates, as well as any propositional logic formula.
\end{example}

\begin{example}
Matrix exponential is a bubble on the subcategory of square matrices, with the property that $\exp(f + g) = \exp(f) \fcmp \exp(g)$ whenever $f \fcmp g = g \fcmp f$.
Also, any function $\S \to \S$ yields a bubble on $\mathbf{Mat}_\S$ given by element-wise application.
For example, we can define a bubble on the category $\mathbf{Mat}_\B$ of Boolean matrices which sends each matrix $f$ to its entrywise negation $\bar{f}$.
\end{example}

DisCoPy implements free bubbles with \py{Bubble}, a subclass of \py{Box} which we attach to the arrow class with \py{Arrow.bubble = Bubble}.
\py{Bubble} has attributes \py{inside: Arrow}, \py{dom: Ob} and \py{cod: Ob} as well as \py{name: str}.
DisCoPy functors interpret bubbles with \py{name = "method"} as the application of \py{ar_factory.method}.
The resulting syntax with bubbles is strictly more expressive than that of free categories alone.
For example, element-wise negation cannot be expressed as a composition: there is no matrix $N : x \to x$ in $\mathbf{Mat}_\B$ such that $N \fcmp f = \bar{f}$ for all $f : x \to y$.
This is also the case for the element-wise application of any non-linear function such as the rectified linear units (ReLU) used in machine learning.
As we will discuss in Chapter~\ref{chapter-3:diag-diff}, differentiation of parameterised matrices cannot be expressed as a composition either, but it is a unary operator between homsets, i.e. a bubble.

\begin{python}
{\normalfont Implementation of free categories with bubbles and their functors.}

\begin{minted}{python}
class Bubble(Box):
    def __init__(self, inside: Arrow, dom=None, cod=None, name="bubble"):
        self.inside, dom, cod = inside, dom or inside.dom, cod or inside.cod
        name = "Bubble({}, {}, {}, {})".format(inside, dom, cod, name)
        super().__init__(name, dom, cod)

Arrow.bubble = Bubble

class Functor(cat.Functor):
    def __call__(self, other):
        if isinstance(other, Bubble):
            return getattr(self.ar_factory, other.name)(
                self(other.inside), self(other.dom), self(other.cod))
        return super().__call__(other)
\end{minted}
\end{python}

\begin{example}
We can encode the architecture of a neural network as an arrow with sums and bubbles, encoding vector addition and non-linear activation function respectively.
The evaluation of the neural network on some input vector for some parameters is given by the application of a sum-and-bubble-preserving functor into $\mathbf{Mat}_\R$.
The hyper-parameters (i.e. the number of neurons at each layer) are given by the image of the functor on objects.

\begin{minted}{python}
Matrix.dtype, Matrix.ReLU = float, lambda self, _, _: self.map(lambda x: max(x, 0))

vector, bias = Box('vector', x, y), Box('bias', x, x)
ones, weights = Box('ones', x, y), Box('weights', y, z)
network = ((vector + (bias >> ones)) >> weights).bubble(name="ReLU")

F = Functor(
    ob={x: 1, y: 4, z: 2},
    ar={vector: [[1.2, -2.3, 3.4, -4.5]],
        bias: [[-3.14]], ones: [[1, 1, 1, 1]]
        weights: [[5.6, -6.7, 7.8, -8.9],
                  [9.0, -0.1, 2.3, -3.4]]})

assert F(network) == F(vector).map(lambda x: x + F(bias)[0][0])\
                              .then(F(weights)).map(lambda x: max(0, x))
\end{minted}
\end{example}

\begin{example}
We can implement propositional logic with boxes as propositions, composition as conjunction, sum as disjunction and bubble as negation.
The evaluation of a formula in a model corresponds to the application of a sum-and-bubble-preserving functor into $\mathbf{Mat}_\B(1, 1)$.

\begin{minted}{python}
Matrix.dtype, Matrix._not = B, lambda self, _, _: self.map(lambda x: not x)

class Formula(Arrow):
    _not = lambda self: self.bubble(name="_not")

    @staticmethod
    def model(data: dict[Proposition, bool]):
        return Functor(ob={Ob('1'): 1}, ar={p: [[data[p]]] for p in data},
                       ar_factory=Matrix)

class Proposition(Box, Formula):
    def __init__(self, name): Box.__init__(self, name, Ob('1'), Ob('1'))

p, q = map(Proposition, "pq")
p_implies_q = (q._not() >> p)._not()
not_p_or_q = p._not() + q

for a, b in itertools.product([0, 1], [0, 1]):
    F = Formula.model({p: a, q: b})
    assert F(p_implies_q) == not (not F(q) and F(p))\
        == F(not_p_or_q) == not F(p) or F(q)
\end{minted}
\end{example}

\begin{remark}
The constructions for dagger, sums and bubbles all commute with each other.
Moreover, there is cube of faithful functors which embed free categories in free $\dagger$-categories with sums and bubbles.
Thus, they are all implemented by default in the same class \py{Arrow}.
\end{remark}
