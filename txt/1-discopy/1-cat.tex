%!TEX root = ../../THESIS.tex

\section{Categories in Python} \label{section:cat}

What are categories and how can they be useful to the Python programmer?
This section will answer this question by taking the standard mathematical definitions and breaking them into \emph{data}, which can be translated into Python code, and \emph{axioms}, which cannot be formally verified in Python, but can be translated into test cases.
The data for a category is given by a tuple $C = (C_0, C_1, \dom, \cod, \id, \then)$ where:
\begin{itemize}
\item $C_0$ and $C_1$ are classes of \emph{objects} and \emph{arrows} respectively,
\item $\dom, \cod : C_1 \to C_0$ are functions called \emph{domain} and \emph{codomain},
\item $\id : C_0 \to C_1$ is a function called \emph{identity},
\item $\then : C_1 \times C_1 \to C_1$ is a partial function called \emph{composition}, denoted by $(\fcmp)$.
\end{itemize}
Given two objects $x, y \in C_0$, the set\footnote
{We will assume that this forms a set rather than a proper class, i.e. we will only work with \emph{locally small} categories.}
$C(x, y) = \{f \in C_1 \s \vert \s \dom(f), \cod(f) = x, y \}$ is called a \emph{homset} and we write $f : x \to y$ whenever $f \in C(x, y)$.
We denote the composition $\then(f, g)$ by $f \fcmp g$, translated to \py{f >> g} or \py{g << f} in Python.
The axioms for the category $C$ are the following:
\begin{itemize}
\item $\id(x) : x \to x$ for all objects $x \in C_0$,
\item for all arrows $f, g \in C_1$, the composition $f \fcmp g$ is defined iff $\cod(f) = \dom(g)$, moreover we have $f \fcmp g : \dom(f) \to \cod(g)$,
\item $\id(\dom(f)) \fcmp f = f = f \fcmp \id(\cod(f))$ for all arrows $f \in C_1$,
\item $f \fcmp (g \fcmp h) = (f \fcmp g) \fcmp h$ whenever either side is defined for $f, g, h \in C_1$.
\end{itemize}

Note that we play with the overloaded meaning of the word \emph{class}: we use it to mean both a mathematical collection that need not be a set, and a Python class with its methods and attributes.
Reading it in the latter sense, $\dom$ and $\cod$ are \emph{attributes} of the arrow class, $\then$ is a \emph{method}, $\id$ is a \emph{static method}.
Thus, the Python implementation of a category is nothing more than a pair of classes \py{Ob} and \py{Arrow} for objects and arrows, together with four methods $\dom, \cod, \then$ and $\id$ .
The \py{Category} class is nothing more than a named tuple with two attributes \py{ob} and \py{ar} for its object and arrow class respectively.
The axioms can be implemented as (necessarily non-exhaustive) software tests, however Python has no formal semantics so there is no hope for to formally verify them.

The data for a \emph{functor} $F : C \to D$ between two categories $C$ and $D$ is given by a pair of overloaded functions $F : C_0 \to D_0$ and $F : C_1 \to D_1$ such that:
\begin{itemize}
    \item $F(\dom(f)) = \dom(F(f))$ and $F(\cod(f)) = \cod(F(f))$ for all $f \in C_1$,
    \item $F(\id(x)) = \id(F(x))$ and $F(f \fcmp g) = F(f) \fcmp F(g)$ for all $x \in C_0$ and $f, g \in C_1$.
\end{itemize}
Thus, implementing a functor in Python amounts to implementing a class with the magic method \py{__call__} of the appropriate type, and then implementing software tests to check that the axioms hold.

The data for a \emph{transformation} $\alpha : F \to G$ between two parallel functors $F, G : C \to D$ is given by a function from objects $x \in C_0$ to components $\alpha(x) : F(x) \to G(x)$ in $D$.
A \emph{natural transformation} is one where $\alpha(x) \fcmp G(f) = F(f) \fcmp \alpha(y)$ for all arrows $f : x \to y$ in $C$.
Again, implementing a transformation amounts to implementing a class with a \py{__call__} method of the appropriate type, checking that a transformation is natural cannot be done formally in Python.
The class templates listed below summarise the required data for categories, functors and transformations.

\begin{python}\label{listing:abstract classes}
{\normalfont Class templates for categories, functors and transformations.}

\begin{minted}{python}
from __future__ import annotations

class Ob: ...

class Arrow:
    dom: Ob
    cod: Ob

    @staticmethod
    def id(x: Ob) -> Arrow: ...
    def then(self, other: Arrow) -> Arrow: ...

@dataclass
class Category:
    ob: type = Ob
    ar: type = Arrow

class Functor:
    dom: Category
    cod: Category

    @overload
    def __call__(self, x: Ob) -> Ob: ...

    @overload
    def __call__(self, f: Arrow) -> Arrow: ...

class Transformation:
    dom: Functor
    cod: Functor

    def __call__(self, x: Ob) -> Arrow: ...
\end{minted}
\end{python}

\begin{remark}
Throughout the thesis we use the postponed evaluation of annotations introduced in Python \py{3.7}~\cite{Langa17}.
Python cannot statically check that arrow composition is well-typed as this would require some form of dependent types, the best we can do is raise an \py{AssertionError} at runtime.
\end{remark}

\begin{example}
When the class of objects and arrows are in fact sets, $C$ is called a \emph{small category}.
For example, the category $\mathbf{FinSet}$ has the set of all finite sets as objects and the set of all functions between them as arrows.
This time equality of functions between finite sets is decidable, so we can write unit tests that check that the axioms hold on specific examples.
\end{example}

\begin{example}
When the class of objects and arrow are finite sets, we can draw the category as a directed multigraph with objects as nodes and arrows as edges, together with the list of equations between paths.
A functor $F : C \to D$ from such a finite category $C$ is called a \emph{commutative diagram} in $D$.
One commutative diagram can state a large number of equations, which can be read by \emph{diagram chasing}.
\end{example}

\begin{example}
A monoid is the same as a category with one object, i.e. every arrow (element) can be composed with (multiplied by) every other.
A preorder, i.e. a set with a reflexive transitive relation, is the same as a category with at most one arrow $x \leq y$ between any two objects $x$ and $y$.
Functors between monoids are the same as homomorphisms, functors between preorders are monotone functions.
\end{example}

\begin{example}
Just about any class of mathematical structures will be the objects of a category with the transformations between them as arrows: the category $\mathbf{Set}$ of sets and functions, the category $\mathbf{Mon}$ of monoids and homomorphisms, the category $\mathbf{Preord}$ of preorders and monotone functions, the category $\mathbf{Cat}$ of small categories and functors, etc.
There are embedding (i.e. injective on objects and arrows) functors from $\mathbf{Mon}$ and $\mathbf{Preord}$ to $\mathbf{Cat}$, i.e. preorders and monoids form a subcategory of $\mathbf{Cat}$.
There is a functor from $\mathbf{Cat}$ to $\mathbf{Preord}$ called the preorder collapse which sends a category $C$ to the preorder given by $x \leq y$ iff there is an arrow $f \in C(x, y)$, i.e. we forget the difference between parallel arrows.
There is a faithful (i.e. injective on homsets) functor $U : \mathbf{Mon} \to \mathbf{Set}$ called the \emph{forgetful functor} which sends monoids to their underlying set and homomorphisms to functions.
\end{example}

\begin{example}
In the same way that there is a set $Y^X$ of functions $X \to Y$ for any two sets $X$ and $Y$, for any two categories $C$ and $D$ there is a category $D^C$ with functors $C \to D$ as objects and natural transformations as arrows.
\end{example}

\begin{example}\label{ex:python categories}
We can define the category $\mathbf{Pyth}$ with objects the class of all Python types and arrows the class of all Python functions.
Domain and codomain could be extracted from type annotations, but instead we implement a class \py{Function} with attributes \py{dom: Ty} and \py{cod: Ty} as well as \py{inside: Callable}.
Identity may given by \py{lambda *xs: xs} and the composition by \py{lambda f, g: lambda *xs: f(*g(*xs)))}. (The star takes care of functions with multiple arguments.)
However, equality of functions in Python is undecidable so there will be no way to check the axioms hold in general.

Endofunctors $\mathbf{Pyth} \to \mathbf{Pyth}$ can be thought of as data containers, see Milewski~\cite{Milewski14} for a discussion in the case of Haskell.
For example, we can define a $\mathbf{List}$ functor which sends a type \py{t} to \py{List[t]} and a function \py{f} to \py{lambda *xs: map(f, xs)}.
There is a natural transformation $\eta : \mathbf{Id} \to \mathbf{List}$ from the obvious identity functor, implemented by the built-in function \py{id}.
Its components send objects \py{x : t} of any type \py{t} to the singleton list \py{[x] : List[t]}.
\end{example}

\begin{python}
{\normalfont Syntactic sugar for composition.}

\py{Composable} implements the syntactic sugar \py{self >> other} (and \py{self << other}) for composition in diagrammatic order (and its opposite) as well as \py{n * self} for $n$-fold composition.
It is an abstract class, i.e. it it subclassed but never instantiated.
The higher-order function \py{inductive} takes a binary method and makes it $n$-ary by using a left fold, we use it as a decorator.

\begin{minted}{python}
class Composable:
    __rshift__ = __llshift__ = lambda self, other: self.then(other)
    __lshift__ = __lrshift__ = lambda self, other: other.then(self)
    __rmul__ = lambda self, n: self.id(self.dom).then(*n * (self, ))

def inductive(method):
    def result(self, *others):
        if not others: return self
        if len(others) == 1: return method(self, others[0])
        if len(others) > 1: return method(method(self, others[0]), *others[1:])
    return result
\end{minted}
\end{python}

\begin{python}\label{listing:Function}
{\normalfont Implementation of the category $\mathbf{Pyth}$ with \py{type} as objects and \py{Function} as arrows.}

\begin{minted}{python}
@dataclass
class Function(Composable):
    inside: Callable
    dom: type
    cod: type

    @staticmethod
    def id(x: type) -> Function:
        return Function(lambda *xs: xs, x, x)

    @inductive
    def then(self, other: Function) -> Function:
        inside = lambda *xs: other(*tuple(self(*xs)))
        return Function(inside, self.dom, other.cod)

    def __call__(self, *xs): return self.inside(*xs)
\end{minted}
\end{python}

\begin{example}
The following commutative diagram denotes a functor $3 \to \mathbf{Pyth}$ from the finite category $3$ with three objects $\{ 0, 1, 2 \}$ and three non-identity arrow $f : 0 \to 1, g : 1 \to 2$ and $h : 0 \to 2$, with the only non-trivial composition $f \fcmp g = h$.
\[ \begin{tikzcd}
\py{int}
\ar{rrrrrr}{\py{lambda n: n * (n - 1) // 2}}
\ar{rrrd}[']{\py{range}}
& & & & & & \py{int} \\
& & & \py{Iterable}
\ar{urrr}[']{\py{sum}} & & &
\end{tikzcd}
\]
It is read as the equation \py{sum(range(n)) = n * (n - 1) // 2}.
\end{example}

\begin{example}
The category $\mathbf{Mat}_\S$ has natural numbers as objects and $n \times m$ matrices with values in $\S$ as arrows $n \to m$.
The identity and composition are given by the identity matrix and matrix multiplication respectively.
In order for matrix multiplication to be well-defined and for $\mathbf{Mat}_\S$ to be a category, the scalars $\S$ should have at least the structure of a \emph{rig} (a riNg without Negatives, also called a \emph{semiring}): a pair of monoids $(\S, +, 0)$ and $(\S, \times, 1)$ with the first one commutative and the second a homomorphism for the first, i.e. $a \times 0 = 0 = 0 \times a$ and $(a + b) \times (c + d) = a c + a d + b c + b d$.
The category $\mathbf{Mat}_\C$ is equivalent to the category of finite dimensional vector spaces and linear maps.
When the scalars are Booleans with disjunction and conjunction as addition and multiplication, the category $\mathbf{Mat}_\B$ is equivalent to the category of finite sets and relations.
There is a faithful functor $\mathbf{FinSet} \to \mathbf{Mat}_\B$ which sends finite sets to their cardinality and functions to their graph.
\end{example}

\begin{python}\label{listing:matrix}
{\normalfont Implementation of $\mathbf{Mat}_\S$ with \py{int} as objects and \py{Matrix[dtype]} as arrows.}

\begin{minted}{python}
@dataclass
class Matrix(Composable):
    dom: int
    cod: int
    inside: list[list[dtype]]

    dtype = int

    def __class_getitem__(cls, dtype):
        class C(cls): pass
        C.dtype = dtype
        return C

    def __init__(self, inside: list[list[Number]], dom: int, cod: int):
        self.dom, self.cod = dom, cod
        self.inside = [list(map(self.dtype, row)) for row in inside]

    @classmethod
    def id(cls, x: int) -> Matrix:
        return cls([[i == j for i in range(x)] for j in range(x)], x, x)

    @inductive
    def then(self, other: Matrix) -> Matrix:
        inside = [[sum([self[i][j] * other[j][k] for j in range(other.dom)])
                   for k in range(other.cod)] for i in range(self.dom)]
        return type(self)(inside, self.dom, other.cod)

    def __getitem__(self, key: int) -> Matrix:
        if self.dom == 1: return Matrix([[self.inside[0][key]]], 1, 1)
        return Matrix([self.inside[key]], 1, self.cod)

    for attr in ("__bool__", "__int__", "__float__", "__complex__"):
        def method(self):  # Downcasting a 1 by 1 Matrix to a scalar.
            assert self.dom == self.cod == 1
            return getattr(self[0][0], attr)()
        setattr(Matrix, attr, method)
\end{minted}

Subscriptable types such as \py{list[list[int]]} implemented by the magic method \py{__class_getitem__} are a new feature of Python \py{3.10}~\cite{Levkivskyi17}.
By default, we fix \py{Matrix = Matrix[int]}.
We can get Boolean, real and complex matrices with \py{Matrix[bool]}, \py{Matrix[float]} and \py{Matrix[complex]} respectively.
Note that this implementation is not meant to be efficient, rather it helps in making the thesis self-contained.
As we will mention in section~\ref{subsection:hypergraph-vs-premonoidal}, DisCoPy interfaces with NumPy~\cite{VanDerWaltEtAl11} for efficient matrix multiplication.
\end{python}

\begin{example}
The category $\mathbf{Circ}$ has natural numbers as objects and $n$-qubit quantum circuits as arrows $n \to n$.
There is a functor $\mathtt{eval} : \mathbf{Circ} \to \mathbf{Mat}_\C$ which sends $n$ qubits to $2^n$ dimensions and evaluates each circuit to its unitary matrix.
\end{example}

\subsection{Free categories}\label{subsection:free-categories}

The main principles behind the implementation of DisCoPy follow from the concept of a \emph{free object}.
Let's start from a simple example.
Given a set $X$, we can construct a monoid $X^\star$ with underlying set $\coprod_{n \in \N} X^n$ the set of all finite lists with elements in $X$.
The associative multiplication is given by list concatenation $X^m \times X^n \to X^{m + n}$ and the unit is given by the empty list denoted $1 \in X^0$.
Given a function $f : X \to Y$, we can construct a homomorphism $f^\star : X^\star \to Y^\star$ defined by element-wise application of $f$ (this is what the built-in \py{map} does in Python).
We can easily check that $(f \fcmp g)^\star = f^\star \fcmp g^\star$ and $(\id_X)^\star = \id_{X^\star}$.
Thus, we have defined a functor $F : \mathbf{Set} \to \mathbf{Mon}$.

Why is this functor so special? Because it is the \emph{left adjoint} to the forgetful functor $U : \mathbf{Mon} \to \mathbf{Set}$.
An \emph{adjunction} $F \dashv U$ between two functors $F : C \to D$ and $U : D \to C$ is a pair of natural transformations $\eta : \id_C \to F \fcmp U$ and $\epsilon : U \fcmp F \to \id_D$ called the \emph{unit} and \emph{counit} respectively.
In the case of lists, we already mentioned the unit in example~\ref{ex:python categories}: it is the function that sends every object to a singleton list.
For a monoid $M$, the counit $\epsilon(M) : F(U(M)) \to M$ is the monoid homomorphism that takes lists of elements in $M$ and multiplies them.
We can easily check that these two transformations are indeed natural, thus we get that \emph{lists are free monoids}.
This may be taken as a mathematical explanation for why lists are so ubiquitous in programming.
Another equivalent definition of adjunction is in terms of an isomorphism $C(x, U(y)) \simeq D(F(x), y)$ which is natural\footnote
{The isomorphism $C(x, U(y)) \simeq D(F(x), y)$ is natural in $x$ if it is a natural transformation between the two functors $C(-, U(y)), D(F(-), y) : C \to \mathbf{Set}$.}
in $x \in C_0$ and $y \in D_0$.
In the adjunction for lists, functions $X \to U(M)$ from a set $X$ to the underlying set of a monoid $M$ are in a natural one-to-one correspondance with monoid homomorphisms $X^\star \to M$.
To define a homomorphism from a free monoid, it is sufficient to define the image of each generating element.

Now we want to play the same game with categories instead of monoids.
We can define a forgetful functor $U : \mathbf{Cat} \to \mathbf{Set}$ which sends a small category $C$ to its set of objects $C_0$, and its left adjoint $F : \mathbf{Set} \to \mathbf{Cat}$ which sends a set to the \emph{discrete category} with its elements as objects and only identity arrows.
However, this is a rather boring construction because forgetting the arrows of a categories is too much: the forgetful functor $U$ is not faithful.
Instead, we need to replace the category of sets with the category of \emph{signatures}.
The data for a signature is given by a tuple $\Sigma = (\Sigma_0, \Sigma_1, \dom, \cod)$ where:
\begin{itemize}
    \item $\Sigma_0$ is a set of \emph{generating objects},
    \item $\Sigma_1$ is a set of \emph{generating arrows}, which we will also call \emph{boxes},
    \item $\dom, \cod : \Sigma_1 \to \Sigma_0$ are the domain and codomain.
\end{itemize}
A morphism of signatures $f : \Sigma \to \Gamma$ is a pair of overloaded functions $f : \Sigma_0 \to \Gamma_0$ and $f : \Sigma_1 \to \Gamma_1$ such that $f \fcmp \dom = \dom \fcmp f$ and $f \fcmp \cod = \cod \fcmp f$.
Thus, signatures and their morphisms form a category $\mathbf{Sig}$ and there is a faithful functor $U : \mathbf{Cat} \to \mathbf{Sig}$ which sends a category to its underlying signature: it forgets the identity and composition.
Signatures may be thought of as directed multigraphs \emph{with an attitude}~\cite{NLab}.
Given a signature $\Sigma$, we can define a category $F(\Sigma)$ with nodes as objects and \emph{paths as arrows}.
More precisely, an arrow $f : x \to y$ is given by a length $n \in \N$ and a list $f_1, \dots, f_n \in \Sigma_1$ with $\dom(f_1) = x$, $\cod(f_n) = y$ and $\cod(f_i) = \dom(f_{i + 1})$ for all $i < n$.
Given a morphism of signatures $f : \Sigma \to \Gamma$, we get a functor $F(f) : F(\Sigma) \to F(\Gamma)$ relabeling boxes in $\Sigma$ by boxes in $\Gamma$.
Thus, we have defined a functor $F : \mathbf{Sig} \to \mathbf{Cat}$, it remains to show that it indeed forms an adjunction $F \dashv U$.
This is very similar to the monoid case: the unit sends a box in a signature to the path of just itself, the counit sends a path of arrows in a category to their composition.
Equivalently, we have a natural isomorphism $\mathbf{Cat}(F(\Sigma), C) \simeq \mathbf{Sig}(\Sigma, U(C))$: to define a functor $F(\Sigma) \to C$ from a free category is the same as to define a morphism of signatures $\Sigma \to U(C)$.

If lists are such fundamental data structures because they are free monoids, we argue that the arrows of free categories should be just as fundamental: they capture the basic notion of \emph{data pipelines}.
Free categories are implemented in the most basic module of DisCoPy, \py{discopy.cat}, which is sketched in listing~\ref{listing:cat.py}.

\begin{python}~\label{listing:cat.py}
{\normalfont Implementation of the free category $F(\Sigma)$ with $\Sigma_0 = \py{Ob}$ and $\Sigma_1 = \py{Box}$.}

\begin{minted}{python}
@dataclass
class Ob:
    name: str
    __str__ = lambda self: self.name

@dataclass
class Arrow(Composable):
    inside: tuple[Arrow, ...]
    dom: Ob
    cod: Ob

    @classmethod
    def cast(cls, old: Arrow) -> Arrow:
        return old if isinstance(old, cls) else cls(old.inside, old.dom, old.cod)

    @classmethod
    def id(cls, x: Ob) -> Arrow:
        return cls.cast(Arrow((), x, x))

    def then(self, *others: Arrow) -> Arrow:
        for f, g in zip((self, ) + others, others): assert f.cod == g.dom
        dom, cod = self.dom, others[-1].cod if others else self.cod
        inside = self.inside + sum([other.inside for other in others], ())
        return self.cast(Arrow(inside, dom, cod))

    __len__ = lambda self: len(self.inside)
    __str__ = lambda self: ' >> '.join(map(str, self.inside))\
        if self.inside else '{}.id({})'.format(type(self).__name__, self.dom)

@dataclass
class Box(Arrow):
    cast = Arrow.cast

    def __init__(self, name: str, dom: Ob, cod: Ob):
        self.name = name
        super().__init__((self, ), dom, cod)

    def __eq__(self, other):
        if isinstance(other, Box):
            return (self.name, self.dom, self.cod)\
                == (other.name, other.dom, other.cod)
        return isinstance(other, Arrow) and other.inside == (self, )

    __str__ = lambda self: self.name
    __hash__ = lambda self: hash(repr(self))
\end{minted}
\end{python}

The classes \py{Ob} and \py{Arrow} for objects and arrows are implemented in a straightforward way, using the \py{dataclass} decorator to avoid the bureaucracy of defining initialisation, equality, setc.
We define the method \py{__str__} so that \py{eval(str(f)) == f} for all \py{f: Arrow}, provided that the names of all objects and boxes are in scope.
The attribute \py{inside} holds the list of generating arrows, which we store as an immutable \py{tuple} rather than a mutable \py{list}.
The method \py{Arrow.then} accepts any number of arrows \py{others}, which will prove useful when defining functors.
The \py{Box} class requires more attention: a box \py{f = Box('f', x, y)} is an arrow with the list of just itself as boxes, i.e. \py{f.inside == (f, )}.
For the axiom \py{f >> f.id(y) == f == f.id(x) >> f} to hold, we need to make sure that \py{f == Arrow((f, ), x, y)}, i.e. a box is equal to the arrow with just itself as boxes.
The main subtlety in the implementation is the class method \py{cast} which takes an \py{old: Arrow} as input and returns a new member of a given \py{cls}, subclass of \py{Arrow}.
This allows the composition of arrows in a subclass to remain within the subclass, without having to rewrite the method \py{then}.
This means we need to make \py{Arrow.id} a \py{classmethod} as well so that it can call \py{cast} and return an arrow of the appropriate subclass.
We also need to fix \py{Box.cast = Arrow.cast}: when we compose a box then an arrow, we want to return a new arrow object, not a box.

\begin{example}\label{example:Circuit}
We can define \py{Circuit} as a subclass of \py{Arrow} and \py{Gate} as a subclass of \py{Circuit} and \py{Box} defined by a name and a number of qubits.

\begin{minted}{python}
class Circuit(Arrow): pass

class Gate(Box, Circuit):
    cast = Circuit.cast

X, Y, Z, H = [Gate(name, Ob('1'), Ob('1')) for name in "XYZH"]

assert (X >> Y) >> Z == X >> (Y >> Z) and X >> Ob('1') == X == Ob('1') >> X
assert isinstance(Circuit.id(Ob('1')), Circuit) and isinstance(X >> Y, Circuit)
\end{minted}
\end{example}

The \py{Functor} class listed in \ref{listing:Functor} has two mappings \py{ob} and \py{ar} as attributes, from objects to objects and from boxes to arrows respectively.
The domain of the functor is implicitly defined as the free category generated by the domain of the \py{ob} and \py{ar} mappings.
The optional arguments \py{dom} and \py{cod} allow to define functors with arbitrary categories as domain and codomain, a \py{Category} is nothing more than a pair of types for its objects and arrows.
For now we only use \py{cod} to define the image of identity arrows, otherwise the (co)domain of the functor is defined implicitly as the (co)domain of the \py{ob} and \py{ar} mappings.

We have chosen to implement functors in terms of Python \py{dict} rather than functions mainly because the syntax looked better for small examples.
However, nothing prevents us from making the most of Python's \emph{duck typing}: if it quacks like a \py{dict} and if it has a \py{__getitem__} method, we can use it to define functors like a \py{dict}.
Thus, we can define functors with domains that are not finitely generated, such as the identity functor or more concretely the evaluation functor for quantum gates parameterised by a continuous angle.
An equivalent solution is to subclass \py{Functor} and override its \py{__call__} method directly.
The only downside is that we cannot print, save or check equality for such functors, we can only apply them to objects and arrows.

\begin{python}~\label{listing:Functor}
{\normalfont Implementation of $\mathbf{Cat}$ with \py{Category} as objects and \py{Functor} as arrows.}

\begin{minted}{python}
class DictOrCallable:
    def __class_getitem__(_, source, target):
        return dict[source, target] | Callable[[source], target]

@dataclass
class FakeDict:
    inside: Callable
    __getitem__ = lambda self, key: self.inside(key)

@dataclass
class Functor(Composable):
    ob: dictOrCallable[Ob, Ob]
    ar: dictOrCallable[Box, Ar]
    dom: Category = Category(Ob, Arrow)
    cod: Category = Category(Ob, Arrow)

    def __init__(self, ob, ar, dom, cod):
        ob, ar = (d if hasattr(d, "__getitem__") else FakeDict(d) for d in (ob, ar))
        self.ob, self.ar, self.dom, self.cod = ob, ar, dom, cod

    def __call__(self, other: Ob | Arrow) -> Ob | Arrow:
        if isinstance(other, Ob): return self.ob[other]
        if isinstance(other, Box):
            result = self.ar[other]
            if isinstance(result, self.cod.ar): return result
            # This allows some nice syntactic sugar for the ar mapping.
            return self.cod.ar(result, self(other.dom), self(other.cod))
        if isinstance(other, Arrow):
            base_case = self.cod.ar.id(self(other.dom))
            return base_case.then(*self(box) for box in other.inside)
        raise TypeError

    @classmethod
    def id(cls, x: Category) -> Functor:
        return cls(lambda obj: obj, lambda box: box, dom=x, cod=x)

    @inductive
    def then(self: Functor, other: Functor) -> Functor:
        assert self.cod == other.dom
        ob, ar = (
            {x: g[f[x]] for x in f} if hasattr(f, "__iter__") else (lambda x: g[f[x]])
            for f, g in [(self.ob, other.ob), (self.ar, other.ar)])
        return type(self)(ob, ar, self.dom, other.cod)
\end{minted}
\end{python}

\begin{example}
A typical DisCoPy script starts by defining objects and boxes:
\begin{minted}{python}
x, y, z = map(Ob, "xyz")
f, g, h = Box('f', x, y), Box('g', y, z), Box('h', z, x)
\end{minted}
We can define a simple relabeling functor from the free category to itself:
\begin{minted}{python}
F = Functor(
    ob={x: y, y: z, z: x},
    ar={f: g, g: h, h: f})
assert F(f >> g >> h) == F(f) >> F(g) >> F(h) == g >> h >> f
\end{minted}
We can interpret our arrows as Python functions:
\begin{minted}{python}
G = Functor(
    ob={x: int, y: Iterable, z: int},
    ar={f: range, g: sum, h: lambda n: n * (n - 1) // 2},
    cod=Category(type, Function))
assert G(f >> g)(42) == G(h)(42) == 861
\end{minted}
We can interpret our arrows as matrices:
\begin{minted}{python}
H = Functor(
    ob={x: 1, y: 2, z: 2},
    ar={f: [[0, 1]], g: [[0, 1], [1, 0]], h: [[1], [0]]},
    cod=Category(int, Matrix))
assert H(f >> g) == H(h).transpose()
\end{minted}
We can even define functors into $\mathbf{Cat}$, i.e. interpret arrows as functors:
\begin{minted}{python}
I = Functor(
    ob={x: Category(Ob, Arrow), y: Category(Ob, Arrow), z: Category(int, Matrix)},
    ar={f: F, g: H},
    cod=Category(Category, Functor))
assert I(f >> g)(h) == H(F(h)) == H(f)
\end{minted}
\end{example}

\subsection{Quotient categories}\label{subsection:quotient-categories}

After free objects, another concept behind DisCoPy is that of a \emph{quotient object}.
Again, let's start with the example of a monoid $M$.
Suppose we're given a binary relation $R \sub M \times M$, then we can construct a quotient monoid $M / R$ with underlying set the equivalence classes of the smallest congruence generated by $R$.
That is, the smallest relation $(\sim_R) \sub M \times M$ such that:
\begin{itemize}
\item $x \sim_R y$ for all $(x, y) \in R$,
\item $x \sim_R x$ and if $x \sim_R y$ and $y \sim_R z$ then $x \sim_R z$,
\item if $x \sim_R x'$ and $y \sim_R y'$ then $x \times y \sim_R x' \times y'$.
\end{itemize}
The first point says that $R \sub (\sim_R)$.
The second says that $(\sim_R)$ is an equivalence relation.
The third says that $(\sim_R)$ is closed under products, it is equivalent to the substitution axiom: if $x \sim_R y$ then $a x b \sim_R a y b$ for all $a, b \in M$.
Explicitly, the congruence $(\sim_R)$ can be constructed in two steps: first, we define the \emph{rewriting relation} $(\to_R) \sub M \times M$ where $a x b \to_R a y b$ for all $(x, y) \in R$ and $a, b \in M$.
Second, we define $(\sim_R)$ as the \emph{symmetric, reflexive, transitive closure} of the rewriting relation, i.e. two elements $x, y \in M$ are equal in $M / R$ iff they are in the same connected component of the undirected graph induced by $(\to_R) \sub M \times M$.
Now there is a homomorphism $q : M \to M / R$ which sends monoid elements to their equivalence class with the following property: for any homomorphism $f : M \to N$ with $x \sim_R y$ implies $f(x) = f(y)$, there is a unique $f' : M / R \to N$ with $f = q \fcmp f'$.
Intuitively, a homomorphism from a quotient $M / R$ is nothing more than a homomorphism from $M$ which respects the axioms $R$.
Up to isomorphism, we can construct any monoid $M$ as the quotient $X^\star / R$ of a free monoid $X^\star$: take $X = U(M)$ and $R = \{ (x y, z) \in X^\star \times X^\star \s \vert \s x \times y = z \in M \}$.

The pair $(X, R \sub X^\star \times X^\star)$ of a set of generating elements $X$ and a binary relation $R$ on its free monoid is called a \emph{presentation} of the monoid $M \simeq X^\star / R$.
Arguably, the most fundamental computational problem is the \emph{word problem for monoids}: given a presentation $(X, R)$ and a pair of lists $x, y \in X^\star$, decide whether $x = y$ in $X^\star / R$.
As mentioned in the introduction, it was shown to be equivalent to Turing's halting problem, and thus undecidable, by Post~\cite{Post47} and Markov~\cite{Markov47}.
The proof is straightforward: we can encode the tape alphabet and the states of a Turing machine in the set $X$ and its transition table into the relation $R$, then whether the machine halts reduces to deciding $x = y$ for $x$ and $y$ the initial and accepting configurations respectively: a proof of equality corresponds precisely to a run of the Turing machine.

The case of quotient categories is similar, only we need to take care of objects now.
Given a category $C$ and a family of binary relations $\{ R_{x,y} \sub C(x, y) \times C(x, y) \}_{x, y \in C_0}$, we can construct a quotient category $C / R$ with equivalence classes as arrows.
There is a functor $Q : C \to C / R$ sending each arrow to its equivalence class, and for any functor $F : C \to D$ with $(f, g) \in R_{x, y}$ implies $F(f) = F(g)$,
there is a unique $F' : C / R \to D$ with $F = Q \fcmp F'$.
Intuitively, a functor from a quotient category $C / R$ is nothing more than a functor from $C$ which respects the axioms $R$.
Again, any small category $C$ is isomorphic to the quotient $F(\Sigma) / R$ of a free category $F(\Sigma)$: take $\Sigma = U(C)$ and $R = \{ (f \fcmp g, h) \in F(\Sigma) \times F(\Sigma) \s \vert \s f \fcmp g = h \in C \}$.
The pair $(\Sigma, R \sub \coprod_{x, y \in \Sigma_0} \Sigma(x, y) \times \Sigma(x, y))$ is called a presentation of the category $C \simeq F(\Sigma) / R$.
Since monoids are just categories with one object, the word problem for categories will be just as undecidable as for monoids.

What does it mean to implement a quotient category in Python?
Since presentations of categories are as expressive as Turing machines, we might as well avoid solving the halting problem and just use a Python function to define equality of arrows.
Implementing a quotient category is nothing more than implementing a free category and an equality function that respects the axioms of a congruence.
One straightforward way is to define equality of arrows $f, g$ in a free category $F(\Sigma)$ to be the equality of their interpretation $\eval{f} = \eval{g}$ under a functor $\eval{-} : F(\Sigma) \to D$ into a concrete category $D$ where equality is decidable.
Another method is to define a \emph{normal form} method which takes an arrow and returns the representative of its equivalence class, then identity of arrow is identity of their normal forms.

\begin{example} \label{example:1-qubit-presentation}
Take the signature $\Sigma$ with one object $\Sigma_0 = \{ 1 \}$ and four arrows $\Sigma_1  = \{ Z, X, H, -1 \}$ for the Z, X and Hadamard gate and the global $(-1)$ phase.
Let's define the relation $R$ induced by:
\begin{itemize}
    \item $H \fcmp X = Z \fcmp H$ and $Z \fcmp X = (-1) \fcmp X \fcmp Z$,
    \item $f \fcmp f = \id(1)$ and $f \fcmp (-1) = (-1) \fcmp f$ for all $f \in \Sigma_1$.
\end{itemize}
The quotient $F(\Sigma) / R$ is a subcategory of the category $\mathbf{Circ}$ of quantum circuits, it is isomorphic to the quotient induced by the interpretation $\eval{-} : F(\Sigma) \to \mathbf{Mat}_\C$.
Suppose we're given a functor $\mathtt{cost} : F(\Sigma) \to \R^+$, we can define the normal form of a circuit $f$ to be the representative of its equivalence class with the lowest cost.
Thus, deciding equality of circuits reduces to solving circuit optimisation perfectly.
\end{example}

\subsection{Daggers, sums and bubbles}\label{subsection:dagger-sums-bubbles}

We conclude this section by discussing three extra pieces of implementation beyond the basics of category theory: daggers, sums and bubbles.
A \emph{dagger} for a category $C$ can be thought of as a kind of time-reversal for arrows.
More precisely, a dagger is a contravariant endofunctor $\dagger : C \to C^{op}$, i.e. from the category to its opposite with $\dom$ and $\cod$ swapped, which is the identity on objects and an involution, i.e. $(\dagger) \fcmp (\dagger) = \id_\C$.
A $\dagger$-functor is a functor between $\dagger$-categories that commutes with the dagger, thus we get a category $\dagger-\mathbf{Cat}$.
The free $\dagger$-category is constructed as follows.
Define the functor $\dagger : \mathbf{Sig} \to \mathbf{Sig}$ which sends a signature $\Sigma$ to $\dagger(\Sigma)$ with
$\dagger(\Sigma)_0 = \Sigma_0$ and $\dagger(\Sigma)_1 = \{ -1, 1 \} \times \Sigma_1$ with $\dom(b, f) = \cod(f)$ if $b = -1$ else $\dom(f)$ and symmetrically for $\cod$.
Then the free dagger category is the quotient category $F(\dagger(\Sigma)) / R$ for the congruence generated by $(1, f) \fcmp (-1, f) \to_R \id(\dom(f))$ and $(-1, f) \fcmp (1, f) \to_R \id(f.cod)$.

\begin{example}
The conjugate transpose defines a dagger on the category $\mathbf{Mat}_\C$, the adjoint defines a dagger on the category $\mathbf{Circ}$ and the evaluation $\mathbf{Circ} \to \mathbf{Mat}_\C$ is a $\dagger$-functor.
By extension, there is a dagger structure on $\mathbf{Mat}_\S$ for each rig anti-homomorphism $\dagger : \S \to \S$, i.e. a homomorphism for the commutative addition and an anti-homomorphism for the (non-necessarily commutative) product $\dagger(a \times b) = \dagger(b) \times \dagger(a)$.
Thus, when $\S$ is a commutative rig such as the Boolean, $\mathbf{Mat}_\S$ is automatically a $\dagger$-category with the transpose as dagger and the identity as conjugation.
\end{example}

DisCoPy implements free $\dagger$-categories by adding an attribute \py{is_dagger: bool} to boxes and a method \py{Arrow.dagger}, shortened to the postfix operator \py{[::-1]}, which reverses the order of boxes and negates \py{is_dagger} elementwise.
The normal form is computable in linear time but it has not been implemented yet.
In order to implement the syntactic sugar \py{f[::-1] == f.dagger()}, we need to override the \py{__getitem__} method.
In general, DisCoPy defines indexing \py{f[i]} and slicing \py{f[start:stop:step]} so that \py{f[key].inside == f.inside[key]} for any \py{key: int} and any \py{key: slice} with \py{key.step in (-1, 1, None)}.
Although the case of negative indices (i.e. counting backwards from the end of the list) is implemented in DisCoPy, its interaction with list reversal is too complex to be listed here.

\begin{python}
{\normalfont Implementation of free $\dagger$-categories and $\dagger$-functors.}
\begin{minted}{python}
class Arrow(cat.Arrow):
    def dagger(self):
        return self.cast(Arrow(
            tuple(box.dagger() for box in self.inside[::-1]), self.cod, self.dom))

    def __getitem__(self, key: int | slice) -> Arrow:
        if isinstance(key, int): return self.cast(self.inside[key])
        if key.step not in (-1, 1, None): raise IndexError
        if key.step == -1:
            for i in (key.start, key.stop):
                if i is not None and i < 0: ...
            stop, start = (
                None if i is None else i + 1 for i in (key.stop, key.start))
            return self[start:stop].dagger()
        dom, cod = self[key.start].dom, self[key.stop].cod
        return self.cast(Arrow(self.inside[key], dom, cod))

class Box(cat.Box, Arrow):
    cast = Arrow.cast

    def __init__(self, name: str, dom: Ob, cod: Ob, is_dagger=False):
        self.is_dagger = is_dagger; cat.Box.__init__(self, name, dom, cod)

    def dagger(self):
        return type(self)(self.name, self.cod, self.dom, not self.is_dagger)

class Functor(cat.Functor):
    dom = cod = Category(Ob, Arrow)

    def __call__(self, other):
        if isinstance(other, Box) and other.is_dagger:
            return self(other.dagger()).dagger()
        return super().__call__(other)
\end{minted}
\end{python}

\begin{example}
We can show the dagger is indeed a contravariant endofunctor.

\begin{minted}{python}
x, y, z = map(Ty, "xyz")
f, g = Box('f', x, y), Box('g', y, z)

assert Diagram.id(x)[::-1] == Diagram.id(x)
assert (f >> g)[::-1] == g[::-1] >> f[::-1]
\end{minted}
\end{example}

\begin{python}
{\normalfont Implementation of $\mathbf{Mat}_\S$ as a $\dagger$-category.}

\begin{minted}{python}
def transpose(self: Matrix) -> Matrix:
    inside = [[self[j][i] for j in range(self.dom)] for i in range(self.cod)]
    return type(self)(inside, self.cod, self.dom)

def map(self: Matrix, func: Callable[[Number], Number]) -> Matrix:
    inside = [list(map(func, row)) for row in self.inside]
    return type(self)(inside, self.dom, self.cod)

Matrix.transpose, Matrix.map = transpose, map
Matrix.conjugate = lambda self: self.map(lambda x: x.conjugate())
Matrix.dagger = lambda self: self.conjugate().transpose()
\end{minted}
\end{python}

\begin{example}
We can implement a simulator for $1$-qubit circuits as a $\dagger$-functor.

\begin{minted}{python}
Circuit.eval = Functor(
    ob={Ob('1'): 2},
    ar={X: [[0, 1], [1, 0]],
        Y: [[0, -1j], [1j, 0]],
        Z: [[1, 0], [0, -1]],
        H: [[x / sqrt(2) for x in row] for row in [[1, 1], [1, -1]]]}
    cod=Category(int, Matrix[complex]))
\end{minted}

We can check that every circuit is \emph{unitary}, i.e. its dagger is also its inverse.

\begin{minted}{python}
for c in [X, Y, Z, H, X >> Y >> Z >> H]:
    assert (c >> c[::-1]).eval() == Matrix.id(2) == (c[::-1] >> c).eval()
\end{minted}

We can check the equations given in the presentation of example~\ref{example:1-qubit-presentation}.

\begin{minted}{python}
assert (Z >> H).eval() == (H >> X).eval()
assert (Z >> X).eval() == (X >> Z).eval().map(lambda x: -x)
for gate in [H, Z, X]: assert (gate >> gate).eval() == Matrix.id(2)
\end{minted}
\end{example}

A category $C$ has \emph{sums}, or equivalently $C$ is \emph{commutative-monoid-enriched}, when it comes equipped with a commutative monoid $(+, 0)$ on each homset $C(x, y)$ such that $f \fcmp 0 = 0 = 0 \fcmp f$ and $(f + f') \fcmp (g + g') = f \fcmp g + f \fcmp g' + f' \fcmp g + f' \fcmp g'$ for all arrows $f, g, f', g'$.
A functor $F : C \to D$ between categories with sums is commutative-monoid-enriched when $F(0) = 0$ and $F(f + g) = F(f) + F(g)$.
For example, the category $\mathbf{Mat}_\S$ has sums given by elementwise addition of matrices.
A commutative-monoid-enriched category with one object is precisely a rig.
Given a signature $\Sigma$, we construct the free category with sums $F^+(\Sigma)$ by taking the free commutative monoid over each homset of $F(\Sigma)$, i.e. arrows $f : x \to y$ in $F^+(\Sigma)$ are \emph{bags} (also called \emph{multisets}) of arrows $f_i : x \to y$ in $F(\Sigma)$.

In DisCoPy, free categories with sums are implemented by \py{Sum}, a subclass of \py{Box} with an attribute \py{terms: list[Arrow]} as well as its own \py{cast} method, which turns an arrow into the sum of just itself.
It is attached to the arrow with \py{Arrow.sum = Sum}.
The composition of a sum as the sum of the compositions of its terms, we also override \py{Arrow.then} so that \py{f >> (g + h) == Sum.cast(f) >> (g + h)} for any arrow \py{f}.
We define equality so that \py{f == Sum.cast(f)}, equality of bags of terms is implemented as equality of lists sorted by an arbitrary ordering.
DisCoPy functors are commutative-monoid-enriched, i.e. a formal sum of arrows can be interpreted as a concrete sum of matrices.

\begin{python}
{\normalfont Implementation of free sum-enriched categories and functors.}

\begin{minted}{python}
class Arrow(cat.Arrow):
    def __eq__(self, other):
        return other.terms == (self, ) if isinstance(other, Sum)\
            else super().__eq__(other)

    def then(self, other: Arrow) -> Arrow:
        return self.sum.cast(self).then(other) if isinstance(other, Sum)\
            else super().then(other)

    @staticmethod
    def zero(dom: Ob, cod: Ob) -> Arrow: return Sum((), dom, cod)

    __add__ = lambda self, other: self.sum.cast(self) + other
    __lt__ = lambda self, other: hash(self) < hash(other)  # An arbitrary order.

class Sum(cat.Box, Arrow):
    def __init__(self, terms: tuple[Arrow, ...], dom: Ob, cod: Ob):
        assert all(f.dom == dom and f.cod == cod for f in terms)
        self.terms, name = terms, "Sum({}, {}, [{}])".format(
            dom, cod, ", ".join(map(str, terms)))
        cat.Box.__init__(self, name, dom, cod)

    def __eq__(self, other):
        if isinstance(other, Sum):
            return (self.dom, self.cod, sorted(self.terms))\
                == (other.dom, other.cod, sorted(other.terms))
        return self.terms == (other, )

    def __add__(self, other):
        if not isinstance(other, Sum): return self + self.cast(other)
        return Sum(self.terms + other.terms, self.dom, self.cod)

    @classmethod
    def cast(cls, old: cat.Arrow) -> Sum:
        return old if isinstance(old, cls) else cls((old, ), old.dom, old.cod)

    @inductive
    def then(self, other):
        terms = tuple(f.then(g) for f in self.terms for g in self.cast(other).terms)
        return type(self)(terms, self.dom, other.cod)

    def dagger(self):
        return type(self)(tuple(f.dagger() for f in self.terms), self.cod, self.dom)

Arrow.sum = Sum

class Functor(cat.Functor):
    dom = cod = Category(Ob, Arrow)

    def __call__(self, other):
        if isinstance(other, Sum):
            unit = self.cod.ar.zero(self(other.dom), self(other.cod))
            return sum([self(f) for f in other.terms], unit)
        return super().__call__(other)
\end{minted}
\end{python}

\begin{python}
{\normalfont Implementation of $\mathbf{Mat}_\S$ as a category with sums.}

\begin{minted}{python}
class Matrix:
    ...
    def __add__(self: Matrix, other: Matrix) -> Matrix:
        inside = [[x + y for x, y in zip(u, v)]
                  for u, v in zip(self.inside, other.inside)]
        return type(self)(inside, self.dom, self.cod)

    @classmethod
    def zero(cls, dom: int, cod: int) -> Matrix:
        return cls([[0 for _ in range(cod)] for _ in range(dom)], dom, cod)
\end{minted}
\end{python}

A \emph{bubble} on a (subcategory of a) category $C$ is a pair of unary operators $\beta_\dom, \beta_\cod : C_0 \to C_0$ on objects and a unary operator between homsets $\beta : C(x, y) \to C(\beta_\dom(x), \beta_\cod(y))$ for (some) pairs of objects $x, y \in C_0$.
Given a signature $\Sigma$ and a pair $\beta_\dom, \beta_\cod : C_0 \to C_0$, we construct the free category with bubbles $F(\Sigma^\beta)$ by induction on the maximum level $n$ of bubble nesting: take the signature $\Sigma^\beta = \bigcup_{n \in \N} \Sigma^\beta_n$
for $\Sigma^\beta_0 = \Sigma$ and $\Sigma^\beta_{n + 1} = \Sigma + \{ \beta(f) \ \vert \ f \in F(\Sigma^\beta_n) \}$.
That is, box in $\Sigma^\beta$ is a box in $\Sigma^\beta_{n}$ for some $n \in \N$.
A box in $\Sigma^\beta_{n}$ is either a box in $\Sigma$ or an arrow $f : x \to y$ in $F(\Sigma^\beta_{n - 1})$ that we have put inside a bubble $\beta(f) : \beta_\dom(x) \to \beta_\cod(y)$.

\begin{example}\label{example:endofunctor-bubbles}
Any endofunctor $\beta : C \to C$ also defines a bubble, thus we can define a bubble-preserving functor $F(U(C)^\beta) \to C$ which interprets bubbles as functor application.
Any functor between two categories $C$ and $D$ defines a bubble on their disjoint union $C + D$ (i.e. with objects $C_0 + D_0$ and arrows $C_1 + D_1$).
These functor bubbles have also been called \emph{functorial boxes}~\cite{Mellies06}.
\end{example}

\begin{example}
An \emph{exponential rig} is a one-object category $\S$ with sums and a bubble $\exp : \S \to \S$ which is a homomorphism from sum to product, i.e. $\exp(a + b) = \exp(a) \exp(b)$ and $\exp(0) = 1$.
Any rig $\S$ is an exponetial rig by taking $\exp(a) = 1$ for all $a \in \S$.
Non-trivial examples include the complex numbers as well as the Boolean rig with negation.
Thus, exponential rigs provide enough syntax to define the matrices of most quantum gates, as well as any propositional logic formula.
\end{example}

\begin{example}
Matrix exponential is a bubble on the subcategory of square matrices, with the property that $\exp(f + g) = \exp(f) \fcmp \exp(g)$ whenever $f \fcmp g = g \fcmp f$.
Also, any function $\S \to \S$ yields a bubble on $\mathbf{Mat}_\S$ given by element-wise application.
For example, we can define a bubble on the category $\mathbf{Mat}_\B$ of Boolean matrices which sends each matrix $f$ to its entrywise negation $\bar{f}$.
\end{example}

DisCoPy implements free bubbles with \py{Bubble}, a subclass of \py{Box} which we attach to the arrow class with \py{Arrow.bubble = Bubble}.
\py{Bubble} has attributes \py{diagram: Arrow} as well as optional arguments \py{dom: Ob}, \py{cod: Ob} and \py{method: str}.
DisCoPy functors interpret bubbles as the application of \py{method} in the codomain category, by default we send bubbles to bubbles.
The resulting syntax is strictly more expressive than that of free categories alone.
For example, element-wise negation cannot be expressed as a composition: there is no matrix $N : x \to x$ in $\mathbf{Mat}_\B$ such that $N \fcmp f = \bar{f}$ for all $f : x \to y$.
This is also the case for the element-wise application of any non-linear function such as the rectified linear units (ReLU) used in machine learning.
As we will discuss in section~\ref{section-3:diag-diff}, differentiation of parameterised matrices cannot be expressed as a composition either, but it is a unary operator between homsets, i.e. a bubble.

\begin{python}
{\normalfont Implementation of free categories with bubbles and their functors.}

\begin{minted}{python}
class Bubble(Box):
    def __init__(self, diagram: Arrow, dom=None, cod=None, method="bubble", is_dagger=False):
        self.diagram, self.method = diagram, method
        dom, cod = dom or diagram.dom, cod or diagram.cod
        name = "Bubble({}, {}, {}, {})".format(diagram, dom, cod, method)
        super().__init__(name, dom, cod, **params)

    dagger = lambda self: type(self)(
        self.diagram, self.dom, self.cod, self.method, is_dagger=not self.is_dagger)
    is_id_on_objects = property(lambda self:
        self.dom == self.diagram.dom and self.cod == self.diagram.cod)

Arrow.bubble = Bubble

class Functor(cat.Functor):
    def __call__(self, other):
        if isinstance(other, Bubble):
            method = getattr(self.cod.ar, other.method)
            return method(self(other.diagram)) if other.is_id_on_objects\
                else method(self(other.diagram), self(other.dom), self(other.cod))
        return super().__call__(other)
\end{minted}
\end{python}

\begin{example}\label{example:neural-net}
We can encode the architecture of a neural network as an arrow with sums and bubbles, encoding vector addition and non-linear activation function respectively.
The evaluation of the neural network on some input vector for some parameters is given by the application of a sum-and-bubble-preserving functor into $\mathbf{Mat}_\R$.
The hyper-parameters (i.e. the number of neurons at each layer) are given by the image of the functor on objects.

\begin{minted}{python}
Matrix.ReLU = lambda self: self.map(lambda x: max(x, 0))

vector, bias = Box('vector', x, y), Box('bias', x, x)
ones, weights = Box('ones', x, y), Box('weights', y, z)
network = ((vector + (bias >> ones)) >> weights).bubble(method="ReLU")

F = Functor(
    ob={x: 1, y: 4, z: 2},
    ar={vector: [[1.2, -2.3, 3.4, -4.5]],
        bias: [[-3.14]], ones: [[1, 1, 1, 1]]
        weights: [[5.6, -6.7, 7.8, -8.9],
                  [9.0, -0.1, 2.3, -3.4]]},
    cod=Category(int, Matrix[float]))

assert F(network) == F(vector).map(lambda x: x + F(bias))\
                              .then(F(weights)).map(lambda x: max(0, x))
\end{minted}
\end{example}

\begin{example}\label{example:propositional-logic}
We can implement propositional logic with boxes as propositions, composition as conjunction, sum as disjunction and bubble as negation.
The evaluation of a formula in a model corresponds to the application of a sum-and-bubble-preserving functor into $\mathbf{Mat}_\B(1, 1)$.

\begin{minted}{python}
Matrix._not = lambda self: self.map(lambda x: not x)

class Formula(Arrow):
    _not = lambda self: self.bubble(method="_not")

class Proposition(Box, Formula):
    def __init__(self, name): Box.__init__(self, name, Ob('x'), Ob('x'))

def model(data: dict[Proposition, bool]):
    return Functor(ob={Ob('x'): 1}, ar={p: [[data[p]]] for p in data},
                   dom=Category(Ob, Formula), cod=Category(int, Matrix[bool]))

p, q = map(Proposition, "pq")
p_implies_q = (q._not() >> p)._not()
not_p_or_q = p._not() + q

for a, b in itertools.product([0, 1], [0, 1]):
    F = model({p: a, q: b})
    assert F(p_implies_q) == not (not F(q) and F(p))\
        == F(not_p_or_q) == not F(p) or F(q)
\end{minted}
\end{example}

\begin{remark}
The constructions for dagger, sums and bubbles all commute with each other.
Moreover, there is cube of faithful functors which embed free categories in free $\dagger$-categories with sums and bubbles.
Thus, they are all implemented by default in the same class \py{Arrow}.
\end{remark}
